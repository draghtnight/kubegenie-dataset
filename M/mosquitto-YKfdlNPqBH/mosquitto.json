[
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "release-name-mosquitto",
      "labels": {
        "app.kubernetes.io/name": "mosquitto",
        "helm.sh/chart": "mosquitto-0.2.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.6.10",
        "app.kubernetes.io/managed-by": "Helm"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-mosquitto",
      "labels": {
        "app.kubernetes.io/name": "mosquitto",
        "helm.sh/chart": "mosquitto-0.2.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.6.10",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "data": {
      "mosquitto.conf": "# Config file for mosquitto\n#\n# See mosquitto.conf(5) for more information.\n#\n# Default values are shown, uncomment to change.\n#\n# Use the # character to indicate a comment, but only if it is the\n# very first character on the line.\n\n# =================================================================\n# General configuration\n# =================================================================\n\n# Use per listener security settings.\n#\n# It is recommended this option be set before any other options.\n#\n# If this option is set to true, then all authentication and access control\n# options are controlled on a per listener basis. The following options are\n# affected:\n#\n# password_file acl_file psk_file auth_plugin auth_opt_* allow_anonymous\n# auto_id_prefix allow_zero_length_clientid\n#\n# Note that if set to true, then a durable client (i.e. with clean session set\n# to false) that has disconnected will use the ACL settings defined for the\n# listener that it was most recently connected to.\n#\n# The default behaviour is for this to be set to false, which maintains the\n# setting behaviour from previous versions of mosquitto.\n#per_listener_settings false\n\n\n# If a client is subscribed to multiple subscriptions that overlap, e.g. foo/#\n# and foo/+/baz , then MQTT expects that when the broker receives a message on\n# a topic that matches both subscriptions, such as foo/bar/baz, then the client\n# should only receive the message once.\n# Mosquitto keeps track of which clients a message has been sent to in order to\n# meet this requirement. The allow_duplicate_messages option allows this\n# behaviour to be disabled, which may be useful if you have a large number of\n# clients subscribed to the same set of topics and are very concerned about\n# minimising memory usage.\n# It can be safely set to true if you know in advance that your clients will\n# never have overlapping subscriptions, otherwise your clients must be able to\n# correctly deal with duplicate messages even when then have QoS=2.\n#allow_duplicate_messages false\n\n# This option controls whether a client is allowed to connect with a zero\n# length client id or not. This option only affects clients using MQTT v3.1.1\n# and later. If set to false, clients connecting with a zero length client id\n# are disconnected. If set to true, clients will be allocated a client id by\n# the broker. This means it is only useful for clients with clean session set\n# to true.\n#allow_zero_length_clientid true\n\n# If allow_zero_length_clientid is true, this option allows you to set a prefix\n# to automatically generated client ids to aid visibility in logs.\n# Defaults to 'auto-'\n#auto_id_prefix auto-\n\n# This option affects the scenario when a client subscribes to a topic that has\n# retained messages. It is possible that the client that published the retained\n# message to the topic had access at the time they published, but that access\n# has been subsequently removed. If check_retain_source is set to true, the\n# default, the source of a retained message will be checked for access rights\n# before it is republished. When set to false, no check will be made and the\n# retained message will always be published. This affects all listeners.\n#check_retain_source true\n\n# QoS 1 and 2 messages will be allowed inflight per client until this limit\n# is exceeded.  Defaults to 0. (No maximum)\n# See also max_inflight_messages\n#max_inflight_bytes 0\n\n# The maximum number of QoS 1 and 2 messages currently inflight per\n# client.\n# This includes messages that are partway through handshakes and\n# those that are being retried. Defaults to 20. Set to 0 for no\n# maximum. Setting to 1 will guarantee in-order delivery of QoS 1\n# and 2 messages.\n#max_inflight_messages 20\n\n# For MQTT v5 clients, it is possible to have the server send a \"server\n# keepalive\" value that will override the keepalive value set by the client.\n# This is intended to be used as a mechanism to say that the server will\n# disconnect the client earlier than it anticipated, and that the client should\n# use the new keepalive value. The max_keepalive option allows you to specify\n# that clients may only connect with keepalive less than or equal to this\n# value, otherwise they will be sent a server keepalive telling them to use\n# max_keepalive. This only applies to MQTT v5 clients. The maximum value\n# allowable is 65535. Do not set below 10.\n#max_keepalive 65535\n\n# For MQTT v5 clients, it is possible to have the server send a \"maximum packet\n# size\" value that will instruct the client it will not accept MQTT packets\n# with size greater than max_packet_size bytes. This applies to the full MQTT\n# packet, not just the payload. Setting this option to a positive value will\n# set the maximum packet size to that number of bytes. If a client sends a\n# packet which is larger than this value, it will be disconnected. This applies\n# to all clients regardless of the protocol version they are using, but v3.1.1\n# and earlier clients will of course not have received the maximum packet size\n# information. Defaults to no limit. Setting below 20 bytes is forbidden\n# because it is likely to interfere with ordinary client operation, even with\n# very small payloads.\n#max_packet_size 0\n\n# QoS 1 and 2 messages above those currently in-flight will be queued per\n# client until this limit is exceeded.  Defaults to 0. (No maximum)\n# See also max_queued_messages.\n# If both max_queued_messages and max_queued_bytes are specified, packets will\n# be queued until the first limit is reached.\n#max_queued_bytes 0\n\n# The maximum number of QoS 1 and 2 messages to hold in a queue per client\n# above those that are currently in-flight.  Defaults to 100. Set\n# to 0 for no maximum (not recommended).\n# See also queue_qos0_messages.\n# See also max_queued_bytes.\n#max_queued_messages 100\n#\n# This option sets the maximum number of heap memory bytes that the broker will\n# allocate, and hence sets a hard limit on memory use by the broker.  Memory\n# requests that exceed this value will be denied. The effect will vary\n# depending on what has been denied. If an incoming message is being processed,\n# then the message will be dropped and the publishing client will be\n# disconnected. If an outgoing message is being sent, then the individual\n# message will be dropped and the receiving client will be disconnected.\n# Defaults to no limit.\n#memory_limit 0\n\n# This option sets the maximum publish payload size that the broker will allow.\n# Received messages that exceed this size will not be accepted by the broker.\n# The default value is 0, which means that all valid MQTT messages are\n# accepted. MQTT imposes a maximum payload size of 268435455 bytes.\n#message_size_limit 0\n\n# This option allows persistent clients (those with clean session set to false)\n# to be removed if they do not reconnect within a certain time frame.\n#\n# This is a non-standard option in MQTT V3.1 but allowed in MQTT v3.1.1.\n#\n# Badly designed clients may set clean session to false whilst using a randomly\n# generated client id. This leads to persistent clients that will never\n# reconnect. This option allows these clients to be removed.\n#\n# The expiration period should be an integer followed by one of h d w m y for\n# hour, day, week, month and year respectively. For example\n#\n# persistent_client_expiration 2m\n# persistent_client_expiration 14d\n# persistent_client_expiration 1y\n#\n# The default if not set is to never expire persistent clients.\n#persistent_client_expiration\n\n# Write process id to a file. Default is a blank string which means\n# a pid file shouldn't be written.\n# This should be set to /var/run/mosquitto.pid if mosquitto is\n# being run automatically on boot with an init script and\n# start-stop-daemon or similar.\n#pid_file\n\n# Set to true to queue messages with QoS 0 when a persistent client is\n# disconnected. These messages are included in the limit imposed by\n# max_queued_messages and max_queued_bytes\n# Defaults to false.\n# This is a non-standard option for the MQTT v3.1 spec but is allowed in\n# v3.1.1.\n#queue_qos0_messages false\n\n# Set to false to disable retained message support. If a client publishes a\n# message with the retain bit set, it will be disconnected if this is set to\n# false.\n#retain_available true\n\n# Disable Nagle's algorithm on client sockets. This has the effect of reducing\n# latency of individual messages at the potential cost of increasing the number\n# of packets being sent.\n#set_tcp_nodelay false\n\n# Time in seconds between updates of the $SYS tree.\n# Set to 0 to disable the publishing of the $SYS tree.\n#sys_interval 10\n\n# The MQTT specification requires that the QoS of a message delivered to a\n# subscriber is never upgraded to match the QoS of the subscription. Enabling\n# this option changes this behaviour. If upgrade_outgoing_qos is set true,\n# messages sent to a subscriber will always match the QoS of its subscription.\n# This is a non-standard option explicitly disallowed by the spec.\n#upgrade_outgoing_qos false\n\n# When run as root, drop privileges to this user and its primary\n# group.\n# Set to root to stay as root, but this is not recommended.\n# If run as a non-root user, this setting has no effect.\n# Note that on Windows this has no effect and so mosquitto should\n# be started by the user you wish it to run as.\n#user mosquitto\n\n# =================================================================\n# Default listener\n# =================================================================\n\n# IP address/hostname to bind the default listener to. If not\n# given, the default listener will not be bound to a specific\n# address and so will be accessible to all network interfaces.\n# bind_address ip-address/host name\n#bind_address\n\n# Port to use for the default listener.\n#port 1883\n\n# Bind the listener to a specific interface. This is similar to\n# bind_address above but is useful when an interface has multiple addresses or\n# the address may change. It is valid to use this with the bind_address option,\n# but take care that the interface you are binding to contains the address you\n# are binding to, otherwise you will not be able to connect.\n# Example: bind_interface eth0\n#bind_interface\n\n# When a listener is using the websockets protocol, it is possible to serve\n# http data as well. Set http_dir to a directory which contains the files you\n# wish to serve. If this option is not specified, then no normal http\n# connections will be possible.\n#http_dir\n\n# The maximum number of client connections to allow. This is\n# a per listener setting.\n# Default is -1, which means unlimited connections.\n# Note that other process limits mean that unlimited connections\n# are not really possible. Typically the default maximum number of\n# connections possible is around 1024.\n#max_connections -1\n\n# Choose the protocol to use when listening.\n# This can be either mqtt or websockets.\n# Websockets support is currently disabled by default at compile time.\n# Certificate based TLS may be used with websockets, except that\n# only the cafile, certfile, keyfile and ciphers options are supported.\n#protocol mqtt\n\n# Set use_username_as_clientid to true to replace the clientid that a client\n# connected with with its username. This allows authentication to be tied to\n# the clientid, which means that it is possible to prevent one client\n# disconnecting another by using the same clientid.\n# If a client connects with no username it will be disconnected as not\n# authorised when this option is set to true.\n# Do not use in conjunction with clientid_prefixes.\n# See also use_identity_as_username.\n#use_username_as_clientid\n\n# -----------------------------------------------------------------\n# Certificate based SSL/TLS support\n# -----------------------------------------------------------------\n# The following options can be used to enable SSL/TLS support for\n# this listener. Note that the recommended port for MQTT over TLS\n# is 8883, but this must be set manually.\n#\n# See also the mosquitto-tls man page.\n\n# At least one of cafile or capath must be defined. They both\n# define methods of accessing the PEM encoded Certificate\n# Authority certificates that have signed your server certificate\n# and that you wish to trust.\n# cafile defines the path to a file containing the CA certificates.\n# capath defines a directory that will be searched for files\n# containing the CA certificates. For capath to work correctly, the\n# certificate files must have \".crt\" as the file ending and you must run\n# \"openssl rehash <path to capath>\" each time you add/remove a certificate.\n#cafile\n#capath\n\n# Path to the PEM encoded server certificate.\n#certfile\n\n# Path to the PEM encoded keyfile.\n#keyfile\n\n\n# If you have require_certificate set to true, you can create a certificate\n# revocation list file to revoke access to particular client certificates. If\n# you have done this, use crlfile to point to the PEM encoded revocation file.\n#crlfile\n\n# If you wish to control which encryption ciphers are used, use the ciphers\n# option. The list of available ciphers can be obtained using the \"openssl\n# ciphers\" command and should be provided in the same format as the output of\n# that command.\n# If unset defaults to DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:@STRENGTH\n#ciphers DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:@STRENGTH\n\n# To allow the use of ephemeral DH key exchange, which provides forward\n# security, the listener must load DH parameters. This can be specified with\n# the dhparamfile option. The dhparamfile can be generated with the command\n# e.g. \"openssl dhparam -out dhparam.pem 2048\"\n#dhparamfile\n\n# By default a TLS enabled listener will operate in a similar fashion to a\n# https enabled web server, in that the server has a certificate signed by a CA\n# and the client will verify that it is a trusted certificate. The overall aim\n# is encryption of the network traffic. By setting require_certificate to true,\n# the client must provide a valid certificate in order for the network\n# connection to proceed. This allows access to the broker to be controlled\n# outside of the mechanisms provided by MQTT.\n#require_certificate false\n\n# This option defines the version of the TLS protocol to use for this listener.\n# The default value allows all of v1.3, v1.2 and v1.1. The valid values are\n# tlsv1.3 tlsv1.2 and tlsv1.1.\n#tls_version\n\n# If require_certificate is true, you may set use_identity_as_username to true\n# to use the CN value from the client certificate as a username. If this is\n# true, the password_file option will not be used for this listener.\n# This takes priority over use_subject_as_username.\n# See also use_subject_as_username.\n#use_identity_as_username false\n\n# If require_certificate is true, you may set use_subject_as_username to true\n# to use the complete subject value from the client certificate as a username.\n# If this is true, the password_file option will not be used for this listener.\n# See also use_identity_as_username\n#use_subject_as_username false\n\n# -----------------------------------------------------------------\n# Pre-shared-key based SSL/TLS support\n# -----------------------------------------------------------------\n# The following options can be used to enable PSK based SSL/TLS support for\n# this listener. Note that the recommended port for MQTT over TLS is 8883, but\n# this must be set manually.\n#\n# See also the mosquitto-tls man page and the \"Certificate based SSL/TLS\n# support\" section. Only one of certificate or PSK encryption support can be\n# enabled for any listener.\n\n# The psk_hint option enables pre-shared-key support for this listener and also\n# acts as an identifier for this listener. The hint is sent to clients and may\n# be used locally to aid authentication. The hint is a free form string that\n# doesn't have much meaning in itself, so feel free to be creative.\n# If this option is provided, see psk_file to define the pre-shared keys to be\n# used or create a security plugin to handle them.\n#psk_hint\n\n# When using PSK, the encryption ciphers used will be chosen from the list of\n# available PSK ciphers. If you want to control which ciphers are available,\n# use the \"ciphers\" option.  The list of available ciphers can be obtained\n# using the \"openssl ciphers\" command and should be provided in the same format\n# as the output of that command.\n#ciphers\n\n# Set use_identity_as_username to have the psk identity sent by the client used\n# as its username. Authentication will be carried out using the PSK rather than\n# the MQTT username/password and so password_file will not be used for this\n# listener.\n#use_identity_as_username false\n\n\n# =================================================================\n# Extra listeners\n# =================================================================\n\n# Listen on a port/ip address combination. By using this variable\n# multiple times, mosquitto can listen on more than one port. If\n# this variable is used and neither bind_address nor port given,\n# then the default listener will not be started.\n# The port number to listen on must be given. Optionally, an ip\n# address or host name may be supplied as a second argument. In\n# this case, mosquitto will attempt to bind the listener to that\n# address and so restrict access to the associated network and\n# interface. By default, mosquitto will listen on all interfaces.\n# Note that for a websockets listener it is not possible to bind to a host\n# name.\n# listener port-number [ip address/host name]\n#listener\n\n# Bind the listener to a specific interface. This is similar to\n# the [ip address/host name] part of the listener definition, but is useful\n# when an interface has multiple addresses or the address may change. It is\n# valid to use this with the [ip address/host name] part of the listener\n# definition, but take care that the interface you are binding to contains the\n# address you are binding to, otherwise you will not be able to connect.\n# Only available on Linux and requires elevated privileges.\n#\n# Example: bind_interface eth0\n#bind_interface\n\n# When a listener is using the websockets protocol, it is possible to serve\n# http data as well. Set http_dir to a directory which contains the files you\n# wish to serve. If this option is not specified, then no normal http\n# connections will be possible.\n#http_dir\n\n# The maximum number of client connections to allow. This is\n# a per listener setting.\n# Default is -1, which means unlimited connections.\n# Note that other process limits mean that unlimited connections\n# are not really possible. Typically the default maximum number of\n# connections possible is around 1024.\n#max_connections -1\n\n# The listener can be restricted to operating within a topic hierarchy using\n# the mount_point option. This is achieved be prefixing the mount_point string\n# to all topics for any clients connected to this listener. This prefixing only\n# happens internally to the broker; the client will not see the prefix.\n#mount_point\n\n# Choose the protocol to use when listening.\n# This can be either mqtt or websockets.\n# Certificate based TLS may be used with websockets, except that only the\n# cafile, certfile, keyfile and ciphers options are supported.\n#protocol mqtt\n\n# Set use_username_as_clientid to true to replace the clientid that a client\n# connected with with its username. This allows authentication to be tied to\n# the clientid, which means that it is possible to prevent one client\n# disconnecting another by using the same clientid.\n# If a client connects with no username it will be disconnected as not\n# authorised when this option is set to true.\n# Do not use in conjunction with clientid_prefixes.\n# See also use_identity_as_username.\n#use_username_as_clientid\n\n# Change the websockets headers size. This is a global option, it is not\n# possible to set per listener. This option sets the size of the buffer used in\n# the libwebsockets library when reading HTTP headers. If you are passing large\n# header data such as cookies then you may need to increase this value. If left\n# unset, or set to 0, then the default of 1024 bytes will be used.\n#websockets_headers_size\n\n# -----------------------------------------------------------------\n# Certificate based SSL/TLS support\n# -----------------------------------------------------------------\n# The following options can be used to enable certificate based SSL/TLS support\n# for this listener. Note that the recommended port for MQTT over TLS is 8883,\n# but this must be set manually.\n#\n# See also the mosquitto-tls man page and the \"Pre-shared-key based SSL/TLS\n# support\" section. Only one of certificate or PSK encryption support can be\n# enabled for any listener.\n\n# At least one of cafile or capath must be defined to enable certificate based\n# TLS encryption. They both define methods of accessing the PEM encoded\n# Certificate Authority certificates that have signed your server certificate\n# and that you wish to trust.\n# cafile defines the path to a file containing the CA certificates.\n# capath defines a directory that will be searched for files\n# containing the CA certificates. For capath to work correctly, the\n# certificate files must have \".crt\" as the file ending and you must run\n# \"openssl rehash <path to capath>\" each time you add/remove a certificate.\n#cafile\n#capath\n\n# Path to the PEM encoded server certificate.\n#certfile\n\n# Path to the PEM encoded keyfile.\n#keyfile\n\n\n# If you wish to control which encryption ciphers are used, use the ciphers\n# option. The list of available ciphers can be optained using the \"openssl\n# ciphers\" command and should be provided in the same format as the output of\n# that command.\n#ciphers\n\n# If you have require_certificate set to true, you can create a certificate\n# revocation list file to revoke access to particular client certificates. If\n# you have done this, use crlfile to point to the PEM encoded revocation file.\n#crlfile\n\n# To allow the use of ephemeral DH key exchange, which provides forward\n# security, the listener must load DH parameters. This can be specified with\n# the dhparamfile option. The dhparamfile can be generated with the command\n# e.g. \"openssl dhparam -out dhparam.pem 2048\"\n#dhparamfile\n\n# By default an TLS enabled listener will operate in a similar fashion to a\n# https enabled web server, in that the server has a certificate signed by a CA\n# and the client will verify that it is a trusted certificate. The overall aim\n# is encryption of the network traffic. By setting require_certificate to true,\n# the client must provide a valid certificate in order for the network\n# connection to proceed. This allows access to the broker to be controlled\n# outside of the mechanisms provided by MQTT.\n#require_certificate false\n\n# If require_certificate is true, you may set use_identity_as_username to true\n# to use the CN value from the client certificate as a username. If this is\n# true, the password_file option will not be used for this listener.\n#use_identity_as_username false\n\n# -----------------------------------------------------------------\n# Pre-shared-key based SSL/TLS support\n# -----------------------------------------------------------------\n# The following options can be used to enable PSK based SSL/TLS support for\n# this listener. Note that the recommended port for MQTT over TLS is 8883, but\n# this must be set manually.\n#\n# See also the mosquitto-tls man page and the \"Certificate based SSL/TLS\n# support\" section. Only one of certificate or PSK encryption support can be\n# enabled for any listener.\n\n# The psk_hint option enables pre-shared-key support for this listener and also\n# acts as an identifier for this listener. The hint is sent to clients and may\n# be used locally to aid authentication. The hint is a free form string that\n# doesn't have much meaning in itself, so feel free to be creative.\n# If this option is provided, see psk_file to define the pre-shared keys to be\n# used or create a security plugin to handle them.\n#psk_hint\n\n# When using PSK, the encryption ciphers used will be chosen from the list of\n# available PSK ciphers. If you want to control which ciphers are available,\n# use the \"ciphers\" option.  The list of available ciphers can be optained\n# using the \"openssl ciphers\" command and should be provided in the same format\n# as the output of that command.\n#ciphers\n\n# Set use_identity_as_username to have the psk identity sent by the client used\n# as its username. Authentication will be carried out using the PSK rather than\n# the MQTT username/password and so password_file will not be used for this\n# listener.\n#use_identity_as_username false\n\n\n# =================================================================\n# Persistence\n# =================================================================\n\n# If persistence is enabled, save the in-memory database to disk\n# every autosave_interval seconds. If set to 0, the persistence\n# database will only be written when mosquitto exits. See also\n# autosave_on_changes.\n# Note that writing of the persistence database can be forced by\n# sending mosquitto a SIGUSR1 signal.\n#autosave_interval 1800\n\n# If true, mosquitto will count the number of subscription changes, retained\n# messages received and queued messages and if the total exceeds\n# autosave_interval then the in-memory database will be saved to disk.\n# If false, mosquitto will save the in-memory database to disk by treating\n# autosave_interval as a time in seconds.\n#autosave_on_changes false\n\n# Save persistent message data to disk (true/false).\n# This saves information about all messages, including\n# subscriptions, currently in-flight messages and retained\n# messages.\n# retained_persistence is a synonym for this option.\n#persistence false\n\n# The filename to use for the persistent database, not including\n# the path.\n#persistence_file mosquitto.db\n\n# Location for persistent database. Must include trailing /\n# Default is an empty string (current directory).\n# Set to e.g. /var/lib/mosquitto/ if running as a proper service on Linux or\n# similar.\n#persistence_location\n\n\n# =================================================================\n# Logging\n# =================================================================\n\n# Places to log to. Use multiple log_dest lines for multiple\n# logging destinations.\n# Possible destinations are: stdout stderr syslog topic file\n#\n# stdout and stderr log to the console on the named output.\n#\n# syslog uses the userspace syslog facility which usually ends up\n# in /var/log/messages or similar.\n#\n# topic logs to the broker topic '$SYS/broker/log/<severity>',\n# where severity is one of D, E, W, N, I, M which are debug, error,\n# warning, notice, information and message. Message type severity is used by\n# the subscribe/unsubscribe log_types and publishes log messages to\n# $SYS/broker/log/M/susbcribe or $SYS/broker/log/M/unsubscribe.\n#\n# The file destination requires an additional parameter which is the file to be\n# logged to, e.g. \"log_dest file /var/log/mosquitto.log\". The file will be\n# closed and reopened when the broker receives a HUP signal. Only a single file\n# destination may be configured.\n#\n# Note that if the broker is running as a Windows service it will default to\n# \"log_dest none\" and neither stdout nor stderr logging is available.\n# Use \"log_dest none\" if you wish to disable logging.\n#log_dest stderr\n\n# Types of messages to log. Use multiple log_type lines for logging\n# multiple types of messages.\n# Possible types are: debug, error, warning, notice, information,\n# none, subscribe, unsubscribe, websockets, all.\n# Note that debug type messages are for decoding the incoming/outgoing\n# network packets. They are not logged in \"topics\".\n#log_type error\n#log_type warning\n#log_type notice\n#log_type information\n\n\n# If set to true, client connection and disconnection messages will be included\n# in the log.\n#connection_messages true\n\n# If using syslog logging (not on Windows), messages will be logged to the\n# \"daemon\" facility by default. Use the log_facility option to choose which of\n# local0 to local7 to log to instead. The option value should be an integer\n# value, e.g. \"log_facility 5\" to use local5.\n#log_facility\n\n# If set to true, add a timestamp value to each log message.\n#log_timestamp true\n\n# Set the format of the log timestamp. If left unset, this is the number of\n# seconds since the Unix epoch.\n# This is a free text string which will be passed to the strftime function. To\n# get an ISO 8601 datetime, for example:\n# log_timestamp_format %Y-%m-%dT%H:%M:%S\n#log_timestamp_format\n\n# Change the websockets logging level. This is a global option, it is not\n# possible to set per listener. This is an integer that is interpreted by\n# libwebsockets as a bit mask for its lws_log_levels enum. See the\n# libwebsockets documentation for more details. \"log_type websockets\" must also\n# be enabled.\n#websockets_log_level 0\n\n\n# =================================================================\n# Security\n# =================================================================\n\n# If set, only clients that have a matching prefix on their\n# clientid will be allowed to connect to the broker. By default,\n# all clients may connect.\n# For example, setting \"secure-\" here would mean a client \"secure-\n# client\" could connect but another with clientid \"mqtt\" couldn't.\n#clientid_prefixes\n\n# Boolean value that determines whether clients that connect\n# without providing a username are allowed to connect. If set to\n# false then a password file should be created (see the\n# password_file option) to control authenticated client access.\n#\n# Defaults to true if no other security options are set. If `password_file` or\n# `psk_file` is set, or if an authentication plugin is loaded which implements\n# username/password or TLS-PSK checks, then `allow_anonymous` defaults to\n# false.\n#\n#allow_anonymous true\n\n# -----------------------------------------------------------------\n# Default authentication and topic access control\n# -----------------------------------------------------------------\n\n# Control access to the broker using a password file. This file can be\n# generated using the mosquitto_passwd utility. If TLS support is not compiled\n# into mosquitto (it is recommended that TLS support should be included) then\n# plain text passwords are used, in which case the file should be a text file\n# with lines in the format:\n# username:password\n# The password (and colon) may be omitted if desired, although this\n# offers very little in the way of security.\n#\n# See the TLS client require_certificate and use_identity_as_username options\n# for alternative authentication options. If an auth_plugin is used as well as\n# password_file, the auth_plugin check will be made first.\n#password_file\n\n# Access may also be controlled using a pre-shared-key file. This requires\n# TLS-PSK support and a listener configured to use it. The file should be text\n# lines in the format:\n# identity:key\n# The key should be in hexadecimal format without a leading \"0x\".\n# If an auth_plugin is used as well, the auth_plugin check will be made first.\n#psk_file\n\n# Control access to topics on the broker using an access control list\n# file. If this parameter is defined then only the topics listed will\n# have access.\n# If the first character of a line of the ACL file is a # it is treated as a\n# comment.\n# Topic access is added with lines of the format:\n#\n# topic [read|write|readwrite] <topic>\n#\n# The access type is controlled using \"read\", \"write\" or \"readwrite\". This\n# parameter is optional (unless <topic> contains a space character) - if not\n# given then the access is read/write.  <topic> can contain the + or #\n# wildcards as in subscriptions.\n#\n# The first set of topics are applied to anonymous clients, assuming\n# allow_anonymous is true. User specific topic ACLs are added after a\n# user line as follows:\n#\n# user <username>\n#\n# The username referred to here is the same as in password_file. It is\n# not the clientid.\n#\n#\n# If is also possible to define ACLs based on pattern substitution within the\n# topic. The patterns available for substition are:\n#\n# %c to match the client id of the client\n# %u to match the username of the client\n#\n# The substitution pattern must be the only text for that level of hierarchy.\n#\n# The form is the same as for the topic keyword, but using pattern as the\n# keyword.\n# Pattern ACLs apply to all users even if the \"user\" keyword has previously\n# been given.\n#\n# If using bridges with usernames and ACLs, connection messages can be allowed\n# with the following pattern:\n# pattern write $SYS/broker/connection/%c/state\n#\n# pattern [read|write|readwrite] <topic>\n#\n# Example:\n#\n# pattern write sensor/%u/data\n#\n# If an auth_plugin is used as well as acl_file, the auth_plugin check will be\n# made first.\n#acl_file\n\n# -----------------------------------------------------------------\n# External authentication and topic access plugin options\n# -----------------------------------------------------------------\n\n# External authentication and access control can be supported with the\n# auth_plugin option. This is a path to a loadable plugin. See also the\n# auth_opt_* options described below.\n#\n# The auth_plugin option can be specified multiple times to load multiple\n# plugins. The plugins will be processed in the order that they are specified\n# here. If the auth_plugin option is specified alongside either of\n# password_file or acl_file then the plugin checks will be made first.\n#\n#auth_plugin\n\n# If the auth_plugin option above is used, define options to pass to the\n# plugin here as described by the plugin instructions. All options named\n# using the format auth_opt_* will be passed to the plugin, for example:\n#\n# auth_opt_db_host\n# auth_opt_db_port\n# auth_opt_db_username\n# auth_opt_db_password\n\n\n# =================================================================\n# Bridges\n# =================================================================\n\n# A bridge is a way of connecting multiple MQTT brokers together.\n# Create a new bridge using the \"connection\" option as described below. Set\n# options for the bridges using the remaining parameters. You must specify the\n# address and at least one topic to subscribe to.\n#\n# Each connection must have a unique name.\n#\n# The address line may have multiple host address and ports specified. See\n# below in the round_robin description for more details on bridge behaviour if\n# multiple addresses are used. Note that if you use an IPv6 address, then you\n# are required to specify a port.\n#\n# The direction that the topic will be shared can be chosen by\n# specifying out, in or both, where the default value is out.\n# The QoS level of the bridged communication can be specified with the next\n# topic option. The default QoS level is 0, to change the QoS the topic\n# direction must also be given.\n#\n# The local and remote prefix options allow a topic to be remapped when it is\n# bridged to/from the remote broker. This provides the ability to place a topic\n# tree in an appropriate location.\n#\n# For more details see the mosquitto.conf man page.\n#\n# Multiple topics can be specified per connection, but be careful\n# not to create any loops.\n#\n# If you are using bridges with cleansession set to false (the default), then\n# you may get unexpected behaviour from incoming topics if you change what\n# topics you are subscribing to. This is because the remote broker keeps the\n# subscription for the old topic. If you have this problem, connect your bridge\n# with cleansession set to true, then reconnect with cleansession set to false\n# as normal.\n#connection <name>\n#address <host>[:<port>] [<host>[:<port>]]\n#topic <topic> [[[out | in | both] qos-level] local-prefix remote-prefix]\n\n\n# If a bridge has topics that have \"out\" direction, the default behaviour is to\n# send an unsubscribe request to the remote broker on that topic. This means\n# that changing a topic direction from \"in\" to \"out\" will not keep receiving\n# incoming messages. Sending these unsubscribe requests is not always\n# desirable, setting bridge_attempt_unsubscribe to false will disable sending\n# the unsubscribe request.\n#bridge_attempt_unsubscribe true\n\n# Set the version of the MQTT protocol to use with for this bridge. Can be one\n# of mqttv311 or mqttv11. Defaults to mqttv311.\n#bridge_protocol_version mqttv311\n\n# Set the clean session variable for this bridge.\n# When set to true, when the bridge disconnects for any reason, all\n# messages and subscriptions will be cleaned up on the remote\n# broker. Note that with cleansession set to true, there may be a\n# significant amount of retained messages sent when the bridge\n# reconnects after losing its connection.\n# When set to false, the subscriptions and messages are kept on the\n# remote broker, and delivered when the bridge reconnects.\n#cleansession false\n\n# Set the amount of time a bridge using the lazy start type must be idle before\n# it will be stopped. Defaults to 60 seconds.\n#idle_timeout 60\n\n# Set the keepalive interval for this bridge connection, in\n# seconds.\n#keepalive_interval 60\n\n# Set the clientid to use on the local broker. If not defined, this defaults to\n# 'local.<clientid>'. If you are bridging a broker to itself, it is important\n# that local_clientid and clientid do not match.\n#local_clientid\n\n# If set to true, publish notification messages to the local and remote brokers\n# giving information about the state of the bridge connection. Retained\n# messages are published to the topic $SYS/broker/connection/<clientid>/state\n# unless the notification_topic option is used.\n# If the message is 1 then the connection is active, or 0 if the connection has\n# failed.\n# This uses the last will and testament feature.\n#notifications true\n\n# Choose the topic on which notification messages for this bridge are\n# published. If not set, messages are published on the topic\n# $SYS/broker/connection/<clientid>/state\n#notification_topic\n\n# Set the client id to use on the remote end of this bridge connection. If not\n# defined, this defaults to 'name.hostname' where name is the connection name\n# and hostname is the hostname of this computer.\n# This replaces the old \"clientid\" option to avoid confusion. \"clientid\"\n# remains valid for the time being.\n#remote_clientid\n\n# Set the password to use when connecting to a broker that requires\n# authentication. This option is only used if remote_username is also set.\n# This replaces the old \"password\" option to avoid confusion. \"password\"\n# remains valid for the time being.\n#remote_password\n\n# Set the username to use when connecting to a broker that requires\n# authentication.\n# This replaces the old \"username\" option to avoid confusion. \"username\"\n# remains valid for the time being.\n#remote_username\n\n# Set the amount of time a bridge using the automatic start type will wait\n# until attempting to reconnect.\n# This option can be configured to use a constant delay time in seconds, or to\n# use a backoff mechanism based on \"Decorrelated Jitter\", which adds a degree\n# of randomness to when the restart occurs.\n#\n# Set a constant timeout of 20 seconds:\n# restart_timeout 20\n#\n# Set backoff with a base (start value) of 10 seconds and a cap (upper limit) of\n# 60 seconds:\n# restart_timeout 10 30\n#\n# Defaults to jitter with a base of 5 and cap of 30\n#restart_timeout 5 30\n\n# If the bridge has more than one address given in the address/addresses\n# configuration, the round_robin option defines the behaviour of the bridge on\n# a failure of the bridge connection. If round_robin is false, the default\n# value, then the first address is treated as the main bridge connection. If\n# the connection fails, the other secondary addresses will be attempted in\n# turn. Whilst connected to a secondary bridge, the bridge will periodically\n# attempt to reconnect to the main bridge until successful.\n# If round_robin is true, then all addresses are treated as equals. If a\n# connection fails, the next address will be tried and if successful will\n# remain connected until it fails\n#round_robin false\n\n# Set the start type of the bridge. This controls how the bridge starts and\n# can be one of three types: automatic, lazy and once. Note that RSMB provides\n# a fourth start type \"manual\" which isn't currently supported by mosquitto.\n#\n# \"automatic\" is the default start type and means that the bridge connection\n# will be started automatically when the broker starts and also restarted\n# after a short delay (30 seconds) if the connection fails.\n#\n# Bridges using the \"lazy\" start type will be started automatically when the\n# number of queued messages exceeds the number set with the \"threshold\"\n# parameter. It will be stopped automatically after the time set by the\n# \"idle_timeout\" parameter. Use this start type if you wish the connection to\n# only be active when it is needed.\n#\n# A bridge using the \"once\" start type will be started automatically when the\n# broker starts but will not be restarted if the connection fails.\n#start_type automatic\n\n# Set the number of messages that need to be queued for a bridge with lazy\n# start type to be restarted. Defaults to 10 messages.\n# Must be less than max_queued_messages.\n#threshold 10\n\n# If try_private is set to true, the bridge will attempt to indicate to the\n# remote broker that it is a bridge not an ordinary client. If successful, this\n# means that loop detection will be more effective and that retained messages\n# will be propagated correctly. Not all brokers support this feature so it may\n# be necessary to set try_private to false if your bridge does not connect\n# properly.\n#try_private true\n\n# -----------------------------------------------------------------\n# Certificate based SSL/TLS support\n# -----------------------------------------------------------------\n# Either bridge_cafile or bridge_capath must be defined to enable TLS support\n# for this bridge.\n# bridge_cafile defines the path to a file containing the\n# Certificate Authority certificates that have signed the remote broker\n# certificate.\n# bridge_capath defines a directory that will be searched for files containing\n# the CA certificates. For bridge_capath to work correctly, the certificate\n# files must have \".crt\" as the file ending and you must run \"openssl rehash\n# <path to capath>\" each time you add/remove a certificate.\n#bridge_cafile\n#bridge_capath\n\n\n# If the remote broker has more than one protocol available on its port, e.g.\n# MQTT and WebSockets, then use bridge_alpn to configure which protocol is\n# requested. Note that WebSockets support for bridges is not yet available.\n#bridge_alpn\n\n# When using certificate based encryption, bridge_insecure disables\n# verification of the server hostname in the server certificate. This can be\n# useful when testing initial server configurations, but makes it possible for\n# a malicious third party to impersonate your server through DNS spoofing, for\n# example. Use this option in testing only. If you need to resort to using this\n# option in a production environment, your setup is at fault and there is no\n# point using encryption.\n#bridge_insecure false\n\n# Path to the PEM encoded client certificate, if required by the remote broker.\n#bridge_certfile\n\n# Path to the PEM encoded client private key, if required by the remote broker.\n#bridge_keyfile\n\n# -----------------------------------------------------------------\n# PSK based SSL/TLS support\n# -----------------------------------------------------------------\n# Pre-shared-key encryption provides an alternative to certificate based\n# encryption. A bridge can be configured to use PSK with the bridge_identity\n# and bridge_psk options. These are the client PSK identity, and pre-shared-key\n# in hexadecimal format with no \"0x\". Only one of certificate and PSK based\n# encryption can be used on one\n# bridge at once.\n#bridge_identity\n#bridge_psk\n\n\n# =================================================================\n# External config files\n# =================================================================\n\n# External configuration files may be included by using the\n# include_dir option. This defines a directory that will be searched\n# for config files. All files that end in '.conf' will be loaded as\n# a configuration file. It is best to have this as the last option\n# in the main file. This option will only be processed from the main\n# configuration file. The directory specified must not contain the\n# main configuration file.\n# Files within include_dir will be loaded sorted in case-sensitive\n# alphabetical order, with capital letters ordered first. If this option is\n# given multiple times, all of the files from the first instance will be\n# processed before the next instance. See the man page for examples.\n#include_dir\n"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-mosquitto",
      "labels": {
        "app.kubernetes.io/name": "mosquitto",
        "helm.sh/chart": "mosquitto-0.2.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.6.10",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "port": 1883,
          "targetPort": "default",
          "protocol": "TCP",
          "name": "default"
        },
        {
          "port": 9001,
          "targetPort": "websocket",
          "protocol": "TCP",
          "name": "websocket"
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "mosquitto",
        "app.kubernetes.io/instance": "release-name"
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-mosquitto",
      "labels": {
        "app.kubernetes.io/name": "mosquitto",
        "helm.sh/chart": "mosquitto-0.2.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.6.10",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "mosquitto",
          "app.kubernetes.io/instance": "release-name"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "mosquitto",
            "app.kubernetes.io/instance": "release-name"
          }
        },
        "spec": {
          "serviceAccountName": "release-name-mosquitto",
          "securityContext": {},
          "containers": [
            {
              "name": "mosquitto",
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "image": "eclipse-mosquitto:1.6.10",
              "imagePullPolicy": "IfNotPresent",
              "ports": [
                {
                  "name": "default",
                  "containerPort": 1883,
                  "protocol": "TCP"
                },
                {
                  "name": "websocket",
                  "containerPort": 9001,
                  "protocol": "TCP"
                }
              ],
              "livenessProbe": {
                "tcpSocket": {
                  "port": "default"
                }
              },
              "readinessProbe": {
                "tcpSocket": {
                  "port": "default"
                }
              },
              "resources": {
                "seccompProfile": {
                  "type": "RuntimeDefault"
                },
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "volumeMounts": [
                {
                  "name": "configmap",
                  "mountPath": "/mosquitto/config"
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "configmap",
              "configMap": {
                "name": "release-name-mosquitto"
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Pod",
    "metadata": {
      "name": "release-name-mosquitto-test-connection",
      "labels": {
        "app.kubernetes.io/name": "mosquitto",
        "helm.sh/chart": "mosquitto-0.2.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.6.10",
        "app.kubernetes.io/managed-by": "Helm"
      },
      "annotations": {
        "helm.sh/hook": "test-success"
      }
    },
    "spec": {
      "containers": [
        {
          "name": "wget",
          "image": "busybox",
          "command": [
            "wget"
          ],
          "args": [
            "release-name-mosquitto:"
          ]
        }
      ],
      "restartPolicy": "Never"
    }
  }
]