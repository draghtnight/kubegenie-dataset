apiVersion: v1
kind: Namespace
metadata:
  labels:
    controle-plane: koordinator
  name: koordinator-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: koord-manager
  namespace: koordinator-system
---
apiVersion: v1
kind: ServiceAccount
metadata:
  namespace: koordinator-system
  name: koordlet
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: koord-scheduler
  namespace: koordinator-system
---
apiVersion: v1
kind: Secret
metadata:
  name: koordinator-webhook-certs
  namespace: koordinator-system
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: koord-scheduler-config
  namespace: koordinator-system
data:
  koord-scheduler-config: |
    apiVersion: kubescheduler.config.k8s.io/v1beta2
    kind: KubeSchedulerConfiguration
    profiles:
      - pluginConfig:
        - args:
            apiVersion: kubescheduler.config.k8s.io/v1beta2
            kind: NodeResourcesFitArgs
            scoringStrategy:
              type: LeastAllocated
              resources:
                - name: cpu
                  weight: 1
                - name: memory
                  weight: 1
                - name: "koordinator.sh/batch-cpu"
                  weight: 1
                - name: "koordinator.sh/batch-mem"
                  weight: 1
          name: NodeResourcesFit
        - args:
            apiVersion: kubescheduler.config.k8s.io/v1beta2
            kind: LoadAwareSchedulingArgs
            filterExpiredNodeMetrics: true
            nodeMetricExpirationSeconds: 300
            resourceWeights:
              cpu: 1
              memory: 1
            usageThresholds:
              cpu: 75
              memory: 85
            estimatedScalingFactors:
              cpu: 80
              memory: 70
          name: LoadAwareScheduling
        plugins:
          filter:
            enabled:
              - name: LoadAwareScheduling
                weight: 0
          reserve:
            enabled:
              - name: LoadAwareScheduling
                weight: 0
          score:
            enabled:
              - name: LoadAwareScheduling
                weight: 1000
        schedulerName: koord-scheduler
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: slo-controller-config
  namespace: koordinator-system
data:
  colocation-config: |
    {
      "enable": true
    }
  resource-threshold-config: |
    {
      "clusterStrategy": {
        "enable": true
      }
    }
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.8.0
  creationTimestamp: null
  name: clustercolocationprofiles.config.koordinator.sh
spec:
  group: config.koordinator.sh
  names:
    kind: ClusterColocationProfile
    listKind: ClusterColocationProfileList
    plural: clustercolocationprofiles
    singular: clustercolocationprofile
  scope: Cluster
  versions:
    - name: v1alpha1
      schema:
        openAPIV3Schema:
          description: ClusterColocationProfile is the Schema for the ClusterColocationProfile API
          properties:
            apiVersion:
              description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
              type: string
            kind:
              description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
              type: string
            metadata:
              type: object
            spec:
              description: ClusterColocationProfileSpec is a description of a ClusterColocationProfile.
              properties:
                annotations:
                  additionalProperties:
                    type: string
                  description: Annotations describes the k/v pair that needs to inject into Pod.Annotations
                  type: object
                koordinatorPriority:
                  description: KoordinatorPriority defines the Pod sub-priority in Koordinator. The priority value will be injected into Pod as label koordinator.sh/priority. Various Koordinator components determine the priority of the Pod in the Koordinator through KoordinatorPriority and the priority value in PriorityClassName. The higher the value, the higher the priority.
                  format: int32
                  type: integer
                labels:
                  additionalProperties:
                    type: string
                  description: Labels describes the k/v pair that needs to inject into Pod.Labels
                  type: object
                namespaceSelector:
                  description: NamespaceSelector decides whether to mutate/validate Pods if the namespace matches the selector. Default to the empty LabelSelector, which matches everything.
                  properties:
                    matchExpressions:
                      description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                      items:
                        description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                        properties:
                          key:
                            description: key is the label key that the selector applies to.
                            type: string
                          operator:
                            description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                            type: string
                          values:
                            description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                            items:
                              type: string
                            type: array
                        required:
                          - key
                          - operator
                        type: object
                      type: array
                    matchLabels:
                      additionalProperties:
                        type: string
                      description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                      type: object
                  type: object
                patch:
                  description: Patch indicates patching podTemplate that will be injected to the Pod.
                  x-kubernetes-preserve-unknown-fields: true
                priorityClassName:
                  description: If specified, the priorityClassName and the priority value defined in PriorityClass will be injected into the Pod. The PriorityClassName, priority value in PriorityClassName and KoordinatorPriority will affect the scheduling, preemption and other behaviors of Koordinator system.
                  enum:
                    - koord-prod
                    - koord-mid
                    - koord-batch
                    - koord-free
                  type: string
                qosClass:
                  description: QoSClass describes the type of Koordinator QoS that the Pod is running. The value will be injected into Pod as label koordinator.sh/qosClass. Options are LSE/LSR/LS/BE/SYSTEM.
                  enum:
                    - LSE
                    - LSR
                    - LS
                    - BE
                    - SYSTEM
                  type: string
                schedulerName:
                  description: If specified, the pod will be dispatched by specified scheduler.
                  type: string
                selector:
                  description: Selector decides whether to mutate/validate Pods if the Pod matches the selector. Default to the empty LabelSelector, which matches everything.
                  properties:
                    matchExpressions:
                      description: matchExpressions is a list of label selector requirements. The requirements are ANDed.
                      items:
                        description: A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
                        properties:
                          key:
                            description: key is the label key that the selector applies to.
                            type: string
                          operator:
                            description: operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
                            type: string
                          values:
                            description: values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
                            items:
                              type: string
                            type: array
                        required:
                          - key
                          - operator
                        type: object
                      type: array
                    matchLabels:
                      additionalProperties:
                        type: string
                      description: matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                      type: object
                  type: object
              required:
                - priorityClassName
                - qosClass
              type: object
            status:
              description: ClusterColocationProfileStatus represents information about the status of a ClusterColocationProfile.
              type: object
          type: object
      served: true
      storage: true
      subresources:
        status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.8.0
  creationTimestamp: null
  name: nodemetrics.slo.koordinator.sh
spec:
  group: slo.koordinator.sh
  names:
    kind: NodeMetric
    listKind: NodeMetricList
    plural: nodemetrics
    singular: nodemetric
  scope: Cluster
  versions:
    - name: v1alpha1
      schema:
        openAPIV3Schema:
          description: NodeMetric is the Schema for the nodemetrics API
          properties:
            apiVersion:
              description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
              type: string
            kind:
              description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
              type: string
            metadata:
              type: object
            spec:
              description: NodeMetricSpec defines the desired state of NodeMetric
              type: object
            status:
              description: NodeMetricStatus defines the observed state of NodeMetric
              properties:
                nodeMetric:
                  description: NodeMetric contains the metrics for this node.
                  properties:
                    nodeUsage:
                      properties:
                        resources:
                          additionalProperties:
                            anyOf:
                              - type: integer
                              - type: string
                            pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                            x-kubernetes-int-or-string: true
                          description: ResourceList is a set of (resource name, quantity) pairs.
                          type: object
                      type: object
                  type: object
                podsMetric:
                  description: PodsMetric contains the metrics for pods belong to this node.
                  items:
                    properties:
                      name:
                        type: string
                      namespace:
                        type: string
                      podUsage:
                        properties:
                          resources:
                            additionalProperties:
                              anyOf:
                                - type: integer
                                - type: string
                              pattern: ^(\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))(([KMGTPE]i)|[numkMGTPE]|([eE](\+|-)?(([0-9]+(\.[0-9]*)?)|(\.[0-9]+))))?$
                              x-kubernetes-int-or-string: true
                            description: ResourceList is a set of (resource name, quantity) pairs.
                            type: object
                        type: object
                    type: object
                  type: array
                updateTime:
                  description: UpdateTime is the last time this NodeMetric was updated.
                  format: date-time
                  type: string
              type: object
          type: object
      served: true
      storage: true
      subresources:
        status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition
metadata:
  annotations:
    controller-gen.kubebuilder.io/version: v0.8.0
  creationTimestamp: null
  name: nodeslos.slo.koordinator.sh
spec:
  group: slo.koordinator.sh
  names:
    kind: NodeSLO
    listKind: NodeSLOList
    plural: nodeslos
    singular: nodeslo
  scope: Cluster
  versions:
    - name: v1alpha1
      schema:
        openAPIV3Schema:
          description: NodeSLO is the Schema for the nodeslos API
          properties:
            apiVersion:
              description: 'APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources'
              type: string
            kind:
              description: 'Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds'
              type: string
            metadata:
              type: object
            spec:
              description: NodeSLOSpec defines the desired state of NodeSLO
              properties:
                cpuBurstStrategy:
                  description: CPU Burst Strategy
                  properties:
                    cfsQuotaBurstPercent:
                      default: 300
                      description: pod cfs quota scale up ceil percentage, default = 300 (300%)
                      format: int64
                      type: integer
                    cfsQuotaBurstPeriodSeconds:
                      default: -1
                      description: specifies a period of time for pod can use at burst, default = -1 (unlimited)
                      format: int64
                      type: integer
                    cpuBurstPercent:
                      default: 1000
                      description: 'cpu burst percentage for setting cpu.cfs_burst_us, legal range: [0, 10000], default as 1000 (1000%)'
                      format: int64
                      type: integer
                    policy:
                      type: string
                    sharePoolThresholdPercent:
                      default: 50
                      description: scale down cfs quota if node cpu overload, default = 50
                      format: int64
                      type: integer
                  type: object
                resourceQoSStrategy:
                  description: QoS config strategy for pods of different qos-class
                  properties:
                    be:
                      description: ResourceQoS for BE pods.
                      properties:
                        memoryQoS:
                          description: MemoryQoSCfg stores node-level config of memory qos
                          properties:
                            enable:
                              description: 'Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQoS and `Policy` instead of an `Enable` option. Please view the differences between MemoryQoSCfg and PodMemoryQoSConfig structs.'
                              type: boolean
                            lowLimitPercent:
                              description: 'LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory, pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            minLimitPercent:
                              description: 'memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. `memory.high` := memory.limit_in_bytes * throttlingFactor / 100 (use "max" if memory.high <= memory.min) MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            oomKillGroup:
                              format: int64
                              type: integer
                            priority:
                              format: int64
                              type: integer
                            priorityEnable:
                              description: 'TODO: enhance the usages of oom priority and oom kill group'
                              format: int64
                              type: integer
                            throttlingPercent:
                              description: 'ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            wmarkMinAdj:
                              description: 'wmark_min_adj (Anolis OS required) WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min'' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min'' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].'
                              format: int64
                              maximum: 50
                              minimum: -25
                              type: integer
                            wmarkRatio:
                              description: 'wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation stops when usage is below `memory.wmark_low`. Basically, `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.wmark_scale_factor `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.'
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            wmarkScalePermill:
                              description: 'WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.'
                              format: int64
                              maximum: 1000
                              minimum: 1
                              type: integer
                          type: object
                        resctrlQoS:
                          description: ResctrlQoSCfg stores node-level config of resctrl qos
                          properties:
                            catRangeEndPercent:
                              default: 100
                              description: LLC available range end for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            catRangeStartPercent:
                              default: 0
                              description: LLC available range start for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            enable:
                              description: Enable indicates whether the resctrl qos is enabled.
                              type: boolean
                            mbaPercent:
                              default: 100
                              description: MBA percent
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                          type: object
                      type: object
                    cgroupRoot:
                      description: ResourceQoS for root cgroup.
                      properties:
                        memoryQoS:
                          description: MemoryQoSCfg stores node-level config of memory qos
                          properties:
                            enable:
                              description: 'Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQoS and `Policy` instead of an `Enable` option. Please view the differences between MemoryQoSCfg and PodMemoryQoSConfig structs.'
                              type: boolean
                            lowLimitPercent:
                              description: 'LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory, pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            minLimitPercent:
                              description: 'memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. `memory.high` := memory.limit_in_bytes * throttlingFactor / 100 (use "max" if memory.high <= memory.min) MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            oomKillGroup:
                              format: int64
                              type: integer
                            priority:
                              format: int64
                              type: integer
                            priorityEnable:
                              description: 'TODO: enhance the usages of oom priority and oom kill group'
                              format: int64
                              type: integer
                            throttlingPercent:
                              description: 'ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            wmarkMinAdj:
                              description: 'wmark_min_adj (Anolis OS required) WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min'' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min'' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].'
                              format: int64
                              maximum: 50
                              minimum: -25
                              type: integer
                            wmarkRatio:
                              description: 'wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation stops when usage is below `memory.wmark_low`. Basically, `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.wmark_scale_factor `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.'
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            wmarkScalePermill:
                              description: 'WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.'
                              format: int64
                              maximum: 1000
                              minimum: 1
                              type: integer
                          type: object
                        resctrlQoS:
                          description: ResctrlQoSCfg stores node-level config of resctrl qos
                          properties:
                            catRangeEndPercent:
                              default: 100
                              description: LLC available range end for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            catRangeStartPercent:
                              default: 0
                              description: LLC available range start for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            enable:
                              description: Enable indicates whether the resctrl qos is enabled.
                              type: boolean
                            mbaPercent:
                              default: 100
                              description: MBA percent
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                          type: object
                      type: object
                    ls:
                      description: ResourceQoS for LS pods.
                      properties:
                        memoryQoS:
                          description: MemoryQoSCfg stores node-level config of memory qos
                          properties:
                            enable:
                              description: 'Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQoS and `Policy` instead of an `Enable` option. Please view the differences between MemoryQoSCfg and PodMemoryQoSConfig structs.'
                              type: boolean
                            lowLimitPercent:
                              description: 'LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory, pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            minLimitPercent:
                              description: 'memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. `memory.high` := memory.limit_in_bytes * throttlingFactor / 100 (use "max" if memory.high <= memory.min) MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            oomKillGroup:
                              format: int64
                              type: integer
                            priority:
                              format: int64
                              type: integer
                            priorityEnable:
                              description: 'TODO: enhance the usages of oom priority and oom kill group'
                              format: int64
                              type: integer
                            throttlingPercent:
                              description: 'ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            wmarkMinAdj:
                              description: 'wmark_min_adj (Anolis OS required) WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min'' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min'' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].'
                              format: int64
                              maximum: 50
                              minimum: -25
                              type: integer
                            wmarkRatio:
                              description: 'wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation stops when usage is below `memory.wmark_low`. Basically, `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.wmark_scale_factor `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.'
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            wmarkScalePermill:
                              description: 'WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.'
                              format: int64
                              maximum: 1000
                              minimum: 1
                              type: integer
                          type: object
                        resctrlQoS:
                          description: ResctrlQoSCfg stores node-level config of resctrl qos
                          properties:
                            catRangeEndPercent:
                              default: 100
                              description: LLC available range end for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            catRangeStartPercent:
                              default: 0
                              description: LLC available range start for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            enable:
                              description: Enable indicates whether the resctrl qos is enabled.
                              type: boolean
                            mbaPercent:
                              default: 100
                              description: MBA percent
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                          type: object
                      type: object
                    lsr:
                      description: ResourceQoS for LSR pods.
                      properties:
                        memoryQoS:
                          description: MemoryQoSCfg stores node-level config of memory qos
                          properties:
                            enable:
                              description: 'Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQoS and `Policy` instead of an `Enable` option. Please view the differences between MemoryQoSCfg and PodMemoryQoSConfig structs.'
                              type: boolean
                            lowLimitPercent:
                              description: 'LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory, pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            minLimitPercent:
                              description: 'memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. `memory.high` := memory.limit_in_bytes * throttlingFactor / 100 (use "max" if memory.high <= memory.min) MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            oomKillGroup:
                              format: int64
                              type: integer
                            priority:
                              format: int64
                              type: integer
                            priorityEnable:
                              description: 'TODO: enhance the usages of oom priority and oom kill group'
                              format: int64
                              type: integer
                            throttlingPercent:
                              description: 'ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            wmarkMinAdj:
                              description: 'wmark_min_adj (Anolis OS required) WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min'' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min'' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].'
                              format: int64
                              maximum: 50
                              minimum: -25
                              type: integer
                            wmarkRatio:
                              description: 'wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation stops when usage is below `memory.wmark_low`. Basically, `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.wmark_scale_factor `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.'
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            wmarkScalePermill:
                              description: 'WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.'
                              format: int64
                              maximum: 1000
                              minimum: 1
                              type: integer
                          type: object
                        resctrlQoS:
                          description: ResctrlQoSCfg stores node-level config of resctrl qos
                          properties:
                            catRangeEndPercent:
                              default: 100
                              description: LLC available range end for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            catRangeStartPercent:
                              default: 0
                              description: LLC available range start for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            enable:
                              description: Enable indicates whether the resctrl qos is enabled.
                              type: boolean
                            mbaPercent:
                              default: 100
                              description: MBA percent
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                          type: object
                      type: object
                    system:
                      description: ResourceQoS for system pods
                      properties:
                        memoryQoS:
                          description: MemoryQoSCfg stores node-level config of memory qos
                          properties:
                            enable:
                              description: 'Enable indicates whether the memory qos is enabled (default: false). This field is used for node-level control, while pod-level configuration is done with MemoryQoS and `Policy` instead of an `Enable` option. Please view the differences between MemoryQoSCfg and PodMemoryQoSConfig structs.'
                              type: boolean
                            lowLimitPercent:
                              description: 'LowLimitPercent specifies the lowLimitFactor percentage to calculate `memory.low`, which TRIES BEST protecting memory from global reclamation when memory usage does not exceed the low limit unless no unprotected memcg can be reclaimed. NOTE: `memory.low` should be larger than `memory.min`. If spec.requests.memory == spec.limits.memory, pod `memory.low` and `memory.high` become invalid, while `memory.wmark_ratio` is still in effect. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            minLimitPercent:
                              description: 'memcg qos If enabled, memcg qos will be set by the agent, where some fields are implicitly calculated from pod spec. 1. `memory.min` := spec.requests.memory * minLimitFactor / 100 (use 0 if requests.memory is not set) 2. `memory.low` := spec.requests.memory * lowLimitFactor / 100 (use 0 if requests.memory is not set) 3. `memory.limit_in_bytes` := spec.limits.memory (set $node.allocatable.memory if limits.memory is not set) 4. `memory.high` := memory.limit_in_bytes * throttlingFactor / 100 (use "max" if memory.high <= memory.min) MinLimitPercent specifies the minLimitFactor percentage to calculate `memory.min`, which protects memory from global reclamation when memory usage does not exceed the min limit. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            oomKillGroup:
                              format: int64
                              type: integer
                            priority:
                              format: int64
                              type: integer
                            priorityEnable:
                              description: 'TODO: enhance the usages of oom priority and oom kill group'
                              format: int64
                              type: integer
                            throttlingPercent:
                              description: 'ThrottlingPercent specifies the throttlingFactor percentage to calculate `memory.high` with pod memory.limits or node allocatable memory, which triggers memcg direct reclamation when memory usage exceeds. Lower the factor brings more heavier reclaim pressure. Close: 0.'
                              format: int64
                              minimum: 0
                              type: integer
                            wmarkMinAdj:
                              description: 'wmark_min_adj (Anolis OS required) WmarkMinAdj specifies `memory.wmark_min_adj` which adjusts per-memcg threshold for global memory reclamation. Lower the factor brings later reclamation. The adjustment uses different formula for different value range. [-25, 0)：global_wmark_min'' = global_wmark_min + (global_wmark_min - 0) * wmarkMinAdj (0, 50]：global_wmark_min'' = global_wmark_min + (global_wmark_low - global_wmark_min) * wmarkMinAdj Close: [LSR:0, LS:0, BE:0]. Recommended: [LSR:-25, LS:-25, BE:50].'
                              format: int64
                              maximum: 50
                              minimum: -25
                              type: integer
                            wmarkRatio:
                              description: 'wmark_ratio (Anolis OS required) Async memory reclamation is triggered when cgroup memory usage exceeds `memory.wmark_high` and the reclamation stops when usage is below `memory.wmark_low`. Basically, `memory.wmark_high` := min(memory.high, memory.limit_in_bytes) * memory.wmark_scale_factor `memory.wmark_low` := min(memory.high, memory.limit_in_bytes) * (memory.wmark_ratio - memory.wmark_scale_factor) WmarkRatio specifies `memory.wmark_ratio` that help calculate `memory.wmark_high`, which triggers async memory reclamation when memory usage exceeds. Close: 0. Recommended: 95.'
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            wmarkScalePermill:
                              description: 'WmarkScalePermill specifies `memory.wmark_scale_factor` that helps calculate `memory.wmark_low`, which stops async memory reclamation when memory usage belows. Close: 50. Recommended: 20.'
                              format: int64
                              maximum: 1000
                              minimum: 1
                              type: integer
                          type: object
                        resctrlQoS:
                          description: ResctrlQoSCfg stores node-level config of resctrl qos
                          properties:
                            catRangeEndPercent:
                              default: 100
                              description: LLC available range end for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            catRangeStartPercent:
                              default: 0
                              description: LLC available range start for pods by percentage
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                            enable:
                              description: Enable indicates whether the resctrl qos is enabled.
                              type: boolean
                            mbaPercent:
                              default: 100
                              description: MBA percent
                              format: int64
                              maximum: 100
                              minimum: 0
                              type: integer
                          type: object
                      type: object
                  type: object
                resourceUsedThresholdWithBE:
                  description: BE pods will be limited if node resource usage overload
                  properties:
                    cpuSuppressPolicy:
                      description: CPUSuppressPolicy
                      type: string
                    cpuSuppressThresholdPercent:
                      default: 65
                      description: cpu suppress threshold percentage (0,100), default = 65
                      format: int64
                      type: integer
                    enable:
                      default: true
                      description: whether the strategy is enabled, default = true
                      type: boolean
                    memoryEvictLowerPercent:
                      description: 'lower: memory release util usage under MemoryEvictLowerPercent, default = MemoryEvictThresholdPercent - 2'
                      format: int64
                      type: integer
                    memoryEvictThresholdPercent:
                      default: 70
                      description: 'upper: memory evict threshold percentage (0,100), default = 70'
                      format: int64
                      type: integer
                  type: object
              type: object
            status:
              description: NodeSLOStatus defines the observed state of NodeSLO
              type: object
          type: object
      served: true
      storage: true
      subresources:
        status: {}
status:
  acceptedNames:
    kind: ""
    plural: ""
  conditions: []
  storedVersions: []
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  creationTimestamp: null
  name: koord-manager-role
rules:
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - namespaces
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - create
      - delete
      - get
      - list
      - update
      - watch
  - apiGroups:
      - '*'
    resources:
      - '*'
    verbs:
      - list
  - apiGroups:
      - admissionregistration.k8s.io
    resources:
      - mutatingwebhookconfigurations
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - admissionregistration.k8s.io
    resources:
      - validatingwebhookconfigurations
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - apiextensions.k8s.io
    resources:
      - customresourcedefinitions
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - nodes
      - nodes/status
      - pods
      - pods/status
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - ""
    resources:
      - pods/ephemeralcontainers
    verbs:
      - get
      - update
  - apiGroups:
      - ""
    resources:
      - secrets
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - scheduling.k8s.io
    resources:
      - priorityclasses
    verbs:
      - get
      - list
      - watch
  - apiGroups:
      - config.koordinator.sh
      - slo.koordinator.sh
    resources:
      - '*'
    verbs:
      - create
      - delete
      - get
      - list
      - patch
      - update
      - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: koordlet-role
rules:
  - apiGroups:
      - config.koordinator.sh
      - slo.koordinator.sh
    resources:
      - '*'
    verbs:
      - '*'
  - apiGroups:
      - ""
    resources:
      - configmaps
      - configmaps/status
    verbs:
      - '*'
  - apiGroups:
      - ""
    resources:
      - nodes
      - nodes/status
      - pods
      - pods/status
    verbs:
      - patch
      - update
      - get
      - list
      - watch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - '*'
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: koord-scheduler-role
rules:
  - apiGroups:
      - apiextensions.k8s.io
    resources:
      - customresourcedefinitions
    verbs:
      - get
      - list
      - patch
      - update
      - watch
  - apiGroups:
      - config.koordinator.sh
      - slo.koordinator.sh
    resources:
      - '*'
    verbs:
      - get
      - list
      - patch
      - update
      - watch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: koord-manager-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: koord-manager-role
subjects:
  - kind: ServiceAccount
    name: koord-manager
    namespace: koordinator-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: koordlet-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: koordlet-role
subjects:
  - kind: ServiceAccount
    name: koordlet
    namespace: koordinator-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: koord-scheduler-rolebinding-custom
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: koord-scheduler-role
subjects:
  - kind: ServiceAccount
    name: koord-scheduler
    namespace: koordinator-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: koord-scheduler-rolebinding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:kube-scheduler
subjects:
  - kind: ServiceAccount
    name: koord-scheduler
    namespace: koordinator-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: koord-scheduler-rolebinding-volume
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: system:volume-scheduler
subjects:
  - kind: ServiceAccount
    name: koord-scheduler
    namespace: koordinator-system
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: koord-leader-election-role
  namespace: koordinator-system
rules:
  - apiGroups:
      - ""
    resources:
      - configmaps
    verbs:
      - get
      - list
      - watch
      - create
      - update
      - patch
      - delete
  - apiGroups:
      - ""
    resources:
      - configmaps/status
    verbs:
      - get
      - update
      - patch
  - apiGroups:
      - ""
    resources:
      - events
    verbs:
      - create
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: koord-leader-election-rolebinding
  namespace: koordinator-system
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: koord-leader-election-role
subjects:
  - kind: ServiceAccount
    name: koord-manager
    namespace: koordinator-system
---
apiVersion: v1
kind: Service
metadata:
  name: koordinator-webhook-service
  namespace: koordinator-system
spec:
  ports:
    - port: 443
      targetPort: 9876
  selector:
    koord-app: koord-manager
---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: koordlet
  namespace: koordinator-system
  labels:
    koord-app: koordlet
spec:
  selector:
    matchLabels:
      koord-app: koordlet
  minReadySeconds: 10
  updateStrategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 20%
  template:
    metadata:
      labels:
        koord-app: koordlet
    spec:
      containers:
        - command:
            - /koordlet
          args:
            - -CgroupRootDir=/host-cgroup/
            - -feature-gates=AllAlpha=true
            - -runtime-hooks=AllAlpha=true
            - -RuntimeHooksNetwork=unix
            - -RuntimeHooksAddr=/host-var-run-koordlet/koordlet.sock
            - --logtostderr=true
            - --v=4
          image: koordinatorsh/koordlet:v0.4.0
          imagePullPolicy: Always
          name: koordlet
          env:
            - name: NODE_NAME
              valueFrom:
                fieldRef:
                  apiVersion: v1
                  fieldPath: spec.nodeName
          resources:
            limits:
              cpu: 500m
              memory: 256Mi
            requests:
              cpu: "0"
              memory: "0"
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                "": NET_RAW
            privileged: true
            readOnlyRootFilesystem: true
            seccompProfile:
              type: RuntimeDefault
          volumeMounts:
            - mountPath: /etc/localtime
              name: host-time
              readOnly: true
            - mountPath: /host-cgroup/
              name: host-cgroup-root
            - mountPath: /host-sys-fs/
              name: host-sys-fs
              mountPropagation: Bidirectional
            - mountPath: /host-var-run/
              name: host-var-run
              readOnly: true
            - mountPath: /host-var-run-koordlet/
              name: host-var-run-koordlet
              mountPropagation: Bidirectional
            - mountPath: /host-sys/
              name: host-sys
              readOnly: true
      tolerations:
        - operator: Exists
      hostNetwork: true
      hostPID: true
      terminationGracePeriodSeconds: 10
      serviceAccountName: koordlet
      volumes:
        - hostPath:
            path: /etc/localtime
            type: ""
          name: host-time
        - hostPath:
            path: /sys/fs/cgroup/
            type: ""
          name: host-cgroup-root
        - hostPath:
            path: /sys/fs/
            type: ""
          name: host-sys-fs
        - hostPath:
            path: /var/run/
            type: ""
          name: host-var-run
        - hostPath:
            path: /var/run/koordlet/
            type: DirectoryOrCreate
          name: host-var-run-koordlet
        - hostPath:
            path: /sys/
            type: ""
          name: host-sys
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    koord-app: koord-manager
  name: koord-manager
  namespace: koordinator-system
spec:
  replicas: 2
  selector:
    matchLabels:
      koord-app: koord-manager
  minReadySeconds: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 100%
  template:
    metadata:
      labels:
        koord-app: koord-manager
    spec:
      containers:
        - args:
            - --enable-leader-election
            - --metrics-addr=:8080
            - --health-probe-addr=:8000
            - --logtostderr=true
            - --leader-election-namespace=koordinator-system
            - --v=4
            - --feature-gates=
            - --sync-period=0
          command:
            - /koord-manager
          image: koordinatorsh/koord-manager:v0.4.0
          imagePullPolicy: Always
          name: manager
          env:
            - name: POD_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: WEBHOOK_PORT
              value: "9876"
            - name: WEBHOOK_CONFIGURATION_FAILURE_POLICY_PODS
              value: Ignore
          ports:
            - containerPort: 9876
              name: webhook-server
              protocol: TCP
            - containerPort: 8080
              name: metrics
              protocol: TCP
            - containerPort: 8000
              name: health
              protocol: TCP
          readinessProbe:
            httpGet:
              path: readyz
              port: 8000
          resources:
            limits:
              cpu: 1000m
              memory: 1Gi
            requests:
              cpu: 500m
              memory: 256Mi
      hostNetwork: false
      terminationGracePeriodSeconds: 10
      serviceAccountName: koord-manager
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: koord-app
                      operator: In
                      values:
                        - koord-manager
                topologyKey: kubernetes.io/hostname
              weight: 100
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    koord-app: koord-scheduler
  name: koord-scheduler
  namespace: koordinator-system
spec:
  replicas: 2
  selector:
    matchLabels:
      koord-app: koord-scheduler
  minReadySeconds: 3
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 0
      maxSurge: 100%
  template:
    metadata:
      labels:
        koord-app: koord-scheduler
    spec:
      containers:
        - args:
            - --leader-elect=true
            - --port=10251
            - --logtostderr=true
            - --authentication-skip-lookup=true
            - --leader-elect-resource-namespace=koordinator-system
            - --v=4
            - --config=/config/koord-scheduler.config
          command:
            - /koord-scheduler
          image: koordinatorsh/koord-scheduler:v0.4.0
          imagePullPolicy: Always
          name: scheduler
          volumeMounts:
            - mountPath: /config
              name: koord-scheduler-config-volume
          readinessProbe:
            httpGet:
              path: healthz
              port: 10251
          resources:
            limits:
              cpu: 1000m
              memory: 1Gi
            requests:
              cpu: 500m
              memory: 256Mi
      hostNetwork: false
      terminationGracePeriodSeconds: 10
      serviceAccountName: koord-scheduler
      volumes:
        - configMap:
            defaultMode: 420
            items:
              - key: koord-scheduler-config
                path: koord-scheduler.config
            name: koord-scheduler-config
          name: koord-scheduler-config-volume
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: koord-app
                      operator: In
                      values:
                        - koord-scheduler
                topologyKey: kubernetes.io/hostname
              weight: 100
---
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: koordinator-mutating-webhook-configuration
  annotations:
    template: ""
webhooks:
  - clientConfig:
      caBundle: Cg==
      service:
        name: koordinator-webhook-service
        namespace: koordinator-system
        path: /mutate-pod
    failurePolicy: Ignore
    admissionReviewVersions:
      - v1
      - v1beta1
    sideEffects: None
    timeoutSeconds: 30
    name: mpod.kb.io
    namespaceSelector:
      matchExpressions:
        - key: control-plane
          operator: DoesNotExist
    rules:
      - apiGroups:
          - ""
        apiVersions:
          - v1
        operations:
          - CREATE
        resources:
          - pods
---
apiVersion: scheduling.k8s.io/v1
description: Offline tasks, computing tasks, etc.
kind: PriorityClass
metadata:
  name: koord-batch
preemptionPolicy: PreemptLowerPriority
value: 5000
---
apiVersion: scheduling.k8s.io/v1
description: Run lowest-priority offline batch jobs, generally refers to not making resource budgets.
kind: PriorityClass
metadata:
  name: koord-free
preemptionPolicy: PreemptLowerPriority
value: 3000
---
apiVersion: scheduling.k8s.io/v1
description: Nearline computation jobs whose SLO weaker than koord-prod.
kind: PriorityClass
metadata:
  name: koord-mid
preemptionPolicy: PreemptLowerPriority
value: 7000
---
apiVersion: scheduling.k8s.io/v1
description: Online production system for applications and businesses.
kind: PriorityClass
metadata:
  name: koord-prod
preemptionPolicy: PreemptLowerPriority
value: 9000
---
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: koordinator-validating-webhook-configuration
  annotations:
    template: ""
webhooks:
  - clientConfig:
      caBundle: Cg==
      service:
        name: koordinator-webhook-service
        namespace: koordinator-system
        path: /validate-pod
    failurePolicy: Ignore
    admissionReviewVersions:
      - v1
      - v1beta1
    sideEffects: None
    timeoutSeconds: 30
    name: vpod.kb.io
    namespaceSelector:
      matchExpressions:
        - key: control-plane
          operator: DoesNotExist
    rules:
      - apiGroups:
          - ""
        apiVersions:
          - v1
        operations:
          - CREATE
          - UPDATE
        resources:
          - pods
