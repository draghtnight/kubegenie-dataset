[
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodDisruptionBudget",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "minAvailable": 1,
      "selector": {
        "matchLabels": {
          "component": "hub",
          "app": "jupyterhub",
          "release": "release-name"
        }
      }
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodDisruptionBudget",
    "metadata": {
      "name": "proxy",
      "labels": {
        "component": "proxy",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "minAvailable": 1,
      "selector": {
        "matchLabels": {
          "component": "proxy",
          "app": "jupyterhub",
          "release": "release-name"
        }
      }
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodDisruptionBudget",
    "metadata": {
      "name": "user-placeholder",
      "labels": {
        "component": "user-placeholder",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "minAvailable": 0,
      "selector": {
        "matchLabels": {
          "component": "user-placeholder",
          "app": "jupyterhub",
          "release": "release-name"
        }
      }
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodDisruptionBudget",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "minAvailable": 1,
      "selector": {
        "matchLabels": {
          "component": "user-scheduler",
          "app": "jupyterhub",
          "release": "release-name"
        }
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    }
  },
  {
    "kind": "Secret",
    "apiVersion": "v1",
    "metadata": {
      "name": "hub-secret",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "type": "Opaque",
    "data": {
      "proxy.token": "Y2hhbmdlbWU=",
      "values.yaml": "YXV0aDoge30KaHViOgogIHNlcnZpY2VzOiB7fQ=="
    }
  },
  {
    "kind": "ConfigMap",
    "apiVersion": "v1",
    "metadata": {
      "name": "hub-config",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "data": {
      "values.yaml": "Chart:\n  Name: jupyterhub\n  Version: 0.9.1\nRelease:\n  Name: release-name\n  Namespace: default\n  Service: Helm\nauth:\n  admin:\n    access: true\n  dummy: {}\n  ldap:\n    dn:\n      search: {}\n      user: {}\n    user: {}\n  state:\n    enabled: false\n  type: dummy\n  whitelist: {}\ncull:\n  concurrency: 10\n  enabled: true\n  every: 600\n  maxAge: 0\n  removeNamedServers: false\n  timeout: 3600\n  users: false\ncustom: {}\ndebug:\n  enabled: false\nhub:\n  allowNamedServers: false\n  annotations: {}\n  baseUrl: /\n  concurrentSpawnLimit: 64\n  consecutiveFailureLimit: 5\n  db:\n    pvc:\n      accessModes:\n      - ReadWriteOnce\n      annotations: {}\n      selector: {}\n      storage: 1Gi\n    type: sqlite-pvc\n  deploymentStrategy:\n    type: Recreate\n  extraConfig: {}\n  extraContainers: []\n  extraVolumeMounts: []\n  extraVolumes: []\n  fsGid: 1000\n  image:\n    name: jupyterhub/k8s-hub\n    tag: 0.9.1\n  imagePullSecret:\n    enabled: false\n  initContainers: []\n  labels: {}\n  livenessProbe:\n    enabled: false\n    initialDelaySeconds: 30\n    periodSeconds: 10\n  networkPolicy:\n    egress:\n    - to:\n      - ipBlock:\n          cidr: 0.0.0.0/0\n    enabled: false\n    ingress: []\n  nodeSelector: {}\n  pdb:\n    enabled: true\n    minAvailable: 1\n  readinessProbe:\n    enabled: true\n    initialDelaySeconds: 0\n    periodSeconds: 10\n  resources:\n    requests:\n      cpu: 200m\n      memory: 512Mi\n  service:\n    annotations: {}\n    ports: {}\n    type: ClusterIP\n  services: {}\n  templatePaths: []\n  templateVars: {}\n  uid: 1000\nscheduling:\n  corePods:\n    nodeAffinity:\n      matchNodePurpose: prefer\n  podPriority:\n    defaultPriority: 0\n    enabled: false\n    globalDefault: false\n    userPlaceholderPriority: -10\n  userPlaceholder:\n    enabled: true\n    replicas: 0\n  userPods:\n    nodeAffinity:\n      matchNodePurpose: prefer\n  userScheduler:\n    enabled: true\n    image:\n      name: gcr.io/google_containers/kube-scheduler-amd64\n      tag: v1.13.12\n    logLevel: 4\n    nodeSelector: {}\n    pdb:\n      enabled: true\n      minAvailable: 1\n    policy: {}\n    replicas: 2\n    resources:\n      requests:\n        cpu: 50m\n        memory: 256Mi\nsingleuser:\n  cloudMetadata:\n    enabled: false\n    ip: 169.254.169.254\n  cmd: jupyterhub-singleuser\n  cpu: {}\n  defaultUrl: /lab\n  events: true\n  extraAnnotations: {}\n  extraContainers: []\n  extraEnv:\n    HOME: /home/jovyan\n    PYSEQUILA_VERSION: 0.1.6\n    SEQUILA_VERSION: 0.5.16\n    TMP_HOME: /tmp/jovyan\n  extraLabels:\n    hub.jupyter.org/network-access-hub: \"true\"\n  extraNodeAffinity:\n    preferred: []\n    required: []\n  extraPodAffinity:\n    preferred: []\n    required: []\n  extraPodAntiAffinity:\n    preferred: []\n    required: []\n  extraPodConfig: {}\n  extraResource:\n    guarantees: {}\n    limits: {}\n  extraTolerations: []\n  fsGid: 100\n  image:\n    name: biodatageeks/pysequila-notebook\n    pullPolicy: IfNotPresent\n    tag: 0.1.3-ga5af501\n  imagePullSecret:\n    enabled: false\n  initContainers: []\n  lifecycleHooks:\n    postStart:\n      exec:\n        command:\n        - sh\n        - -c\n        - |\n          mkdir -p $HOME/.local/share/jupyter/kernels/; cp -r $TMP_HOME/venv $HOME; cp -r $TMP_HOME/.sdkman $HOME; cp -r  $TMP_HOME/.local/share/jupyter/kernels/pysequila/ $HOME/.local/share/jupyter/kernels/;\n  memory:\n    guarantee: 1G\n  networkPolicy:\n    egress:\n    - to:\n      - ipBlock:\n          cidr: 0.0.0.0/0\n          except:\n          - 169.254.169.254/32\n    enabled: false\n    ingress: []\n  networkTools:\n    image:\n      name: jupyterhub/k8s-network-tools\n      tag: 0.9.1\n  nodeSelector: {}\n  serviceAccountName: null\n  startTimeout: 300\n  storage:\n    capacity: 10Gi\n    dynamic:\n      pvcNameTemplate: claim-{username}{servername}\n      storageAccessModes:\n      - ReadWriteOnce\n      storageClass: standard\n      volumeNameTemplate: volume-{username}{servername}\n    extraLabels: {}\n    extraVolumeMounts: []\n    extraVolumes: []\n    homeMountPath: /home/jovyan\n    static:\n      subPath: '{username}'\n    type: dynamic\n  uid: 1000\n",
      "cull_idle_servers.py": "#!/usr/bin/env python3\n# Imported from https://github.com/jupyterhub/jupyterhub/blob/6b1046697/examples/cull-idle/cull_idle_servers.py\n\"\"\"script to monitor and cull idle single-user servers\n\nCaveats:\n\nlast_activity is not updated with high frequency,\nso cull timeout should be greater than the sum of:\n\n- single-user websocket ping interval (default: 30s)\n- JupyterHub.last_activity_interval (default: 5 minutes)\n\nYou can run this as a service managed by JupyterHub with this in your config::\n\n\n    c.JupyterHub.services = [\n        {\n            'name': 'cull-idle',\n            'admin': True,\n            'command': 'python cull_idle_servers.py --timeout=3600'.split(),\n        }\n    ]\n\nOr run it manually by generating an API token and storing it in `JUPYTERHUB_API_TOKEN`:\n\n    export JUPYTERHUB_API_TOKEN=`jupyterhub token`\n    python cull_idle_servers.py [--timeout=900] [--url=http://127.0.0.1:8081/hub/api]\n\"\"\"\n\nfrom datetime import datetime, timezone\nfrom functools import partial\nimport json\nimport os\n\ntry:\n    from urllib.parse import quote\nexcept ImportError:\n    from urllib import quote\n\nimport dateutil.parser\n\nfrom tornado.gen import coroutine, multi\nfrom tornado.locks import Semaphore\nfrom tornado.log import app_log\nfrom tornado.httpclient import AsyncHTTPClient, HTTPRequest\nfrom tornado.ioloop import IOLoop, PeriodicCallback\nfrom tornado.options import define, options, parse_command_line\n\n\ndef parse_date(date_string):\n    \"\"\"Parse a timestamp\n\n    If it doesn't have a timezone, assume utc\n\n    Returned datetime object will always be timezone-aware\n    \"\"\"\n    dt = dateutil.parser.parse(date_string)\n    if not dt.tzinfo:\n        # assume na√Øve timestamps are UTC\n        dt = dt.replace(tzinfo=timezone.utc)\n    return dt\n\n\ndef format_td(td):\n    \"\"\"\n    Nicely format a timedelta object\n\n    as HH:MM:SS\n    \"\"\"\n    if td is None:\n        return \"unknown\"\n    if isinstance(td, str):\n        return td\n    seconds = int(td.total_seconds())\n    h = seconds // 3600\n    seconds = seconds % 3600\n    m = seconds // 60\n    seconds = seconds % 60\n    return f\"{h:02}:{m:02}:{seconds:02}\"\n\n\n@coroutine\ndef cull_idle(\n    url,\n    api_token,\n    inactive_limit,\n    cull_users=False,\n    remove_named_servers=False,\n    max_age=0,\n    concurrency=10,\n):\n    \"\"\"Shutdown idle single-user servers\n\n    If cull_users, inactive *users* will be deleted as well.\n    \"\"\"\n    auth_header = {\n        'Authorization': 'token %s' % api_token,\n    }\n    req = HTTPRequest(\n        url=url + '/users',\n        headers=auth_header,\n    )\n    now = datetime.now(timezone.utc)\n    client = AsyncHTTPClient()\n\n    if concurrency:\n        semaphore = Semaphore(concurrency)\n        @coroutine\n        def fetch(req):\n            \"\"\"client.fetch wrapped in a semaphore to limit concurrency\"\"\"\n            yield semaphore.acquire()\n            try:\n                return (yield client.fetch(req))\n            finally:\n                yield semaphore.release()\n    else:\n        fetch = client.fetch\n\n    resp = yield fetch(req)\n    users = json.loads(resp.body.decode('utf8', 'replace'))\n    futures = []\n\n    @coroutine\n    def handle_server(user, server_name, server):\n        \"\"\"Handle (maybe) culling a single server\n\n        Returns True if server is now stopped (user removable),\n        False otherwise.\n        \"\"\"\n        log_name = user['name']\n        if server_name:\n            log_name = '%s/%s' % (user['name'], server_name)\n        if server.get('pending'):\n            app_log.warning(\n                \"Not culling server %s with pending %s\",\n                log_name, server['pending'])\n            return False\n\n        if server.get('started'):\n            age = now - parse_date(server['started'])\n        else:\n            # started may be undefined on jupyterhub < 0.9\n            age = None\n\n        # check last activity\n        # last_activity can be None in 0.9\n        if server['last_activity']:\n            inactive = now - parse_date(server['last_activity'])\n        else:\n            # no activity yet, use start date\n            # last_activity may be None with jupyterhub 0.9,\n            # which introduces the 'started' field which is never None\n            # for running servers\n            inactive = age\n\n        should_cull = (inactive is not None and\n                       inactive.total_seconds() >= inactive_limit)\n        if should_cull:\n            app_log.info(\n                \"Culling server %s (inactive for %s)\",\n                log_name, format_td(inactive))\n\n        if max_age and not should_cull:\n            # only check started if max_age is specified\n            # so that we can still be compatible with jupyterhub 0.8\n            # which doesn't define the 'started' field\n            if age is not None and age.total_seconds() >= max_age:\n                app_log.info(\n                    \"Culling server %s (age: %s, inactive for %s)\",\n                    log_name, format_td(age), format_td(inactive))\n                should_cull = True\n\n        if not should_cull:\n            app_log.debug(\n                \"Not culling server %s (age: %s, inactive for %s)\",\n                log_name, format_td(age), format_td(inactive))\n            return False\n\n        body = None\n        if server_name:\n            # culling a named server\n            # A named server can be stopped and kept available to the user\n            # for starting again or stopped and removed. To remove the named\n            # server we have to pass an additional option in the body of our\n            # DELETE request.\n            delete_url = url + \"/users/%s/servers/%s\" % (\n                quote(user['name']),\n                quote(server['name']),\n            )\n            if remove_named_servers:\n                body = json.dumps({\"remove\": True})\n        else:\n            delete_url = url + '/users/%s/server' % quote(user['name'])\n\n        req = HTTPRequest(\n            url=delete_url,\n            method='DELETE',\n            headers=auth_header,\n            body=body,\n            allow_nonstandard_methods=True,\n        )\n        resp = yield fetch(req)\n        if resp.code == 202:\n            app_log.warning(\n                \"Server %s is slow to stop\",\n                log_name,\n            )\n            # return False to prevent culling user with pending shutdowns\n            return False\n        return True\n\n    @coroutine\n    def handle_user(user):\n        \"\"\"Handle one user.\n\n        Create a list of their servers, and async exec them.  Wait for\n        that to be done, and if all servers are stopped, possibly cull\n        the user.\n        \"\"\"\n        # shutdown servers first.\n        # Hub doesn't allow deleting users with running servers.\n        # named servers contain the 'servers' dict\n        if 'servers' in user:\n            servers = user['servers']\n        # Otherwise, server data is intermingled in with the user\n        # model\n        else:\n            servers = {}\n            if user['server']:\n                servers[''] = {\n                    'started': user.get('started'),\n                    'last_activity': user['last_activity'],\n                    'pending': user['pending'],\n                    'url': user['server'],\n                }\n        server_futures = [\n            handle_server(user, server_name, server)\n            for server_name, server in servers.items()\n        ]\n        results = yield multi(server_futures)\n        if not cull_users:\n            return\n        # some servers are still running, cannot cull users\n        still_alive = len(results) - sum(results)\n        if still_alive:\n            app_log.debug(\n                \"Not culling user %s with %i servers still alive\",\n                user['name'], still_alive)\n            return False\n\n        should_cull = False\n        if user.get('created'):\n            age = now - parse_date(user['created'])\n        else:\n            # created may be undefined on jupyterhub < 0.9\n            age = None\n\n        # check last activity\n        # last_activity can be None in 0.9\n        if user['last_activity']:\n            inactive = now - parse_date(user['last_activity'])\n        else:\n            # no activity yet, use start date\n            # last_activity may be None with jupyterhub 0.9,\n            # which introduces the 'created' field which is never None\n            inactive = age\n\n        should_cull = (inactive is not None and\n                       inactive.total_seconds() >= inactive_limit)\n        if should_cull:\n            app_log.info(\n                \"Culling user %s (inactive for %s)\",\n                user['name'], inactive)\n\n        if max_age and not should_cull:\n            # only check created if max_age is specified\n            # so that we can still be compatible with jupyterhub 0.8\n            # which doesn't define the 'started' field\n            if age is not None and age.total_seconds() >= max_age:\n                app_log.info(\n                    \"Culling user %s (age: %s, inactive for %s)\",\n                    user['name'], format_td(age), format_td(inactive))\n                should_cull = True\n\n        if not should_cull:\n            app_log.debug(\n                \"Not culling user %s (created: %s, last active: %s)\",\n                user['name'], format_td(age), format_td(inactive))\n            return False\n\n        req = HTTPRequest(\n            url=url + '/users/%s' % user['name'],\n            method='DELETE',\n            headers=auth_header,\n        )\n        yield fetch(req)\n        return True\n\n    for user in users:\n        futures.append((user['name'], handle_user(user)))\n\n    for (name, f) in futures:\n        try:\n            result = yield f\n        except Exception:\n            app_log.exception(\"Error processing %s\", name)\n        else:\n            if result:\n                app_log.debug(\"Finished culling %s\", name)\n\n\nif __name__ == '__main__':\n    define(\n        'url',\n        default=os.environ.get('JUPYTERHUB_API_URL'),\n        help=\"The JupyterHub API URL\",\n    )\n    define('timeout', default=600, help=\"The idle timeout (in seconds)\")\n    define('cull_every', default=0,\n           help=\"The interval (in seconds) for checking for idle servers to cull\")\n    define('max_age', default=0,\n           help=\"The maximum age (in seconds) of servers that should be culled even if they are active\")\n    define('cull_users', default=False,\n           help=\"\"\"Cull users in addition to servers.\n                This is for use in temporary-user cases such as BinderHub.\"\"\",\n           )\n    define('remove_named_servers', default=False,\n           help=\"\"\"Remove named servers in addition to stopping them.\n                This is useful for a BinderHub that uses authentication and named servers.\"\"\",\n           )\n    define('concurrency', default=10,\n           help=\"\"\"Limit the number of concurrent requests made to the Hub.\n\n                Deleting a lot of users at the same time can slow down the Hub,\n                so limit the number of API requests we have outstanding at any given time.\n                \"\"\"\n           )\n\n    parse_command_line()\n    if not options.cull_every:\n        options.cull_every = options.timeout // 2\n    api_token = os.environ['JUPYTERHUB_API_TOKEN']\n\n    try:\n        AsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n    except ImportError as e:\n        app_log.warning(\n            \"Could not load pycurl: %s\\n\"\n            \"pycurl is recommended if you have a large number of users.\",\n            e)\n\n    loop = IOLoop.current()\n    cull = partial(\n        cull_idle,\n        url=options.url,\n        api_token=api_token,\n        inactive_limit=options.timeout,\n        cull_users=options.cull_users,\n        remove_named_servers=options.remove_named_servers,\n        max_age=options.max_age,\n        concurrency=options.concurrency,\n    )\n    # schedule first cull immediately\n    # because PeriodicCallback doesn't start until the end of the first interval\n    loop.add_callback(cull)\n    # schedule periodic cull\n    pc = PeriodicCallback(cull, 1e3 * options.cull_every)\n    pc.start()\n    try:\n        loop.start()\n    except KeyboardInterrupt:\n        pass\n",
      "jupyterhub_config.py": "import os\nimport re\nimport sys\n\nfrom tornado.httpclient import AsyncHTTPClient\nfrom kubernetes import client\nfrom jupyterhub.utils import url_path_join\n\n# Make sure that modules placed in the same directory as the jupyterhub config are added to the pythonpath\nconfiguration_directory = os.path.dirname(os.path.realpath(__file__))\nsys.path.insert(0, configuration_directory)\n\nfrom z2jh import get_config, set_config_if_not_none\n\n# Configure JupyterHub to use the curl backend for making HTTP requests,\n# rather than the pure-python implementations. The default one starts\n# being too slow to make a large number of requests to the proxy API\n# at the rate required.\nAsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n\n# Patch for CVE-2020-15110: change default template for named servers\n# with kubespawner 0.11, {servername} *contains* a leading '-'\n# leading `{user}-{server}` to create `username--servername`,\n# preventing collision.\n# kubespawner 0.12 does not contain `-` in {servername},\n# and uses default name template `{username}--{servername}`\n# so this patch must not be used with kubespawner >= 0.12\n\nfrom distutils.version import LooseVersion as V\nfrom traitlets import default\nimport kubespawner\nfrom kubespawner import KubeSpawner\n\n\nclass PatchedKubeSpawner(KubeSpawner):\n    @default(\"pod_name_template\")\n    def _default_pod_name_template(self):\n        if self.name:\n            return \"jupyter-{username}-{servername}\"\n        else:\n            return \"jupyter-{username}\"\n\n    @default(\"pvc_name_template\")\n    def _default_pvc_name_template(self):\n        if self.name:\n            return \"claim-{username}-{servername}\"\n        else:\n            return \"claim-{username}\"\n\n\nkubespawner_version = getattr(kubespawner, \"__version__\", \"0.11\")\nif V(kubespawner_version) < V(\"0.11.999\"):\n    c.JupyterHub.spawner_class = PatchedKubeSpawner\nelse:\n    # 0.12 or greater, defaults are safe\n    c.JupyterHub.spawner_class = KubeSpawner\n\n# Connect to a proxy running in a different pod\nc.ConfigurableHTTPProxy.api_url = 'http://{}:{}'.format(os.environ['PROXY_API_SERVICE_HOST'], int(os.environ['PROXY_API_SERVICE_PORT']))\nc.ConfigurableHTTPProxy.should_start = False\n\n# Do not shut down user pods when hub is restarted\nc.JupyterHub.cleanup_servers = False\n\n# Check that the proxy has routes appropriately setup\nc.JupyterHub.last_activity_interval = 60\n\n# Don't wait at all before redirecting a spawning user to the progress page\nc.JupyterHub.tornado_settings = {\n    'slow_spawn_timeout': 0,\n}\n\n\ndef camelCaseify(s):\n    \"\"\"convert snake_case to camelCase\n\n    For the common case where some_value is set from someValue\n    so we don't have to specify the name twice.\n    \"\"\"\n    return re.sub(r\"_([a-z])\", lambda m: m.group(1).upper(), s)\n\n\n# configure the hub db connection\ndb_type = get_config('hub.db.type')\nif db_type == 'sqlite-pvc':\n    c.JupyterHub.db_url = \"sqlite:///jupyterhub.sqlite\"\nelif db_type == \"sqlite-memory\":\n    c.JupyterHub.db_url = \"sqlite://\"\nelse:\n    set_config_if_not_none(c.JupyterHub, \"db_url\", \"hub.db.url\")\n    \n\nfor trait, cfg_key in (\n    # Max number of servers that can be spawning at any one time\n    ('concurrent_spawn_limit', None),\n    # Max number of servers to be running at one time\n    ('active_server_limit', None),\n    # base url prefix\n    ('base_url', None),\n    ('allow_named_servers', None),\n    ('named_server_limit_per_user', None),\n    ('authenticate_prometheus', None),\n    ('redirect_to_server', None),\n    ('shutdown_on_logout', None),\n    ('template_paths', None),\n    ('template_vars', None),\n):\n    if cfg_key is None:\n        cfg_key = camelCaseify(trait)\n    set_config_if_not_none(c.JupyterHub, trait, 'hub.' + cfg_key)\n\nc.JupyterHub.ip = os.environ['PROXY_PUBLIC_SERVICE_HOST']\nc.JupyterHub.port = int(os.environ['PROXY_PUBLIC_SERVICE_PORT'])\n\n# the hub should listen on all interfaces, so the proxy can access it\nc.JupyterHub.hub_ip = '0.0.0.0'\n\n# implement common labels\n# this duplicates the jupyterhub.commonLabels helper\ncommon_labels = c.KubeSpawner.common_labels = {}\ncommon_labels['app'] = get_config(\n    \"nameOverride\",\n    default=get_config(\"Chart.Name\", \"jupyterhub\"),\n)\ncommon_labels['heritage'] = \"jupyterhub\"\nchart_name = get_config('Chart.Name')\nchart_version = get_config('Chart.Version')\nif chart_name and chart_version:\n    common_labels['chart'] = \"{}-{}\".format(\n        chart_name, chart_version.replace('+', '_'),\n    )\nrelease = get_config('Release.Name')\nif release:\n    common_labels['release'] = release\n\nc.KubeSpawner.namespace = os.environ.get('POD_NAMESPACE', 'default')\n\n# Max number of consecutive failures before the Hub restarts itself\n# requires jupyterhub 0.9.2\nset_config_if_not_none(\n    c.Spawner,\n    'consecutive_failure_limit',\n    'hub.consecutiveFailureLimit',\n)\n\nfor trait, cfg_key in (\n    ('start_timeout', None),\n    ('image_pull_policy', 'image.pullPolicy'),\n    ('events_enabled', 'events'),\n    ('extra_labels', None),\n    ('extra_annotations', None),\n    ('uid', None),\n    ('fs_gid', None),\n    ('service_account', 'serviceAccountName'),\n    ('storage_extra_labels', 'storage.extraLabels'),\n    ('tolerations', 'extraTolerations'),\n    ('node_selector', None),\n    ('node_affinity_required', 'extraNodeAffinity.required'),\n    ('node_affinity_preferred', 'extraNodeAffinity.preferred'),\n    ('pod_affinity_required', 'extraPodAffinity.required'),\n    ('pod_affinity_preferred', 'extraPodAffinity.preferred'),\n    ('pod_anti_affinity_required', 'extraPodAntiAffinity.required'),\n    ('pod_anti_affinity_preferred', 'extraPodAntiAffinity.preferred'),\n    ('lifecycle_hooks', None),\n    ('init_containers', None),\n    ('extra_containers', None),\n    ('mem_limit', 'memory.limit'),\n    ('mem_guarantee', 'memory.guarantee'),\n    ('cpu_limit', 'cpu.limit'),\n    ('cpu_guarantee', 'cpu.guarantee'),\n    ('extra_resource_limits', 'extraResource.limits'),\n    ('extra_resource_guarantees', 'extraResource.guarantees'),\n    ('environment', 'extraEnv'),\n    ('profile_list', None),\n    ('extra_pod_config', None),\n):\n    if cfg_key is None:\n        cfg_key = camelCaseify(trait)\n    set_config_if_not_none(c.KubeSpawner, trait, 'singleuser.' + cfg_key)\n\nimage = get_config(\"singleuser.image.name\")\nif image:\n    tag = get_config(\"singleuser.image.tag\")\n    if tag:\n        image = \"{}:{}\".format(image, tag)\n\n    c.KubeSpawner.image = image\n\nif get_config('singleuser.imagePullSecret.enabled'):\n    c.KubeSpawner.image_pull_secrets = 'singleuser-image-credentials'\n\n# scheduling:\nif get_config('scheduling.userScheduler.enabled'):\n    c.KubeSpawner.scheduler_name = os.environ['HELM_RELEASE_NAME'] + \"-user-scheduler\"\nif get_config('scheduling.podPriority.enabled'):\n    c.KubeSpawner.priority_class_name = os.environ['HELM_RELEASE_NAME'] + \"-default-priority\"\n\n# add node-purpose affinity\nmatch_node_purpose = get_config('scheduling.userPods.nodeAffinity.matchNodePurpose')\nif match_node_purpose:\n    node_selector = dict(\n        matchExpressions=[\n            dict(\n                key=\"hub.jupyter.org/node-purpose\",\n                operator=\"In\",\n                values=[\"user\"],\n            )\n        ],\n    )\n    if match_node_purpose == 'prefer':\n        c.KubeSpawner.node_affinity_preferred.append(\n            dict(\n                weight=100,\n                preference=node_selector,\n            ),\n        )\n    elif match_node_purpose == 'require':\n        c.KubeSpawner.node_affinity_required.append(node_selector)\n    elif match_node_purpose == 'ignore':\n        pass\n    else:\n        raise ValueError(\"Unrecognized value for matchNodePurpose: %r\" % match_node_purpose)\n\n# add dedicated-node toleration\nfor key in (\n    'hub.jupyter.org/dedicated',\n    # workaround GKE not supporting / in initial node taints\n    'hub.jupyter.org_dedicated',\n):\n    c.KubeSpawner.tolerations.append(\n        dict(\n            key=key,\n            operator='Equal',\n            value='user',\n            effect='NoSchedule',\n        )\n    )\n\n# Configure dynamically provisioning pvc\nstorage_type = get_config('singleuser.storage.type')\n\nif storage_type == 'dynamic':\n    pvc_name_template = get_config('singleuser.storage.dynamic.pvcNameTemplate')\n    c.KubeSpawner.pvc_name_template = pvc_name_template\n    volume_name_template = get_config('singleuser.storage.dynamic.volumeNameTemplate')\n    c.KubeSpawner.storage_pvc_ensure = True\n    set_config_if_not_none(c.KubeSpawner, 'storage_class', 'singleuser.storage.dynamic.storageClass')\n    set_config_if_not_none(c.KubeSpawner, 'storage_access_modes', 'singleuser.storage.dynamic.storageAccessModes')\n    set_config_if_not_none(c.KubeSpawner, 'storage_capacity', 'singleuser.storage.capacity')\n\n    # Add volumes to singleuser pods\n    c.KubeSpawner.volumes = [\n        {\n            'name': volume_name_template,\n            'persistentVolumeClaim': {\n                'claimName': pvc_name_template\n            }\n        }\n    ]\n    c.KubeSpawner.volume_mounts = [\n        {\n            'mountPath': get_config('singleuser.storage.homeMountPath'),\n            'name': volume_name_template\n        }\n    ]\nelif storage_type == 'static':\n    pvc_claim_name = get_config('singleuser.storage.static.pvcName')\n    c.KubeSpawner.volumes = [{\n        'name': 'home',\n        'persistentVolumeClaim': {\n            'claimName': pvc_claim_name\n        }\n    }]\n\n    c.KubeSpawner.volume_mounts = [{\n        'mountPath': get_config('singleuser.storage.homeMountPath'),\n        'name': 'home',\n        'subPath': get_config('singleuser.storage.static.subPath')\n    }]\n\nc.KubeSpawner.volumes.extend(get_config('singleuser.storage.extraVolumes', []))\nc.KubeSpawner.volume_mounts.extend(get_config('singleuser.storage.extraVolumeMounts', []))\n\n# Gives spawned containers access to the API of the hub\nc.JupyterHub.hub_connect_ip = os.environ['HUB_SERVICE_HOST']\nc.JupyterHub.hub_connect_port = int(os.environ['HUB_SERVICE_PORT'])\n\n# Allow switching authenticators easily\nauth_type = get_config('auth.type')\nemail_domain = 'local'\n\ncommon_oauth_traits = (\n        ('client_id', None),\n        ('client_secret', None),\n        ('oauth_callback_url', 'callbackUrl'),\n)\n\nif auth_type == 'google':\n    c.JupyterHub.authenticator_class = 'oauthenticator.GoogleOAuthenticator'\n    for trait, cfg_key in common_oauth_traits + (\n        ('hosted_domain', None),\n        ('login_service', None),\n    ):\n        if cfg_key is None:\n            cfg_key = camelCaseify(trait)\n        set_config_if_not_none(c.GoogleOAuthenticator, trait, 'auth.google.' + cfg_key)\n    email_domain = get_config('auth.google.hostedDomain')\nelif auth_type == 'github':\n    c.JupyterHub.authenticator_class = 'oauthenticator.github.GitHubOAuthenticator'\n    for trait, cfg_key in common_oauth_traits + (\n        ('github_organization_whitelist', 'orgWhitelist'),\n    ):\n        if cfg_key is None:\n            cfg_key = camelCaseify(trait)\n        set_config_if_not_none(c.GitHubOAuthenticator, trait, 'auth.github.' + cfg_key)\nelif auth_type == 'cilogon':\n    c.JupyterHub.authenticator_class = 'oauthenticator.CILogonOAuthenticator'\n    for trait, cfg_key in common_oauth_traits:\n        if cfg_key is None:\n            cfg_key = camelCaseify(trait)\n        set_config_if_not_none(c.CILogonOAuthenticator, trait, 'auth.cilogon.' + cfg_key)\nelif auth_type == 'gitlab':\n    c.JupyterHub.authenticator_class = 'oauthenticator.gitlab.GitLabOAuthenticator'\n    for trait, cfg_key in common_oauth_traits + (\n        ('gitlab_group_whitelist', None),\n        ('gitlab_project_id_whitelist', None),\n        ('gitlab_url', None),\n    ):\n        if cfg_key is None:\n            cfg_key = camelCaseify(trait)\n        set_config_if_not_none(c.GitLabOAuthenticator, trait, 'auth.gitlab.' + cfg_key)\nelif auth_type == 'azuread':\n    c.JupyterHub.authenticator_class = 'oauthenticator.azuread.AzureAdOAuthenticator'\n    for trait, cfg_key in common_oauth_traits + (\n        ('tenant_id', None),\n        ('username_claim', None),\n    ):\n        if cfg_key is None:\n            cfg_key = camelCaseify(trait)\n\n        set_config_if_not_none(c.AzureAdOAuthenticator, trait, 'auth.azuread.' + cfg_key)\nelif auth_type == 'mediawiki':\n    c.JupyterHub.authenticator_class = 'oauthenticator.mediawiki.MWOAuthenticator'\n    for trait, cfg_key in common_oauth_traits + (\n        ('index_url', None),\n    ):\n        if cfg_key is None:\n            cfg_key = camelCaseify(trait)\n        set_config_if_not_none(c.MWOAuthenticator, trait, 'auth.mediawiki.' + cfg_key)\nelif auth_type == 'globus':\n    c.JupyterHub.authenticator_class = 'oauthenticator.globus.GlobusOAuthenticator'\n    for trait, cfg_key in common_oauth_traits + (\n        ('identity_provider', None),\n    ):\n        if cfg_key is None:\n            cfg_key = camelCaseify(trait)\n        set_config_if_not_none(c.GlobusOAuthenticator, trait, 'auth.globus.' + cfg_key)\nelif auth_type == 'hmac':\n    c.JupyterHub.authenticator_class = 'hmacauthenticator.HMACAuthenticator'\n    c.HMACAuthenticator.secret_key = bytes.fromhex(get_config('auth.hmac.secretKey'))\nelif auth_type == 'dummy':\n    c.JupyterHub.authenticator_class = 'dummyauthenticator.DummyAuthenticator'\n    set_config_if_not_none(c.DummyAuthenticator, 'password', 'auth.dummy.password')\nelif auth_type == 'tmp':\n    c.JupyterHub.authenticator_class = 'tmpauthenticator.TmpAuthenticator'\nelif auth_type == 'lti':\n    c.JupyterHub.authenticator_class = 'ltiauthenticator.LTIAuthenticator'\n    set_config_if_not_none(c.LTIAuthenticator, 'consumers', 'auth.lti.consumers')\nelif auth_type == 'ldap':\n    c.JupyterHub.authenticator_class = 'ldapauthenticator.LDAPAuthenticator'\n    c.LDAPAuthenticator.server_address = get_config('auth.ldap.server.address')\n    set_config_if_not_none(c.LDAPAuthenticator, 'server_port', 'auth.ldap.server.port')\n    set_config_if_not_none(c.LDAPAuthenticator, 'use_ssl', 'auth.ldap.server.ssl')\n    set_config_if_not_none(c.LDAPAuthenticator, 'allowed_groups', 'auth.ldap.allowedGroups')\n    set_config_if_not_none(c.LDAPAuthenticator, 'bind_dn_template', 'auth.ldap.dn.templates')\n    set_config_if_not_none(c.LDAPAuthenticator, 'lookup_dn', 'auth.ldap.dn.lookup')\n    set_config_if_not_none(c.LDAPAuthenticator, 'lookup_dn_search_filter', 'auth.ldap.dn.search.filter')\n    set_config_if_not_none(c.LDAPAuthenticator, 'lookup_dn_search_user', 'auth.ldap.dn.search.user')\n    set_config_if_not_none(c.LDAPAuthenticator, 'lookup_dn_search_password', 'auth.ldap.dn.search.password')\n    set_config_if_not_none(c.LDAPAuthenticator, 'lookup_dn_user_dn_attribute', 'auth.ldap.dn.user.dnAttribute')\n    set_config_if_not_none(c.LDAPAuthenticator, 'escape_userdn', 'auth.ldap.dn.user.escape')\n    set_config_if_not_none(c.LDAPAuthenticator, 'valid_username_regex', 'auth.ldap.dn.user.validRegex')\n    set_config_if_not_none(c.LDAPAuthenticator, 'user_search_base', 'auth.ldap.dn.user.searchBase')\n    set_config_if_not_none(c.LDAPAuthenticator, 'user_attribute', 'auth.ldap.dn.user.attribute')\nelif auth_type == 'custom':\n    # full_class_name looks like \"myauthenticator.MyAuthenticator\".\n    # To create a docker image with this class availabe, you can just have the\n    # following Dockerfile:\n    #   FROM jupyterhub/k8s-hub:v0.4\n    #   RUN pip3 install myauthenticator\n    full_class_name = get_config('auth.custom.className')\n    c.JupyterHub.authenticator_class = full_class_name\n    auth_class_name = full_class_name.rsplit('.', 1)[-1]\n    auth_config = c[auth_class_name]\n    auth_config.update(get_config('auth.custom.config') or {})\nelse:\n    raise ValueError(\"Unhandled auth type: %r\" % auth_type)\n\nset_config_if_not_none(c.OAuthenticator, 'scope', 'auth.scopes')\n\nset_config_if_not_none(c.Authenticator, 'enable_auth_state', 'auth.state.enabled')\n\n# Enable admins to access user servers\nset_config_if_not_none(c.JupyterHub, 'admin_access', 'auth.admin.access')\nset_config_if_not_none(c.Authenticator, 'admin_users', 'auth.admin.users')\nset_config_if_not_none(c.Authenticator, 'whitelist', 'auth.whitelist.users')\n\nc.JupyterHub.services = []\n\nif get_config('cull.enabled', False):\n    cull_cmd = [\n        'python3',\n        '/etc/jupyterhub/cull_idle_servers.py',\n    ]\n    base_url = c.JupyterHub.get('base_url', '/')\n    cull_cmd.append(\n        '--url=http://127.0.0.1:8081' + url_path_join(base_url, 'hub/api')\n    )\n\n    cull_timeout = get_config('cull.timeout')\n    if cull_timeout:\n        cull_cmd.append('--timeout=%s' % cull_timeout)\n\n    cull_every = get_config('cull.every')\n    if cull_every:\n        cull_cmd.append('--cull-every=%s' % cull_every)\n\n    cull_concurrency = get_config('cull.concurrency')\n    if cull_concurrency:\n        cull_cmd.append('--concurrency=%s' % cull_concurrency)\n\n    if get_config('cull.users'):\n        cull_cmd.append('--cull-users')\n\n    if get_config('cull.removeNamedServers'):\n        cull_cmd.append('--remove-named-servers')\n\n    cull_max_age = get_config('cull.maxAge')\n    if cull_max_age:\n        cull_cmd.append('--max-age=%s' % cull_max_age)\n\n    c.JupyterHub.services.append({\n        'name': 'cull-idle',\n        'admin': True,\n        'command': cull_cmd,\n    })\n\nfor name, service in get_config('hub.services', {}).items():\n    # jupyterhub.services is a list of dicts, but\n    # in the helm chart it is a dict of dicts for easier merged-config\n    service.setdefault('name', name)\n    # handle camelCase->snake_case of api_token\n    api_token = service.pop('apiToken', None)\n    if api_token:\n        service['api_token'] = api_token\n    c.JupyterHub.services.append(service)\n\n\nset_config_if_not_none(c.Spawner, 'cmd', 'singleuser.cmd')\nset_config_if_not_none(c.Spawner, 'default_url', 'singleuser.defaultUrl')\n\ncloud_metadata = get_config('singleuser.cloudMetadata', {})\n\nif not cloud_metadata.get('enabled', False):\n    # Use iptables to block access to cloud metadata by default\n    network_tools_image_name = get_config('singleuser.networkTools.image.name')\n    network_tools_image_tag = get_config('singleuser.networkTools.image.tag')\n    ip_block_container = client.V1Container(\n        name=\"block-cloud-metadata\",\n        image=f\"{network_tools_image_name}:{network_tools_image_tag}\",\n        command=[\n            'iptables',\n            '-A', 'OUTPUT',\n            '-d', cloud_metadata.get('ip', '169.254.169.254'),\n            '-j', 'DROP'\n        ],\n        security_context=client.V1SecurityContext(\n            privileged=True,\n            run_as_user=0,\n            capabilities=client.V1Capabilities(add=['NET_ADMIN'])\n        )\n    )\n\n    c.KubeSpawner.init_containers.append(ip_block_container)\n\n\nif get_config('debug.enabled', False):\n    c.JupyterHub.log_level = 'DEBUG'\n    c.Spawner.debug = True\n\n\nextra_config = get_config('hub.extraConfig', {})\nif isinstance(extra_config, str):\n    from textwrap import indent, dedent\n    msg = dedent(\n    \"\"\"\n    hub.extraConfig should be a dict of strings,\n    but found a single string instead.\n\n    extraConfig as a single string is deprecated\n    as of the jupyterhub chart version 0.6.\n\n    The keys can be anything identifying the\n    block of extra configuration.\n\n    Try this instead:\n\n        hub:\n          extraConfig:\n            myConfig: |\n              {}\n\n    This configuration will still be loaded,\n    but you are encouraged to adopt the nested form\n    which enables easier merging of multiple extra configurations.\n    \"\"\"\n    )\n    print(\n        msg.format(\n            indent(extra_config, ' ' * 10).lstrip()\n        ),\n        file=sys.stderr\n    )\n    extra_config = {'deprecated string': extra_config}\n\nfor key, config_py in sorted(extra_config.items()):\n    print(\"Loading extra config: %s\" % key)\n    exec(config_py)\n",
      "z2jh.py": "\"\"\"\nUtility methods for use in jupyterhub_config.py and dynamic subconfigs.\n\nMethods here can be imported by extraConfig in values.yaml\n\"\"\"\nfrom collections import Mapping\nfrom functools import lru_cache\nimport os\n\nimport yaml\n\n\n# memoize so we only load config once\n@lru_cache()\ndef _load_config():\n    \"\"\"Load configuration from disk\n\n    Memoized to only load once\n    \"\"\"\n    cfg = {}\n    for source in ('config', 'secret'):\n        path = f\"/etc/jupyterhub/{source}/values.yaml\"\n        if os.path.exists(path):\n            print(f\"Loading {path}\")\n            with open(path) as f:\n                values = yaml.safe_load(f)\n            cfg = _merge_dictionaries(cfg, values)\n        else:\n            print(f\"No config at {path}\")\n    return cfg\n\n\ndef _merge_dictionaries(a, b):\n    \"\"\"Merge two dictionaries recursively.\n\n    Simplified From https://stackoverflow.com/a/7205107\n    \"\"\"\n    merged = a.copy()\n    for key in b:\n        if key in a:\n            if isinstance(a[key], Mapping) and isinstance(b[key], Mapping):\n                merged[key] = _merge_dictionaries(a[key], b[key])\n            else:\n                merged[key] = b[key]\n        else:\n            merged[key] = b[key]\n    return merged\n\n\ndef get_config(key, default=None):\n    \"\"\"\n    Find a config item of a given name & return it\n\n    Parses everything as YAML, so lists and dicts are available too\n\n    get_config(\"a.b.c\") returns config['a']['b']['c']\n    \"\"\"\n    value = _load_config()\n    # resolve path in yaml\n    for level in key.split('.'):\n        if not isinstance(value, dict):\n            # a parent is a scalar or null,\n            # can't resolve full path\n            return default\n        if level not in value:\n            return default\n        else:\n            value = value[level]\n    return value\n\n\ndef set_config_if_not_none(cparent, name, key):\n    \"\"\"\n    Find a config item of a given name, set the corresponding Jupyter\n    configuration item if not None\n    \"\"\"\n    data = get_config(key)\n    if data is not None:\n        setattr(cparent, name, data)\n"
    }
  },
  {
    "kind": "ConfigMap",
    "apiVersion": "v1",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "data": {
      "policy.cfg": "{\"alwaysCheckAllPredicates\":false,\"apiVersion\":\"v1\",\"hardPodAffinitySymmetricWeight\":100,\"kind\":\"Policy\",\"predicates\":[{\"name\":\"PodFitsResources\"},{\"name\":\"HostName\"},{\"name\":\"PodFitsHostPorts\"},{\"name\":\"MatchNodeSelector\"},{\"name\":\"NoDiskConflict\"},{\"name\":\"PodToleratesNodeTaints\"},{\"name\":\"MaxEBSVolumeCount\"},{\"name\":\"MaxGCEPDVolumeCount\"},{\"name\":\"MaxAzureDiskVolumeCount\"},{\"name\":\"CheckVolumeBinding\"},{\"name\":\"NoVolumeZoneConflict\"},{\"name\":\"MatchInterPodAffinity\"}],\"priorities\":[{\"name\":\"NodePreferAvoidPodsPriority\",\"weight\":161051},{\"name\":\"NodeAffinityPriority\",\"weight\":14641},{\"name\":\"InterPodAffinityPriority\",\"weight\":1331},{\"name\":\"MostRequestedPriority\",\"weight\":121},{\"name\":\"ImageLocalityPriority\",\"weight\":11}]}"
    }
  },
  {
    "kind": "PersistentVolumeClaim",
    "apiVersion": "v1",
    "metadata": {
      "name": "hub-db-dir",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "accessModes": [
        "ReadWriteOnce"
      ],
      "resources": {
        "requests": {
          "storage": "1Gi"
        }
      }
    }
  },
  {
    "kind": "ClusterRole",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-user-scheduler-complementary",
      "labels": {
        "component": "user-scheduler-complementary",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resourceNames": [
          "user-scheduler"
        ],
        "resources": [
          "configmaps"
        ],
        "verbs": [
          "get",
          "update"
        ]
      },
      {
        "apiGroups": [
          "storage.k8s.io"
        ],
        "resources": [
          "storageclasses"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "persistentvolume",
          "persistentvolumeclaims"
        ],
        "verbs": [
          "update"
        ]
      }
    ]
  },
  {
    "kind": "ClusterRoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-user-scheduler-base",
      "labels": {
        "component": "user-scheduler-base",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "user-scheduler",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "ClusterRole",
      "name": "system:kube-scheduler",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "kind": "ClusterRoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-user-scheduler-complementary",
      "labels": {
        "component": "user-scheduler-complementary",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "user-scheduler",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "ClusterRole",
      "name": "release-name-user-scheduler-complementary",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "kind": "Role",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "pods",
          "persistentvolumeclaims"
        ],
        "verbs": [
          "get",
          "watch",
          "list",
          "create",
          "delete"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "events"
        ],
        "verbs": [
          "get",
          "watch",
          "list"
        ]
      }
    ]
  },
  {
    "kind": "RoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "hub",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "Role",
      "name": "hub",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      },
      "annotations": {
        "prometheus.io/scrape": "true",
        "prometheus.io/path": "/hub/metrics"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "selector": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name"
      },
      "ports": [
        {
          "protocol": "TCP",
          "port": 8081,
          "targetPort": 8081
        }
      ]
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "proxy-api",
      "labels": {
        "component": "proxy-api",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "selector": {
        "component": "proxy",
        "app": "jupyterhub",
        "release": "release-name"
      },
      "ports": [
        {
          "protocol": "TCP",
          "port": 8001,
          "targetPort": 8001
        }
      ]
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "proxy-public",
      "labels": {
        "component": "proxy-public",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "selector": {
        "component": "proxy",
        "release": "release-name"
      },
      "ports": [
        {
          "name": "https",
          "port": 443,
          "protocol": "TCP",
          "targetPort": 443
        },
        {
          "name": "http",
          "port": 80,
          "protocol": "TCP",
          "targetPort": 8000
        }
      ],
      "type": "LoadBalancer"
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "DaemonSet",
    "metadata": {
      "name": "continuous-image-puller",
      "labels": {
        "component": "continuous-image-puller",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "selector": {
        "matchLabels": {
          "component": "continuous-image-puller",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "updateStrategy": {
        "type": "RollingUpdate",
        "rollingUpdate": {
          "maxUnavailable": "100%"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "continuous-image-puller",
            "app": "jupyterhub",
            "release": "release-name"
          }
        },
        "spec": {
          "tolerations": [
            {
              "key": "hub.jupyter.org_dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            },
            {
              "key": "hub.jupyter.org/dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            }
          ],
          "nodeSelector": {},
          "terminationGracePeriodSeconds": 0,
          "automountServiceAccountToken": false,
          "initContainers": [
            {
              "name": "image-pull-singleuser",
              "image": "biodatageeks/pysequila-notebook:0.1.3-ga5af501",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ]
            },
            {
              "name": "image-pull-metadata-block",
              "image": "jupyterhub/k8s-network-tools:0.9.1",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ]
            }
          ],
          "containers": [
            {
              "name": "pause",
              "image": "gcr.io/google_containers/pause:3.1"
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "component": "hub",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "strategy": {
        "type": "Recreate"
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "hub",
            "app": "jupyterhub",
            "release": "release-name",
            "hub.jupyter.org/network-access-proxy-api": "true",
            "hub.jupyter.org/network-access-proxy-http": "true",
            "hub.jupyter.org/network-access-singleuser": "true"
          },
          "annotations": {
            "checksum/config-map": "065ab732e50f600835fe1a4ba6d6facc1f34b88bb7edf85c73aecc1bcbf7351f",
            "checksum/secret": "1094d68d7062379e03742840364280a1cc2fa331d3437dc42ebcff0cee60b00c"
          }
        },
        "spec": {
          "nodeSelector": {},
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "core"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "volumes": [
            {
              "name": "config",
              "configMap": {
                "name": "hub-config"
              }
            },
            {
              "name": "secret",
              "secret": {
                "secretName": "hub-secret"
              }
            },
            {
              "name": "hub-db-dir",
              "persistentVolumeClaim": {
                "claimName": "hub-db-dir"
              }
            }
          ],
          "serviceAccountName": "hub",
          "securityContext": {
            "fsGroup": 1000
          },
          "containers": [
            {
              "name": "hub",
              "image": "jupyterhub/k8s-hub:0.9.1",
              "command": [
                "jupyterhub",
                "--config",
                "/etc/jupyterhub/jupyterhub_config.py",
                "--upgrade-db"
              ],
              "volumeMounts": [
                {
                  "mountPath": "/etc/jupyterhub/jupyterhub_config.py",
                  "subPath": "jupyterhub_config.py",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/z2jh.py",
                  "subPath": "z2jh.py",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/cull_idle_servers.py",
                  "subPath": "cull_idle_servers.py",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/config/",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/secret/",
                  "name": "secret"
                },
                {
                  "mountPath": "/srv/jupyterhub",
                  "name": "hub-db-dir"
                }
              ],
              "resources": {
                "requests": {
                  "cpu": "200m",
                  "memory": "512Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "securityContext": {
                "runAsUser": 11146,
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "env": [
                {
                  "name": "PYTHONUNBUFFERED",
                  "value": "1"
                },
                {
                  "name": "HELM_RELEASE_NAME",
                  "value": "release-name"
                },
                {
                  "name": "POD_NAMESPACE",
                  "valueFrom": {
                    "fieldRef": {
                      "fieldPath": "metadata.namespace"
                    }
                  }
                },
                {
                  "name": "CONFIGPROXY_AUTH_TOKEN",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "hub-secret",
                      "key": "proxy.token"
                    }
                  }
                }
              ],
              "ports": [
                {
                  "containerPort": 8081,
                  "name": "hub"
                }
              ],
              "readinessProbe": {
                "initialDelaySeconds": 0,
                "periodSeconds": 10,
                "httpGet": {
                  "path": "/hub/health",
                  "port": "hub"
                }
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "proxy",
      "labels": {
        "component": "proxy",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "component": "proxy",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "strategy": {
        "type": "Recreate"
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "proxy",
            "app": "jupyterhub",
            "release": "release-name",
            "hub.jupyter.org/network-access-hub": "true",
            "hub.jupyter.org/network-access-singleuser": "true"
          },
          "annotations": {
            "checksum/hub-secret": "ea1d4268fe8d6feef50b1867177e1ffed7d2706007c04af685a0902b78b04655",
            "checksum/proxy-secret": "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b"
          }
        },
        "spec": {
          "terminationGracePeriodSeconds": 60,
          "nodeSelector": {},
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "core"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "containers": [
            {
              "name": "chp",
              "image": "jupyterhub/configurable-http-proxy:4.2.1",
              "command": [
                "configurable-http-proxy",
                "--ip=0.0.0.0",
                "--api-ip=0.0.0.0",
                "--api-port=8001",
                "--default-target=http://$(HUB_SERVICE_HOST):$(HUB_SERVICE_PORT)",
                "--error-target=http://$(HUB_SERVICE_HOST):$(HUB_SERVICE_PORT)/hub/error",
                "--port=8000"
              ],
              "resources": {
                "requests": {
                  "cpu": "200m",
                  "memory": "512Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "env": [
                {
                  "name": "CONFIGPROXY_AUTH_TOKEN",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "hub-secret",
                      "key": "proxy.token"
                    }
                  }
                }
              ],
              "ports": [
                {
                  "containerPort": 8000,
                  "name": "proxy-public"
                },
                {
                  "containerPort": 8001,
                  "name": "api"
                }
              ],
              "livenessProbe": {
                "initialDelaySeconds": 30,
                "periodSeconds": 10,
                "httpGet": {
                  "path": "/_chp_healthz",
                  "port": "proxy-public",
                  "scheme": "HTTP"
                }
              },
              "readinessProbe": {
                "initialDelaySeconds": 0,
                "periodSeconds": 10,
                "httpGet": {
                  "path": "/_chp_healthz",
                  "port": "proxy-public",
                  "scheme": "HTTP"
                }
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 2,
      "selector": {
        "matchLabels": {
          "component": "user-scheduler",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "user-scheduler",
            "app": "jupyterhub",
            "release": "release-name"
          },
          "annotations": {
            "checksum/config-map": "1faff3ba83d005ff41f9d1ac430671413df0bb1cdda4e6bda9099609f6bb5eda"
          }
        },
        "spec": {
          "serviceAccountName": "user-scheduler",
          "nodeSelector": {},
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "core"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "containers": [
            {
              "name": "user-scheduler",
              "image": "gcr.io/google_containers/kube-scheduler-amd64:v1.13.12",
              "command": [
                "/usr/local/bin/kube-scheduler",
                "--scheduler-name=release-name-user-scheduler",
                "--policy-configmap=user-scheduler",
                "--policy-configmap-namespace=default",
                "--lock-object-name=user-scheduler",
                "--lock-object-namespace=default",
                "--leader-elect-resource-lock=configmaps",
                "--v=4"
              ],
              "livenessProbe": {
                "httpGet": {
                  "path": "/healthz",
                  "port": 10251
                },
                "initialDelaySeconds": 15
              },
              "readinessProbe": {
                "httpGet": {
                  "path": "/healthz",
                  "port": 10251
                }
              },
              "resources": {
                "requests": {
                  "cpu": "50m",
                  "memory": "256Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "user-placeholder",
      "labels": {
        "component": "user-placeholder",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "podManagementPolicy": "Parallel",
      "replicas": 0,
      "selector": {
        "matchLabels": {
          "component": "user-placeholder",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "serviceName": "user-placeholder",
      "template": {
        "metadata": {
          "labels": {
            "component": "user-placeholder",
            "app": "jupyterhub",
            "release": "release-name"
          }
        },
        "spec": {
          "schedulerName": "release-name-user-scheduler",
          "tolerations": [
            {
              "key": "hub.jupyter.org_dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            },
            {
              "key": "hub.jupyter.org/dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            }
          ],
          "nodeSelector": {},
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "user"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "terminationGracePeriodSeconds": 0,
          "automountServiceAccountToken": false,
          "containers": [
            {
              "name": "pause",
              "image": "gcr.io/google_containers/pause:3.1",
              "resources": {
                "requests": {
                  "memory": "1G"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "hook-image-awaiter",
      "labels": {
        "component": "image-puller",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm",
        "hub.jupyter.org/deletable": "true"
      },
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded",
        "helm.sh/hook-weight": "0"
      }
    }
  },
  {
    "kind": "Role",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "hook-image-awaiter",
      "labels": {
        "component": "image-puller",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm",
        "hub.jupyter.org/deletable": "true"
      },
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded",
        "helm.sh/hook-weight": "0"
      }
    },
    "rules": [
      {
        "apiGroups": [
          "apps"
        ],
        "resources": [
          "daemonsets"
        ],
        "verbs": [
          "get"
        ]
      }
    ]
  },
  {
    "kind": "RoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "hook-image-awaiter",
      "labels": {
        "component": "image-puller",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm",
        "hub.jupyter.org/deletable": "true"
      },
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded",
        "helm.sh/hook-weight": "0"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "hook-image-awaiter",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "Role",
      "name": "hook-image-awaiter",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "DaemonSet",
    "metadata": {
      "name": "hook-image-puller",
      "labels": {
        "component": "hook-image-puller",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm",
        "hub.jupyter.org/deletable": "true"
      },
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded",
        "helm.sh/hook-weight": "-10"
      }
    },
    "spec": {
      "selector": {
        "matchLabels": {
          "component": "hook-image-puller",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "updateStrategy": {
        "type": "RollingUpdate",
        "rollingUpdate": {
          "maxUnavailable": "100%"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "hook-image-puller",
            "app": "jupyterhub",
            "release": "release-name"
          }
        },
        "spec": {
          "tolerations": [
            {
              "key": "hub.jupyter.org_dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            },
            {
              "key": "hub.jupyter.org/dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            }
          ],
          "nodeSelector": {},
          "terminationGracePeriodSeconds": 0,
          "automountServiceAccountToken": false,
          "initContainers": [
            {
              "name": "image-pull-singleuser",
              "image": "biodatageeks/pysequila-notebook:0.1.3-ga5af501",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ]
            },
            {
              "name": "image-pull-metadata-block",
              "image": "jupyterhub/k8s-network-tools:0.9.1",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ]
            }
          ],
          "containers": [
            {
              "name": "pause",
              "image": "gcr.io/google_containers/pause:3.1"
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "batch/v1",
    "kind": "Job",
    "metadata": {
      "name": "hook-image-awaiter",
      "labels": {
        "component": "image-puller",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.9.1",
        "heritage": "Helm",
        "hub.jupyter.org/deletable": "true"
      },
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded",
        "helm.sh/hook-weight": "10"
      }
    },
    "spec": {
      "template": {
        "metadata": {
          "labels": {
            "component": "image-puller",
            "app": "jupyterhub",
            "release": "release-name"
          }
        },
        "spec": {
          "restartPolicy": "Never",
          "serviceAccountName": "hook-image-awaiter",
          "containers": [
            {
              "image": "jupyterhub/k8s-image-awaiter:0.9.1",
              "name": "hook-image-awaiter",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/image-awaiter",
                "-ca-path=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt",
                "-auth-token-path=/var/run/secrets/kubernetes.io/serviceaccount/token",
                "-api-server-address=https://$(KUBERNETES_SERVICE_HOST):$(KUBERNETES_SERVICE_PORT)",
                "-namespace=default",
                "-daemonset=hook-image-puller"
              ]
            }
          ]
        }
      }
    }
  }
]