[
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "release-name-vela-core-legacy",
      "labels": {
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "vela-addon-registry",
      "namespace": "lqgAXnRcu"
    },
    "data": {
      "registries": "{ \"KubeVela\":{ \"name\": \"KubeVela\", \"helm\": { \"url\": \"https://addons.kubevela.net\" } } }"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "service-applied-resources-view",
      "namespace": "lqgAXnRcu"
    },
    "data": {
      "template": "import (\n    \"vela/ql\"\n)\nparameter: {\n    appName:    string\n    appNs:      string\n    name?:      string\n    cluster?:   string\n    clusterNs?: string\n}\nresponse: ql.#ListAppliedResources & {\n    app: {\n        name:      parameter.appName\n        namespace: parameter.appNs\n        filter: {\n            if parameter.cluster != _|_ {\n                cluster: parameter.cluster\n            }\n            if parameter.clusterNs != _|_ {\n                clusterNamespace: parameter.clusterNs\n            }\n            if parameter.name != _|_ {\n                components: [parameter.name]\n            }\n        }\n    }\n}\nif response.err == _|_ {\n    status: {\n        resources: response.list\n    }\n}\nif response.err != _|_ {\n    status: {\n        error: response.err\n    }\n}\n"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "service-endpoints-view",
      "namespace": "lqgAXnRcu"
    },
    "data": {
      "template": "import (\n    \"vela/ql\"\n)\nparameter: {\n    appName:    string\n    appNs:      string\n    name?:      string\n    cluster?:   string\n    clusterNs?: string\n}\nresources: ql.#CollectServiceEndpoints & {\n    app: {\n        name:      parameter.appName\n        namespace: parameter.appNs\n        filter: {\n            if parameter.cluster != _|_ {\n                cluster: parameter.cluster\n            }\n            if parameter.clusterNs != _|_ {\n                clusterNamespace: parameter.clusterNs\n            }\n            if parameter.name != _|_ {\n                components: [parameter.name]\n            }\n        }\n    }\n}\nif resources.err == _|_ {\n    status: {\n        endpoints: resources.list\n    }\n}\nif resources.err != _|_ {\n    status: {\n        error: resources.err\n    }\n}\n"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "application-resource-tree-view",
      "namespace": "lqgAXnRcu"
    },
    "data": {
      "template": "import (\n    \"vela/ql\"\n)\nparameter: {\n    appName:    string\n    appNs:      string\n    name?:      string\n    cluster?:   string\n    clusterNs?: string\n}\nresponse: ql.#GetApplicationTree & {\n    app: {\n        name:      parameter.appName\n        namespace: parameter.appNs\n        filter: {\n            if parameter.cluster != _|_ {\n                cluster: parameter.cluster\n            }\n            if parameter.clusterNs != _|_ {\n                clusterNamespace: parameter.clusterNs\n            }\n            if parameter.name != _|_ {\n                components: [parameter.name]\n            }\n        }\n    }\n}\n\nif response.err == _|_ {\n    status: {\n        resources: response.list\n    }\n}\nif response.err != _|_ {\n    status: {\n        error: response.err\n    }\n}\n"
    }
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "ClusterRole",
    "metadata": {
      "name": "release-name-vela-core-legacy:cluster-gateway:proxy"
    },
    "rules": [
      {
        "apiGroups": [
          "cluster.core.oam.dev"
        ],
        "resources": [
          "clustergateways/proxy"
        ],
        "verbs": [
          "get",
          "list",
          "watch",
          "create",
          "update",
          "patch",
          "delete"
        ]
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "ClusterRoleBinding",
    "metadata": {
      "name": "release-name-vela-core-legacy:cluster-gateway:proxy"
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "ClusterRole",
      "name": "release-name-vela-core-legacy:cluster-gateway:proxy"
    },
    "subjects": [
      {
        "kind": "Group",
        "name": "kubevela:client",
        "apiGroup": "rbac.authorization.k8s.io"
      },
      {
        "kind": "ServiceAccount",
        "name": "release-name-vela-core-legacy",
        "namespace": "default"
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "ClusterRoleBinding",
    "metadata": {
      "name": "release-name-vela-core-legacy:manager-rolebinding"
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "ClusterRole",
      "name": "cluster-admin"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-vela-core-legacy",
        "namespace": "default"
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "Role",
    "metadata": {
      "name": "release-name-vela-core-legacy:leader-election-role"
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "configmaps"
        ],
        "verbs": [
          "get",
          "list",
          "watch",
          "create",
          "update",
          "patch",
          "delete"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "configmaps/status"
        ],
        "verbs": [
          "get",
          "update",
          "patch"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "events"
        ],
        "verbs": [
          "create"
        ]
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
      "name": "release-name-vela-core-legacy:leader-election-rolebinding"
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "Role",
      "name": "release-name-vela-core-legacy:leader-election-role"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-vela-core-legacy"
      }
    ]
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "vela-core-legacy-webhook",
      "namespace": "lqgAXnRcu",
      "labels": {
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "port": 443,
          "targetPort": 9443,
          "protocol": "TCP",
          "name": "https"
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-cluster-gateway-service",
      "namespace": "lqgAXnRcu"
    },
    "spec": {
      "selector": {
        "app.kubernetes.io/name": "vela-core-legacy-cluster-gateway",
        "app.kubernetes.io/instance": "release-name-cluster-gateway"
      },
      "ports": [
        {
          "protocol": "TCP",
          "port": 9443,
          "targetPort": 9443
        }
      ]
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-cluster-gateway",
      "namespace": "lqgAXnRcu",
      "labels": {
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "vela-core-legacy-cluster-gateway",
          "app.kubernetes.io/instance": "release-name-cluster-gateway"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "vela-core-legacy-cluster-gateway",
            "app.kubernetes.io/instance": "release-name-cluster-gateway"
          }
        },
        "spec": {
          "serviceAccountName": "release-name-vela-core-legacy",
          "securityContext": {},
          "containers": [
            {
              "name": "release-name-vela-core-legacy-cluster-gateway",
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true,
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "args": [
                "apiserver",
                "--secure-port=9443",
                "--secret-namespace=default",
                "--feature-gates=APIPriorityAndFairness=false,ClientIdentityPenetration=false",
                "--tls-cert-file=/etc/k8s-cluster-gateway-certs/tls.crt",
                "--tls-private-key-file=/etc/k8s-cluster-gateway-certs/tls.key"
              ],
              "image": "oamdev/cluster-gateway:v1.4.0",
              "imagePullPolicy": "IfNotPresent",
              "resources": {
                "limits": {
                  "cpu": "100m",
                  "memory": "200Mi"
                }
              },
              "ports": [
                {
                  "containerPort": 9443
                }
              ],
              "volumeMounts": [
                {
                  "mountPath": "/etc/k8s-cluster-gateway-certs",
                  "name": "tls-cert-vol",
                  "readOnly": true
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "tls-cert-vol",
              "secret": {
                "defaultMode": 420,
                "secretName": "release-name-vela-core-legacy-cluster-gateway-tls-v2"
              }
            }
          ]
        }
      },
      "strategy": {
        "type": "RollingUpdate",
        "rollingUpdate": {
          "maxSurge": 1,
          "maxUnavailable": 1
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-vela-core-legacy",
      "namespace": "lqgAXnRcu",
      "labels": {
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "vela-core-legacy",
          "app.kubernetes.io/instance": "release-name"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "vela-core-legacy",
            "app.kubernetes.io/instance": "release-name"
          },
          "annotations": {
            "prometheus.io/path": "/metrics",
            "prometheus.io/port": "8080",
            "prometheus.io/scrape": "true"
          }
        },
        "spec": {
          "serviceAccountName": "release-name-vela-core-legacy",
          "securityContext": {},
          "containers": [
            {
              "name": "release-name",
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true,
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "args": [
                "--metrics-addr=:8080",
                "--enable-leader-election",
                "--use-webhook=true",
                "--webhook-port=9443",
                "--webhook-cert-dir=/etc/k8s-webhook-certs",
                "--optimize-mark-with-prob=0.1",
                "--health-addr=:9440",
                "--disable-caps=rollout",
                "--system-definition-namespace=default",
                "--application-revision-limit=10",
                "--definition-revision-limit=20",
                "--oam-spec-ver=v0.3",
                "--enable-cluster-gateway",
                "--application-re-sync-period=5m",
                "--concurrent-reconciles=4",
                "--kube-api-qps=50",
                "--kube-api-burst=100",
                "--max-workflow-wait-backoff-time=60",
                "--max-workflow-failed-backoff-time=300",
                "--max-workflow-step-error-retry-times=10",
                "--feature-gates=EnableSuspendOnFailure=false",
                "--feature-gates=AuthenticateApplication=false"
              ],
              "image": "oamdev/vela-core:v1.4.1",
              "imagePullPolicy": "Always",
              "resources": {
                "limits": {
                  "cpu": "500m",
                  "memory": "1Gi"
                },
                "requests": {
                  "cpu": "50m",
                  "memory": "20Mi"
                }
              },
              "ports": [
                {
                  "containerPort": 9443,
                  "name": "webhook-server",
                  "protocol": "TCP"
                },
                {
                  "containerPort": 9440,
                  "name": "healthz",
                  "protocol": "TCP"
                }
              ],
              "readinessProbe": {
                "httpGet": {
                  "path": "/readyz",
                  "port": "healthz"
                },
                "initialDelaySeconds": 30,
                "periodSeconds": 5
              },
              "livenessProbe": {
                "httpGet": {
                  "path": "/healthz",
                  "port": "healthz"
                },
                "initialDelaySeconds": 90,
                "periodSeconds": 5
              },
              "volumeMounts": [
                {
                  "mountPath": "/etc/k8s-webhook-certs",
                  "name": "tls-cert-vol",
                  "readOnly": true
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "tls-cert-vol",
              "secret": {
                "defaultMode": 420,
                "secretName": "release-name-vela-core-legacy-admission"
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apiregistration.k8s.io/v1",
    "kind": "APIService",
    "metadata": {
      "name": "v1alpha1.cluster.core.oam.dev",
      "annotations": null,
      "labels": {
        "api": "cluster-extension-apiserver",
        "apiserver": "true"
      }
    },
    "spec": {
      "version": "v1alpha1",
      "group": "cluster.core.oam.dev",
      "groupPriorityMinimum": 2000,
      "service": {
        "name": "release-name-cluster-gateway-service",
        "namespace": "default",
        "port": 9443
      },
      "versionPriority": 10,
      "insecureSkipTLSVerify": false,
      "caBundle": "Cg=="
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "custom.definition.oam.dev/alias.config.oam.dev": "Image Registry",
        "definition.oam.dev/description": "Config information to authenticate image registry"
      },
      "labels": {
        "custom.definition.oam.dev/catalog.config.oam.dev": "velacore-config",
        "custom.definition.oam.dev/multi-cluster.config.oam.dev": "true",
        "custom.definition.oam.dev/type.config.oam.dev": "image-registry",
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "config-image-registry",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n)\n\noutput: {\n\tapiVersion: \"v1\"\n\tkind:       \"Secret\"\n\tmetadata: {\n\t\tname:      context.name\n\t\tnamespace: context.namespace\n\t\tlabels: {\n\t\t\t\"config.oam.dev/catalog\":       \"velacore-config\"\n\t\t\t\"config.oam.dev/type\":          \"image-registry\"\n\t\t\t\"config.oam.dev/multi-cluster\": \"true\"\n\t\t\t\"config.oam.dev/identifier\":    parameter.registry\n\t\t\t\"config.oam.dev/sub-type\":      \"auth\"\n\t\t}\n\t}\n\tif parameter.auth != _|_ {\n\t\ttype: \"kubernetes.io/dockerconfigjson\"\n\t}\n\tif parameter.auth == _|_ {\n\t\ttype: \"Opaque\"\n\t}\n\tif parameter.auth != _|_ {\n\t\tstringData: \".dockerconfigjson\": json.Marshal({\n\t\t\tauths: \"\\(parameter.registry)\": {\n\t\t\t\tusername: parameter.auth.username\n\t\t\t\tpassword: parameter.auth.password\n\t\t\t\tif parameter.auth.email != _|_ {\n\t\t\t\t\temail: parameter.auth.email\n\t\t\t\t}\n\t\t\t\tauth: base64.Encode(null, (parameter.auth.username + \":\" + parameter.auth.password))\n\t\t\t}\n\t\t})\n\t}\n}\nparameter: {\n\t// +usage=Image registry FQDN\n\tregistry: string\n\t// +usage=Authenticate the image registry\n\tauth?: {\n\t\t// +usage=Private Image registry username\n\t\tusername: string\n\t\t// +usage=Private Image registry password\n\t\tpassword: string\n\t\t// +usage=Private Image registry email\n\t\temail?: string\n\t}\n}\n"
        }
      },
      "workload": {
        "type": "autodetects.core.oam.dev"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Describes cron jobs that run code or a script to completion."
      },
      "name": "cron-task",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "output: {\n\tapiVersion: \"batch/v1beta1\"\n\tkind:       \"CronJob\"\n\tspec: {\n\t\tschedule:                   parameter.schedule\n\t\tconcurrencyPolicy:          parameter.concurrencyPolicy\n\t\tsuspend:                    parameter.suspend\n\t\tsuccessfulJobsHistoryLimit: parameter.successfulJobsHistoryLimit\n\t\tfailedJobsHistoryLimit:     parameter.failedJobsHistoryLimit\n\t\tif parameter.startingDeadlineSeconds != _|_ {\n\t\t\tstartingDeadlineSeconds: parameter.startingDeadlineSeconds\n\t\t}\n\t\tjobTemplate: {\n\t\t\tmetadata: {\n\t\t\t\tlabels: {\n\t\t\t\t\tif parameter.labels != _|_ {\n\t\t\t\t\t\tparameter.labels\n\t\t\t\t\t}\n\t\t\t\t\t\"app.oam.dev/name\":      context.appName\n\t\t\t\t\t\"app.oam.dev/component\": context.name\n\t\t\t\t}\n\t\t\t\tif parameter.annotations != _|_ {\n\t\t\t\t\tannotations: parameter.annotations\n\t\t\t\t}\n\t\t\t}\n\t\t\tspec: {\n\t\t\t\tparallelism: parameter.count\n\t\t\t\tcompletions: parameter.count\n\t\t\t\tif parameter.ttlSecondsAfterFinished != _|_ {\n\t\t\t\t\tttlSecondsAfterFinished: parameter.ttlSecondsAfterFinished\n\t\t\t\t}\n\t\t\t\tif parameter.activeDeadlineSeconds != _|_ {\n\t\t\t\t\tactiveDeadlineSeconds: parameter.activeDeadlineSeconds\n\t\t\t\t}\n\t\t\t\tbackoffLimit: parameter.backoffLimit\n\t\t\t\ttemplate: {\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tlabels: {\n\t\t\t\t\t\t\tif parameter.labels != _|_ {\n\t\t\t\t\t\t\t\tparameter.labels\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\"app.oam.dev/name\":      context.appName\n\t\t\t\t\t\t\t\"app.oam.dev/component\": context.name\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif parameter.annotations != _|_ {\n\t\t\t\t\t\t\tannotations: parameter.annotations\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tspec: {\n\t\t\t\t\t\trestartPolicy: parameter.restart\n\t\t\t\t\t\tcontainers: [{\n\t\t\t\t\t\t\tname:  context.name\n\t\t\t\t\t\t\timage: parameter.image\n\t\t\t\t\t\t\tif parameter[\"imagePullPolicy\"] != _|_ {\n\t\t\t\t\t\t\t\timagePullPolicy: parameter.imagePullPolicy\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif parameter[\"cmd\"] != _|_ {\n\t\t\t\t\t\t\t\tcommand: parameter.cmd\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif parameter[\"env\"] != _|_ {\n\t\t\t\t\t\t\t\tenv: parameter.env\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif parameter[\"cpu\"] != _|_ {\n\t\t\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\t\t\tlimits: cpu:   parameter.cpu\n\t\t\t\t\t\t\t\t\trequests: cpu: parameter.cpu\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif parameter[\"memory\"] != _|_ {\n\t\t\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\t\t\tlimits: memory:   parameter.memory\n\t\t\t\t\t\t\t\t\trequests: memory: parameter.memory\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif parameter[\"volumes\"] != _|_ {\n\t\t\t\t\t\t\t\tvolumeMounts: [ for v in parameter.volumes {\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tmountPath: v.mountPath\n\t\t\t\t\t\t\t\t\t\tname:      v.name\n\t\t\t\t\t\t\t\t\t}}]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}]\n\t\t\t\t\t\tif parameter[\"volumes\"] != _|_ {\n\t\t\t\t\t\t\tvolumes: [ for v in parameter.volumes {\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tname: v.name\n\t\t\t\t\t\t\t\t\tif v.type == \"pvc\" {\n\t\t\t\t\t\t\t\t\t\tpersistentVolumeClaim: claimName: v.claimName\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif v.type == \"configMap\" {\n\t\t\t\t\t\t\t\t\t\tconfigMap: {\n\t\t\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\t\t\tname:        v.cmName\n\t\t\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif v.type == \"secret\" {\n\t\t\t\t\t\t\t\t\t\tsecret: {\n\t\t\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\t\t\tsecretName:  v.secretName\n\t\t\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif v.type == \"emptyDir\" {\n\t\t\t\t\t\t\t\t\t\temptyDir: medium: v.medium\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}}]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif parameter[\"imagePullSecrets\"] != _|_ {\n\t\t\t\t\t\t\timagePullSecrets: [ for v in parameter.imagePullSecrets {\n\t\t\t\t\t\t\t\tname: v\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif parameter.hostAliases != _|_ {\n\t\t\t\t\t\t\thostAliases: [ for v in parameter.hostAliases {\n\t\t\t\t\t\t\t\tip:        v.ip\n\t\t\t\t\t\t\t\thostnames: v.hostnames\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nparameter: {\n\t// +usage=Specify the labels in the workload\n\tlabels?: [string]: string\n\n\t// +usage=Specify the annotations in the workload\n\tannotations?: [string]: string\n\n\t// +usage=Specify the schedule in Cron format, see https://en.wikipedia.org/wiki/Cron\n\tschedule: string\n\n\t// +usage=Specify deadline in seconds for starting the job if it misses scheduled\n\tstartingDeadlineSeconds?: int\n\n\t// +usage=suspend subsequent executions\n\tsuspend: *false | bool\n\n\t// +usage=Specifies how to treat concurrent executions of a Job\n\tconcurrencyPolicy: *\"Allow\" | \"Allow\" | \"Forbid\" | \"Replace\"\n\n\t// +usage=The number of successful finished jobs to retain\n\tsuccessfulJobsHistoryLimit: *3 | int\n\n\t// +usage=The number of failed finished jobs to retain\n\tfailedJobsHistoryLimit: *1 | int\n\n\t// +usage=Specify number of tasks to run in parallel\n\t// +short=c\n\tcount: *1 | int\n\n\t// +usage=Which image would you like to use for your service\n\t// +short=i\n\timage: string\n\n\t// +usage=Specify image pull policy for your service\n\timagePullPolicy?: \"Always\" | \"Never\" | \"IfNotPresent\"\n\n\t// +usage=Specify image pull secrets for your service\n\timagePullSecrets?: [...string]\n\n\t// +usage=Define the job restart policy, the value can only be Never or OnFailure. By default, it's Never.\n\trestart: *\"Never\" | string\n\n\t// +usage=Commands to run in the container\n\tcmd?: [...string]\n\n\t// +usage=Define arguments by using environment variables\n\tenv?: [...{\n\t\t// +usage=Environment variable name\n\t\tname: string\n\t\t// +usage=The value of the environment variable\n\t\tvalue?: string\n\t\t// +usage=Specifies a source the value of this var should come from\n\t\tvalueFrom?: {\n\t\t\t// +usage=Selects a key of a secret in the pod's namespace\n\t\t\tsecretKeyRef: {\n\t\t\t\t// +usage=The name of the secret in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the secret to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t\t// +usage=Selects a key of a config map in the pod's namespace\n\t\t\tconfigMapKeyRef: {\n\t\t\t\t// +usage=The name of the config map in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the config map to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t}]\n\n\t// +usage=Number of CPU units for the service, like `0.5` (0.5 CPU core), `1` (1 CPU core)\n\tcpu?: string\n\n\t// +usage=Specifies the attributes of the memory resource required for the container.\n\tmemory?: string\n\n\t// +usage=Declare volumes and volumeMounts\n\tvolumes?: [...{\n\t\tname:      string\n\t\tmountPath: string\n\t\t// +usage=Specify volume type, options: \"pvc\",\"configMap\",\"secret\",\"emptyDir\"\n\t\ttype: \"pvc\" | \"configMap\" | \"secret\" | \"emptyDir\"\n\t\tif type == \"pvc\" {\n\t\t\tclaimName: string\n\t\t}\n\t\tif type == \"configMap\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tcmName:      string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"secret\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tsecretName:  string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"emptyDir\" {\n\t\t\tmedium: *\"\" | \"Memory\"\n\t\t}\n\t}]\n\n\t// +usage=An optional list of hosts and IPs that will be injected into the pod's hosts file\n\thostAliases?: [...{\n\t\tip: string\n\t\thostnames: [...string]\n\t}]\n\n\t// +usage=Limits the lifetime of a Job that has finished\n\tttlSecondsAfterFinished?: int\n\n\t// +usage=The duration in seconds relative to the startTime that the job may be continuously active before the system tries to terminate it\n\tactiveDeadlineSeconds?: int\n\n\t// +usage=The number of retries before marking this job failed\n\tbackoffLimit: *6 | int\n\n\t// +usage=Instructions for assessing whether the container is alive.\n\tlivenessProbe?: #HealthProbe\n\n\t// +usage=Instructions for assessing whether the container is in a suitable state to serve traffic.\n\treadinessProbe?: #HealthProbe\n}\n#HealthProbe: {\n\n\t// +usage=Instructions for assessing container health by executing a command. Either this attribute or the httpGet attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the httpGet attribute and the tcpSocket attribute.\n\texec?: {\n\t\t// +usage=A command to be executed inside the container to assess its health. Each space delimited token of the command is a separate array element. Commands exiting 0 are considered to be successful probes, whilst all other exit codes are considered failures.\n\t\tcommand: [...string]\n\t}\n\n\t// +usage=Instructions for assessing container health by executing an HTTP GET request. Either this attribute or the exec attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the tcpSocket attribute.\n\thttpGet?: {\n\t\t// +usage=The endpoint, relative to the port, to which the HTTP GET request should be directed.\n\t\tpath: string\n\t\t// +usage=The TCP socket within the container to which the HTTP GET request should be directed.\n\t\tport: int\n\t\thttpHeaders?: [...{\n\t\t\tname:  string\n\t\t\tvalue: string\n\t\t}]\n\t}\n\n\t// +usage=Instructions for assessing container health by probing a TCP socket. Either this attribute or the exec attribute or the httpGet attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the httpGet attribute.\n\ttcpSocket?: {\n\t\t// +usage=The TCP socket within the container that should be probed to assess container health.\n\t\tport: int\n\t}\n\n\t// +usage=Number of seconds after the container is started before the first probe is initiated.\n\tinitialDelaySeconds: *0 | int\n\n\t// +usage=How often, in seconds, to execute the probe.\n\tperiodSeconds: *10 | int\n\n\t// +usage=Number of seconds after which the probe times out.\n\ttimeoutSeconds: *1 | int\n\n\t// +usage=Minimum consecutive successes for the probe to be considered successful after having failed.\n\tsuccessThreshold: *1 | int\n\n\t// +usage=Number of consecutive failures required to determine the container is not alive (liveness probe) or not ready (readiness probe).\n\tfailureThreshold: *3 | int\n}\n"
        }
      },
      "workload": {
        "definition": {
          "apiVersion": "batch/v1beta1",
          "kind": "CronJob"
        },
        "type": "cronjobs.batch"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "K8s-objects allow users to specify raw K8s objects in properties"
      },
      "name": "k8s-objects",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "output: parameter.objects[0]\noutputs: {\n\tfor i, v in parameter.objects {\n\t\tif i > 0 {\n\t\t\t\"objects-\\(i)\": v\n\t\t}\n\t}\n}\nparameter: objects: [...{}]\n"
        }
      },
      "workload": {
        "type": "autodetects.core.oam.dev"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Raw allow users to specify raw K8s object in properties. This definition is DEPRECATED, please use 'k8s-objects' instead."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "raw",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "output: parameter\nparameter: {}\n"
        }
      },
      "workload": {
        "type": "autodetects.core.oam.dev"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Ref-objects allow users to specify ref objects to use. Notice that this component type have special handle logic."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "ref-objects",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "#K8sObject: {\n\tapiVersion: string\n\tkind:       string\n\tmetadata: {\n\t\tname: string\n\t\t...\n\t}\n\t...\n}\noutput: parameter.objects[0]\noutputs: {\n\tfor i, v in parameter.objects {\n\t\tif i > 0 {\n\t\t\t\"objects-\\(i)\": v\n\t\t}\n\t}\n}\nparameter: objects: [...#K8sObject]\n"
        }
      },
      "status": {
        "customStatus": "if context.output.apiVersion == \"apps/v1\" && context.output.kind == \"Deployment\" {\n\tready: {\n\t\treadyReplicas: *0 | int\n\t} & {\n\t\tif context.output.status.readyReplicas != _|_ {\n\t\t\treadyReplicas: context.output.status.readyReplicas\n\t\t}\n\t}\n\tmessage: \"Ready:\\(ready.readyReplicas)/\\(context.output.spec.replicas)\"\n}\nif context.output.apiVersion != \"apps/v1\" || context.output.kind != \"Deployment\" {\n\tmessage: \"\"\n}",
        "healthPolicy": "if context.output.apiVersion == \"apps/v1\" && context.output.kind == \"Deployment\" {\n\tready: {\n\t\tupdatedReplicas:    *0 | int\n\t\treadyReplicas:      *0 | int\n\t\treplicas:           *0 | int\n\t\tobservedGeneration: *0 | int\n\t} & {\n\t\tif context.output.status.updatedReplicas != _|_ {\n\t\t\tupdatedReplicas: context.output.status.updatedReplicas\n\t\t}\n\t\tif context.output.status.readyReplicas != _|_ {\n\t\t\treadyReplicas: context.output.status.readyReplicas\n\t\t}\n\t\tif context.output.status.replicas != _|_ {\n\t\t\treplicas: context.output.status.replicas\n\t\t}\n\t\tif context.output.status.observedGeneration != _|_ {\n\t\t\tobservedGeneration: context.output.status.observedGeneration\n\t\t}\n\t}\n\tisHealth: (context.output.spec.replicas == ready.readyReplicas) && (context.output.spec.replicas == ready.updatedReplicas) && (context.output.spec.replicas == ready.replicas) && (ready.observedGeneration == context.output.metadata.generation || ready.observedGeneration > context.output.metadata.generation)\n}\nif context.output.apiVersion != \"apps/v1\" || context.output.kind != \"Deployment\" {\n\tisHealth: true\n}"
      },
      "workload": {
        "type": "autodetects.core.oam.dev"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Describes jobs that run code or a script to completion."
      },
      "name": "task",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "output: {\n\tapiVersion: \"batch/v1\"\n\tkind:       \"Job\"\n\tspec: {\n\t\tparallelism: parameter.count\n\t\tcompletions: parameter.count\n\t\ttemplate: {\n\t\t\tmetadata: {\n\t\t\t\tlabels: {\n\t\t\t\t\tif parameter.labels != _|_ {\n\t\t\t\t\t\tparameter.labels\n\t\t\t\t\t}\n\t\t\t\t\t\"app.oam.dev/name\":      context.appName\n\t\t\t\t\t\"app.oam.dev/component\": context.name\n\t\t\t\t}\n\t\t\t\tif parameter.annotations != _|_ {\n\t\t\t\t\tannotations: parameter.annotations\n\t\t\t\t}\n\t\t\t}\n\t\t\tspec: {\n\t\t\t\trestartPolicy: parameter.restart\n\t\t\t\tcontainers: [{\n\t\t\t\t\tname:  context.name\n\t\t\t\t\timage: parameter.image\n\n\t\t\t\t\tif parameter[\"imagePullPolicy\"] != _|_ {\n\t\t\t\t\t\timagePullPolicy: parameter.imagePullPolicy\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"cmd\"] != _|_ {\n\t\t\t\t\t\tcommand: parameter.cmd\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"env\"] != _|_ {\n\t\t\t\t\t\tenv: parameter.env\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"cpu\"] != _|_ {\n\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\tlimits: cpu:   parameter.cpu\n\t\t\t\t\t\t\trequests: cpu: parameter.cpu\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"memory\"] != _|_ {\n\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\tlimits: memory:   parameter.memory\n\t\t\t\t\t\t\trequests: memory: parameter.memory\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"volumes\"] != _|_ {\n\t\t\t\t\t\tvolumeMounts: [ for v in parameter.volumes {\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmountPath: v.mountPath\n\t\t\t\t\t\t\t\tname:      v.name\n\t\t\t\t\t\t\t}}]\n\t\t\t\t\t}\n\t\t\t\t}]\n\n\t\t\t\tif parameter[\"volumes\"] != _|_ {\n\t\t\t\t\tvolumes: [ for v in parameter.volumes {\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: v.name\n\t\t\t\t\t\t\tif v.type == \"pvc\" {\n\t\t\t\t\t\t\t\tpersistentVolumeClaim: claimName: v.claimName\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"configMap\" {\n\t\t\t\t\t\t\t\tconfigMap: {\n\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\tname:        v.cmName\n\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"secret\" {\n\t\t\t\t\t\t\t\tsecret: {\n\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\tsecretName:  v.secretName\n\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"emptyDir\" {\n\t\t\t\t\t\t\t\temptyDir: medium: v.medium\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}}]\n\t\t\t\t}\n\n\t\t\t\tif parameter[\"imagePullSecrets\"] != _|_ {\n\t\t\t\t\timagePullSecrets: [ for v in parameter.imagePullSecrets {\n\t\t\t\t\t\tname: v\n\t\t\t\t\t},\n\t\t\t\t\t]\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n}\nparameter: {\n\t// +usage=Specify the labels in the workload\n\tlabels?: [string]: string\n\n\t// +usage=Specify the annotations in the workload\n\tannotations?: [string]: string\n\n\t// +usage=Specify number of tasks to run in parallel\n\t// +short=c\n\tcount: *1 | int\n\n\t// +usage=Which image would you like to use for your service\n\t// +short=i\n\timage: string\n\n\t// +usage=Specify image pull policy for your service\n\timagePullPolicy?: \"Always\" | \"Never\" | \"IfNotPresent\"\n\n\t// +usage=Specify image pull secrets for your service\n\timagePullSecrets?: [...string]\n\n\t// +usage=Define the job restart policy, the value can only be Never or OnFailure. By default, it's Never.\n\trestart: *\"Never\" | string\n\n\t// +usage=Commands to run in the container\n\tcmd?: [...string]\n\n\t// +usage=Define arguments by using environment variables\n\tenv?: [...{\n\t\t// +usage=Environment variable name\n\t\tname: string\n\t\t// +usage=The value of the environment variable\n\t\tvalue?: string\n\t\t// +usage=Specifies a source the value of this var should come from\n\t\tvalueFrom?: {\n\t\t\t// +usage=Selects a key of a secret in the pod's namespace\n\t\t\tsecretKeyRef: {\n\t\t\t\t// +usage=The name of the secret in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the secret to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t\t// +usage=Selects a key of a config map in the pod's namespace\n\t\t\tconfigMapKeyRef: {\n\t\t\t\t// +usage=The name of the config map in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the config map to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t}]\n\n\t// +usage=Number of CPU units for the service, like `0.5` (0.5 CPU core), `1` (1 CPU core)\n\tcpu?: string\n\n\t// +usage=Specifies the attributes of the memory resource required for the container.\n\tmemory?: string\n\n\t// +usage=Declare volumes and volumeMounts\n\tvolumes?: [...{\n\t\tname:      string\n\t\tmountPath: string\n\t\t// +usage=Specify volume type, options: \"pvc\",\"configMap\",\"secret\",\"emptyDir\"\n\t\ttype: \"pvc\" | \"configMap\" | \"secret\" | \"emptyDir\"\n\t\tif type == \"pvc\" {\n\t\t\tclaimName: string\n\t\t}\n\t\tif type == \"configMap\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tcmName:      string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"secret\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tsecretName:  string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"emptyDir\" {\n\t\t\tmedium: *\"\" | \"Memory\"\n\t\t}\n\t}]\n\n\t// +usage=Instructions for assessing whether the container is alive.\n\tlivenessProbe?: #HealthProbe\n\n\t// +usage=Instructions for assessing whether the container is in a suitable state to serve traffic.\n\treadinessProbe?: #HealthProbe\n}\n#HealthProbe: {\n\n\t// +usage=Instructions for assessing container health by executing a command. Either this attribute or the httpGet attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the httpGet attribute and the tcpSocket attribute.\n\texec?: {\n\t\t// +usage=A command to be executed inside the container to assess its health. Each space delimited token of the command is a separate array element. Commands exiting 0 are considered to be successful probes, whilst all other exit codes are considered failures.\n\t\tcommand: [...string]\n\t}\n\n\t// +usage=Instructions for assessing container health by executing an HTTP GET request. Either this attribute or the exec attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the tcpSocket attribute.\n\thttpGet?: {\n\t\t// +usage=The endpoint, relative to the port, to which the HTTP GET request should be directed.\n\t\tpath: string\n\t\t// +usage=The TCP socket within the container to which the HTTP GET request should be directed.\n\t\tport: int\n\t\thttpHeaders?: [...{\n\t\t\tname:  string\n\t\t\tvalue: string\n\t\t}]\n\t}\n\n\t// +usage=Instructions for assessing container health by probing a TCP socket. Either this attribute or the exec attribute or the httpGet attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the httpGet attribute.\n\ttcpSocket?: {\n\t\t// +usage=The TCP socket within the container that should be probed to assess container health.\n\t\tport: int\n\t}\n\n\t// +usage=Number of seconds after the container is started before the first probe is initiated.\n\tinitialDelaySeconds: *0 | int\n\n\t// +usage=How often, in seconds, to execute the probe.\n\tperiodSeconds: *10 | int\n\n\t// +usage=Number of seconds after which the probe times out.\n\ttimeoutSeconds: *1 | int\n\n\t// +usage=Minimum consecutive successes for the probe to be considered successful after having failed.\n\tsuccessThreshold: *1 | int\n\n\t// +usage=Number of consecutive failures required to determine the container is not alive (liveness probe) or not ready (readiness probe).\n\tfailureThreshold: *3 | int\n}\n"
        }
      },
      "status": {
        "customStatus": "status: {\n\tactive:    *0 | int\n\tfailed:    *0 | int\n\tsucceeded: *0 | int\n} & {\n\tif context.output.status.active != _|_ {\n\t\tactive: context.output.status.active\n\t}\n\tif context.output.status.failed != _|_ {\n\t\tfailed: context.output.status.failed\n\t}\n\tif context.output.status.succeeded != _|_ {\n\t\tsucceeded: context.output.status.succeeded\n\t}\n}\nmessage: \"Active/Failed/Succeeded:\\(status.active)/\\(status.failed)/\\(status.succeeded)\"",
        "healthPolicy": "succeeded: *0 | int\nif context.output.status.succeeded != _|_ {\n\tsucceeded: context.output.status.succeeded\n}\nisHealth: succeeded == context.output.spec.parallelism"
      },
      "workload": {
        "definition": {
          "apiVersion": "batch/v1",
          "kind": "Job"
        },
        "type": "jobs.batch"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Describes long-running, scalable, containerized services that have a stable network endpoint to receive external network traffic from customers."
      },
      "name": "webservice",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"strconv\"\n)\n\nmountsArray: {\n\tpvc: *[\n\t\tfor v in parameter.volumeMounts.pvc {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\tconfigMap: *[\n\t\t\tfor v in parameter.volumeMounts.configMap {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\tsecret: *[\n\t\tfor v in parameter.volumeMounts.secret {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\temptyDir: *[\n\t\t\tfor v in parameter.volumeMounts.emptyDir {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\thostPath: *[\n\t\t\tfor v in parameter.volumeMounts.hostPath {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n}\nvolumesArray: {\n\tpvc: *[\n\t\tfor v in parameter.volumeMounts.pvc {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tpersistentVolumeClaim: claimName: v.claimName\n\t\t\t}\n\t\t},\n\t] | []\n\n\tconfigMap: *[\n\t\t\tfor v in parameter.volumeMounts.configMap {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tconfigMap: {\n\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\tname:        v.cmName\n\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\titems: v.items\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t] | []\n\n\tsecret: *[\n\t\tfor v in parameter.volumeMounts.secret {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tsecret: {\n\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\tsecretName:  v.secretName\n\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\titems: v.items\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t] | []\n\n\temptyDir: *[\n\t\t\tfor v in parameter.volumeMounts.emptyDir {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\temptyDir: medium: v.medium\n\t\t\t}\n\t\t},\n\t] | []\n\n\thostPath: *[\n\t\t\tfor v in parameter.volumeMounts.hostPath {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\thostPath: path: v.path\n\t\t\t}\n\t\t},\n\t] | []\n}\noutput: {\n\tapiVersion: \"apps/v1\"\n\tkind:       \"Deployment\"\n\tspec: {\n\t\tselector: matchLabels: \"app.oam.dev/component\": context.name\n\n\t\ttemplate: {\n\t\t\tmetadata: {\n\t\t\t\tlabels: {\n\t\t\t\t\tif parameter.labels != _|_ {\n\t\t\t\t\t\tparameter.labels\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.addRevisionLabel {\n\t\t\t\t\t\t\"app.oam.dev/revision\": context.revision\n\t\t\t\t\t}\n\t\t\t\t\t\"app.oam.dev/name\":      context.appName\n\t\t\t\t\t\"app.oam.dev/component\": context.name\n\t\t\t\t}\n\t\t\t\tif parameter.annotations != _|_ {\n\t\t\t\t\tannotations: parameter.annotations\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tspec: {\n\t\t\t\tcontainers: [{\n\t\t\t\t\tname:  context.name\n\t\t\t\t\timage: parameter.image\n\t\t\t\t\tif parameter[\"port\"] != _|_ && parameter[\"ports\"] == _|_ {\n\t\t\t\t\t\tports: [{\n\t\t\t\t\t\t\tcontainerPort: parameter.port\n\t\t\t\t\t\t}]\n\t\t\t\t\t}\n\t\t\t\t\tif parameter[\"ports\"] != _|_ {\n\t\t\t\t\t\tports: [ for v in parameter.ports {\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcontainerPort: v.port\n\t\t\t\t\t\t\t\tprotocol:      v.protocol\n\t\t\t\t\t\t\t\tif v.name != _|_ {\n\t\t\t\t\t\t\t\t\tname: v.name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif v.name == _|_ {\n\t\t\t\t\t\t\t\t\tname: \"port-\" + strconv.FormatInt(v.port, 10)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}}]\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"imagePullPolicy\"] != _|_ {\n\t\t\t\t\t\timagePullPolicy: parameter.imagePullPolicy\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"cmd\"] != _|_ {\n\t\t\t\t\t\tcommand: parameter.cmd\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"env\"] != _|_ {\n\t\t\t\t\t\tenv: parameter.env\n\t\t\t\t\t}\n\n\t\t\t\t\tif context[\"config\"] != _|_ {\n\t\t\t\t\t\tenv: context.config\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"cpu\"] != _|_ {\n\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\tlimits: cpu:   parameter.cpu\n\t\t\t\t\t\t\trequests: cpu: parameter.cpu\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"memory\"] != _|_ {\n\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\tlimits: memory:   parameter.memory\n\t\t\t\t\t\t\trequests: memory: parameter.memory\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"volumes\"] != _|_ && parameter[\"volumeMounts\"] == _|_ {\n\t\t\t\t\t\tvolumeMounts: [ for v in parameter.volumes {\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmountPath: v.mountPath\n\t\t\t\t\t\t\t\tname:      v.name\n\t\t\t\t\t\t\t}}]\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"volumeMounts\"] != _|_ {\n\t\t\t\t\t\tvolumeMounts: mountsArray.pvc + mountsArray.configMap + mountsArray.secret + mountsArray.emptyDir + mountsArray.hostPath\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"livenessProbe\"] != _|_ {\n\t\t\t\t\t\tlivenessProbe: parameter.livenessProbe\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"readinessProbe\"] != _|_ {\n\t\t\t\t\t\treadinessProbe: parameter.readinessProbe\n\t\t\t\t\t}\n\n\t\t\t\t}]\n\n\t\t\t\tif parameter[\"hostAliases\"] != _|_ {\n\t\t\t\t\t// +patchKey=ip\n\t\t\t\t\thostAliases: parameter.hostAliases\n\t\t\t\t}\n\n\t\t\t\tif parameter[\"imagePullSecrets\"] != _|_ {\n\t\t\t\t\timagePullSecrets: [ for v in parameter.imagePullSecrets {\n\t\t\t\t\t\tname: v\n\t\t\t\t\t},\n\t\t\t\t\t]\n\t\t\t\t}\n\n\t\t\t\tif parameter[\"volumes\"] != _|_ && parameter[\"volumeMounts\"] == _|_ {\n\t\t\t\t\tvolumes: [ for v in parameter.volumes {\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: v.name\n\t\t\t\t\t\t\tif v.type == \"pvc\" {\n\t\t\t\t\t\t\t\tpersistentVolumeClaim: claimName: v.claimName\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"configMap\" {\n\t\t\t\t\t\t\t\tconfigMap: {\n\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\tname:        v.cmName\n\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"secret\" {\n\t\t\t\t\t\t\t\tsecret: {\n\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\tsecretName:  v.secretName\n\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"emptyDir\" {\n\t\t\t\t\t\t\t\temptyDir: medium: v.medium\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t\t}\n\n\t\t\t\tif parameter[\"volumeMounts\"] != _|_ {\n\t\t\t\t\tvolumes: volumesArray.pvc + volumesArray.configMap + volumesArray.secret + volumesArray.emptyDir + volumesArray.hostPath\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nexposePorts: [\n\tfor v in parameter.ports if v.expose == true {\n\t\tport:       v.port\n\t\ttargetPort: v.port\n\t\tif v.name != _|_ {\n\t\t\tname: v.name\n\t\t}\n\t\tif v.name == _|_ {\n\t\t\tname: \"port-\" + strconv.FormatInt(v.port, 10)\n\t\t}\n\t},\n]\noutputs: {\n\tif len(exposePorts) != 0 {\n\t\twebserviceExpose: {\n\t\t\tapiVersion: \"v1\"\n\t\t\tkind:       \"Service\"\n\t\t\tmetadata: name: context.name\n\t\t\tspec: {\n\t\t\t\tselector: \"app.oam.dev/component\": context.name\n\t\t\t\tports: exposePorts\n\t\t\t\ttype:  parameter.exposeType\n\t\t\t}\n\t\t}\n\t}\n}\nparameter: {\n\t// +usage=Specify the labels in the workload\n\tlabels?: [string]: string\n\n\t// +usage=Specify the annotations in the workload\n\tannotations?: [string]: string\n\n\t// +usage=Which image would you like to use for your service\n\t// +short=i\n\timage: string\n\n\t// +usage=Specify image pull policy for your service\n\timagePullPolicy?: \"Always\" | \"Never\" | \"IfNotPresent\"\n\n\t// +usage=Specify image pull secrets for your service\n\timagePullSecrets?: [...string]\n\n\t// +ignore\n\t// +usage=Deprecated field, please use ports instead\n\t// +short=p\n\tport?: int\n\n\t// +usage=Which ports do you want customer traffic sent to, defaults to 80\n\tports?: [...{\n\t\t// +usage=Number of port to expose on the pod's IP address\n\t\tport: int\n\t\t// +usage=Name of the port\n\t\tname?: string\n\t\t// +usage=Protocol for port. Must be UDP, TCP, or SCTP\n\t\tprotocol: *\"TCP\" | \"UDP\" | \"SCTP\"\n\t\t// +usage=Specify if the port should be exposed\n\t\texpose: *false | bool\n\t}]\n\n\t// +ignore\n\t// +usage=Specify what kind of Service you want. options: \"ClusterIP\", \"NodePort\", \"LoadBalancer\", \"ExternalName\"\n\texposeType: *\"ClusterIP\" | \"NodePort\" | \"LoadBalancer\" | \"ExternalName\"\n\n\t// +ignore\n\t// +usage=If addRevisionLabel is true, the revision label will be added to the underlying pods\n\taddRevisionLabel: *false | bool\n\n\t// +usage=Commands to run in the container\n\tcmd?: [...string]\n\n\t// +usage=Define arguments by using environment variables\n\tenv?: [...{\n\t\t// +usage=Environment variable name\n\t\tname: string\n\t\t// +usage=The value of the environment variable\n\t\tvalue?: string\n\t\t// +usage=Specifies a source the value of this var should come from\n\t\tvalueFrom?: {\n\t\t\t// +usage=Selects a key of a secret in the pod's namespace\n\t\t\tsecretKeyRef?: {\n\t\t\t\t// +usage=The name of the secret in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the secret to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t\t// +usage=Selects a key of a config map in the pod's namespace\n\t\t\tconfigMapKeyRef?: {\n\t\t\t\t// +usage=The name of the config map in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the config map to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t}]\n\n\t// +usage=Number of CPU units for the service, like `0.5` (0.5 CPU core), `1` (1 CPU core)\n\tcpu?: string\n\n\t// +usage=Specifies the attributes of the memory resource required for the container.\n\tmemory?: string\n\n\tvolumeMounts?: {\n\t\t// +usage=Mount PVC type volume\n\t\tpvc?: [...{\n\t\t\tname:      string\n\t\t\tmountPath: string\n\t\t\t// +usage=The name of the PVC\n\t\t\tclaimName: string\n\t\t}]\n\t\t// +usage=Mount ConfigMap type volume\n\t\tconfigMap?: [...{\n\t\t\tname:        string\n\t\t\tmountPath:   string\n\t\t\tdefaultMode: *420 | int\n\t\t\tcmName:      string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}]\n\t\t// +usage=Mount Secret type volume\n\t\tsecret?: [...{\n\t\t\tname:        string\n\t\t\tmountPath:   string\n\t\t\tdefaultMode: *420 | int\n\t\t\tsecretName:  string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}]\n\t\t// +usage=Mount EmptyDir type volume\n\t\temptyDir?: [...{\n\t\t\tname:      string\n\t\t\tmountPath: string\n\t\t\tmedium:    *\"\" | \"Memory\"\n\t\t}]\n\t\t// +usage=Mount HostPath type volume\n\t\thostPath?: [...{\n\t\t\tname:      string\n\t\t\tmountPath: string\n\t\t\tpath:      string\n\t\t}]\n\t}\n\n\t// +usage=Deprecated field, use volumeMounts instead.\n\tvolumes?: [...{\n\t\tname:      string\n\t\tmountPath: string\n\t\t// +usage=Specify volume type, options: \"pvc\",\"configMap\",\"secret\",\"emptyDir\"\n\t\ttype: \"pvc\" | \"configMap\" | \"secret\" | \"emptyDir\"\n\t\tif type == \"pvc\" {\n\t\t\tclaimName: string\n\t\t}\n\t\tif type == \"configMap\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tcmName:      string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"secret\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tsecretName:  string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"emptyDir\" {\n\t\t\tmedium: *\"\" | \"Memory\"\n\t\t}\n\t}]\n\n\t// +usage=Instructions for assessing whether the container is alive.\n\tlivenessProbe?: #HealthProbe\n\n\t// +usage=Instructions for assessing whether the container is in a suitable state to serve traffic.\n\treadinessProbe?: #HealthProbe\n\n\t// +usage=Specify the hostAliases to add\n\thostAliases?: [...{\n\t\tip: string\n\t\thostnames: [...string]\n\t}]\n}\n#HealthProbe: {\n\n\t// +usage=Instructions for assessing container health by executing a command. Either this attribute or the httpGet attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the httpGet attribute and the tcpSocket attribute.\n\texec?: {\n\t\t// +usage=A command to be executed inside the container to assess its health. Each space delimited token of the command is a separate array element. Commands exiting 0 are considered to be successful probes, whilst all other exit codes are considered failures.\n\t\tcommand: [...string]\n\t}\n\n\t// +usage=Instructions for assessing container health by executing an HTTP GET request. Either this attribute or the exec attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the tcpSocket attribute.\n\thttpGet?: {\n\t\t// +usage=The endpoint, relative to the port, to which the HTTP GET request should be directed.\n\t\tpath: string\n\t\t// +usage=The TCP socket within the container to which the HTTP GET request should be directed.\n\t\tport:    int\n\t\thost?:   string\n\t\tscheme?: *\"HTTP\" | string\n\t\thttpHeaders?: [...{\n\t\t\tname:  string\n\t\t\tvalue: string\n\t\t}]\n\t}\n\n\t// +usage=Instructions for assessing container health by probing a TCP socket. Either this attribute or the exec attribute or the httpGet attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the httpGet attribute.\n\ttcpSocket?: {\n\t\t// +usage=The TCP socket within the container that should be probed to assess container health.\n\t\tport: int\n\t}\n\n\t// +usage=Number of seconds after the container is started before the first probe is initiated.\n\tinitialDelaySeconds: *0 | int\n\n\t// +usage=How often, in seconds, to execute the probe.\n\tperiodSeconds: *10 | int\n\n\t// +usage=Number of seconds after which the probe times out.\n\ttimeoutSeconds: *1 | int\n\n\t// +usage=Minimum consecutive successes for the probe to be considered successful after having failed.\n\tsuccessThreshold: *1 | int\n\n\t// +usage=Number of consecutive failures required to determine the container is not alive (liveness probe) or not ready (readiness probe).\n\tfailureThreshold: *3 | int\n}\n"
        }
      },
      "status": {
        "customStatus": "ready: {\n\treadyReplicas: *0 | int\n} & {\n\tif context.output.status.readyReplicas != _|_ {\n\t\treadyReplicas: context.output.status.readyReplicas\n\t}\n}\nmessage: \"Ready:\\(ready.readyReplicas)/\\(context.output.spec.replicas)\"",
        "healthPolicy": "ready: {\n\tupdatedReplicas:    *0 | int\n\treadyReplicas:      *0 | int\n\treplicas:           *0 | int\n\tobservedGeneration: *0 | int\n} & {\n\tif context.output.status.updatedReplicas != _|_ {\n\t\tupdatedReplicas: context.output.status.updatedReplicas\n\t}\n\tif context.output.status.readyReplicas != _|_ {\n\t\treadyReplicas: context.output.status.readyReplicas\n\t}\n\tif context.output.status.replicas != _|_ {\n\t\treplicas: context.output.status.replicas\n\t}\n\tif context.output.status.observedGeneration != _|_ {\n\t\tobservedGeneration: context.output.status.observedGeneration\n\t}\n}\nisHealth: (context.output.spec.replicas == ready.readyReplicas) && (context.output.spec.replicas == ready.updatedReplicas) && (context.output.spec.replicas == ready.replicas) && (ready.observedGeneration == context.output.metadata.generation || ready.observedGeneration > context.output.metadata.generation)"
      },
      "workload": {
        "definition": {
          "apiVersion": "apps/v1",
          "kind": "Deployment"
        },
        "type": "deployments.apps"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ComponentDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Describes long-running, scalable, containerized services that running at backend. They do NOT have network endpoint to receive external network traffic."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "worker",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "mountsArray: {\n\tpvc: *[\n\t\tfor v in parameter.volumeMounts.pvc {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\tconfigMap: *[\n\t\t\tfor v in parameter.volumeMounts.configMap {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\tsecret: *[\n\t\tfor v in parameter.volumeMounts.secret {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\temptyDir: *[\n\t\t\tfor v in parameter.volumeMounts.emptyDir {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n\n\thostPath: *[\n\t\t\tfor v in parameter.volumeMounts.hostPath {\n\t\t\t{\n\t\t\t\tmountPath: v.mountPath\n\t\t\t\tname:      v.name\n\t\t\t}\n\t\t},\n\t] | []\n}\nvolumesArray: {\n\tpvc: *[\n\t\tfor v in parameter.volumeMounts.pvc {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tpersistentVolumeClaim: claimName: v.claimName\n\t\t\t}\n\t\t},\n\t] | []\n\n\tconfigMap: *[\n\t\t\tfor v in parameter.volumeMounts.configMap {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tconfigMap: {\n\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\tname:        v.cmName\n\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\titems: v.items\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t] | []\n\n\tsecret: *[\n\t\tfor v in parameter.volumeMounts.secret {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tsecret: {\n\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\tsecretName:  v.secretName\n\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\titems: v.items\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t] | []\n\n\temptyDir: *[\n\t\t\tfor v in parameter.volumeMounts.emptyDir {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\temptyDir: medium: v.medium\n\t\t\t}\n\t\t},\n\t] | []\n\n\thostPath: *[\n\t\t\tfor v in parameter.volumeMounts.hostPath {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\thostPath: path: v.path\n\t\t\t}\n\t\t},\n\t] | []\n}\noutput: {\n\tapiVersion: \"apps/v1\"\n\tkind:       \"Deployment\"\n\tspec: {\n\t\tselector: matchLabels: \"app.oam.dev/component\": context.name\n\n\t\ttemplate: {\n\t\t\tmetadata: labels: {\n\t\t\t\t\"app.oam.dev/name\":      context.appName\n\t\t\t\t\"app.oam.dev/component\": context.name\n\t\t\t}\n\n\t\t\tspec: {\n\t\t\t\tcontainers: [{\n\t\t\t\t\tname:  context.name\n\t\t\t\t\timage: parameter.image\n\n\t\t\t\t\tif parameter[\"imagePullPolicy\"] != _|_ {\n\t\t\t\t\t\timagePullPolicy: parameter.imagePullPolicy\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"cmd\"] != _|_ {\n\t\t\t\t\t\tcommand: parameter.cmd\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"env\"] != _|_ {\n\t\t\t\t\t\tenv: parameter.env\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"cpu\"] != _|_ {\n\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\tlimits: cpu:   parameter.cpu\n\t\t\t\t\t\t\trequests: cpu: parameter.cpu\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"memory\"] != _|_ {\n\t\t\t\t\t\tresources: {\n\t\t\t\t\t\t\tlimits: memory:   parameter.memory\n\t\t\t\t\t\t\trequests: memory: parameter.memory\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"volumes\"] != _|_ && parameter[\"volumeMounts\"] == _|_ {\n\t\t\t\t\t\tvolumeMounts: [ for v in parameter.volumes {\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmountPath: v.mountPath\n\t\t\t\t\t\t\t\tname:      v.name\n\t\t\t\t\t\t\t}}]\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"volumeMounts\"] != _|_ {\n\t\t\t\t\t\tvolumeMounts: mountsArray.pvc + mountsArray.configMap + mountsArray.secret + mountsArray.emptyDir + mountsArray.hostPath\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"livenessProbe\"] != _|_ {\n\t\t\t\t\t\tlivenessProbe: parameter.livenessProbe\n\t\t\t\t\t}\n\n\t\t\t\t\tif parameter[\"readinessProbe\"] != _|_ {\n\t\t\t\t\t\treadinessProbe: parameter.readinessProbe\n\t\t\t\t\t}\n\n\t\t\t\t}]\n\n\t\t\t\tif parameter[\"imagePullSecrets\"] != _|_ {\n\t\t\t\t\timagePullSecrets: [ for v in parameter.imagePullSecrets {\n\t\t\t\t\t\tname: v\n\t\t\t\t\t},\n\t\t\t\t\t]\n\t\t\t\t}\n\n\t\t\t\tif parameter[\"volumes\"] != _|_ && parameter[\"volumeMounts\"] == _|_ {\n\t\t\t\t\tvolumes: [ for v in parameter.volumes {\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tname: v.name\n\t\t\t\t\t\t\tif v.type == \"pvc\" {\n\t\t\t\t\t\t\t\tpersistentVolumeClaim: claimName: v.claimName\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"configMap\" {\n\t\t\t\t\t\t\t\tconfigMap: {\n\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\tname:        v.cmName\n\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"secret\" {\n\t\t\t\t\t\t\t\tsecret: {\n\t\t\t\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\t\t\t\tsecretName:  v.secretName\n\t\t\t\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif v.type == \"emptyDir\" {\n\t\t\t\t\t\t\t\temptyDir: medium: v.medium\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t\tif parameter[\"volumeMounts\"] != _|_ {\n\t\t\t\t\tvolumes: volumesArray.pvc + volumesArray.configMap + volumesArray.secret + volumesArray.emptyDir + volumesArray.hostPath\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nparameter: {\n\t// +usage=Which image would you like to use for your service\n\t// +short=i\n\timage: string\n\n\t// +usage=Specify image pull policy for your service\n\timagePullPolicy?: string\n\n\t// +usage=Specify image pull secrets for your service\n\timagePullSecrets?: [...string]\n\n\t// +usage=Commands to run in the container\n\tcmd?: [...string]\n\n\t// +usage=Define arguments by using environment variables\n\tenv?: [...{\n\t\t// +usage=Environment variable name\n\t\tname: string\n\t\t// +usage=The value of the environment variable\n\t\tvalue?: string\n\t\t// +usage=Specifies a source the value of this var should come from\n\t\tvalueFrom?: {\n\t\t\t// +usage=Selects a key of a secret in the pod's namespace\n\t\t\tsecretKeyRef?: {\n\t\t\t\t// +usage=The name of the secret in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the secret to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t\t// +usage=Selects a key of a config map in the pod's namespace\n\t\t\tconfigMapKeyRef?: {\n\t\t\t\t// +usage=The name of the config map in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the config map to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t}]\n\n\t// +usage=Number of CPU units for the service, like `0.5` (0.5 CPU core), `1` (1 CPU core)\n\tcpu?: string\n\n\t// +usage=Specifies the attributes of the memory resource required for the container.\n\tmemory?: string\n\n\tvolumeMounts?: {\n\t\t// +usage=Mount PVC type volume\n\t\tpvc?: [...{\n\t\t\tname:      string\n\t\t\tmountPath: string\n\t\t\t// +usage=The name of the PVC\n\t\t\tclaimName: string\n\t\t}]\n\t\t// +usage=Mount ConfigMap type volume\n\t\tconfigMap?: [...{\n\t\t\tname:        string\n\t\t\tmountPath:   string\n\t\t\tdefaultMode: *420 | int\n\t\t\tcmName:      string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}]\n\t\t// +usage=Mount Secret type volume\n\t\tsecret?: [...{\n\t\t\tname:        string\n\t\t\tmountPath:   string\n\t\t\tdefaultMode: *420 | int\n\t\t\tsecretName:  string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}]\n\t\t// +usage=Mount EmptyDir type volume\n\t\temptyDir?: [...{\n\t\t\tname:      string\n\t\t\tmountPath: string\n\t\t\tmedium:    *\"\" | \"Memory\"\n\t\t}]\n\t\t// +usage=Mount HostPath type volume\n\t\thostPath?: [...{\n\t\t\tname:      string\n\t\t\tmountPath: string\n\t\t\tpath:      string\n\t\t}]\n\t}\n\n\t// +usage=Deprecated field, use volumeMounts instead.\n\tvolumes?: [...{\n\t\tname:      string\n\t\tmountPath: string\n\t\t// +usage=Specify volume type, options: \"pvc\",\"configMap\",\"secret\",\"emptyDir\"\n\t\ttype: \"pvc\" | \"configMap\" | \"secret\" | \"emptyDir\"\n\t\tif type == \"pvc\" {\n\t\t\tclaimName: string\n\t\t}\n\t\tif type == \"configMap\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tcmName:      string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"secret\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tsecretName:  string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"emptyDir\" {\n\t\t\tmedium: *\"\" | \"Memory\"\n\t\t}\n\t}]\n\n\t// +usage=Instructions for assessing whether the container is alive.\n\tlivenessProbe?: #HealthProbe\n\n\t// +usage=Instructions for assessing whether the container is in a suitable state to serve traffic.\n\treadinessProbe?: #HealthProbe\n}\n#HealthProbe: {\n\n\t// +usage=Instructions for assessing container health by executing a command. Either this attribute or the httpGet attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the httpGet attribute and the tcpSocket attribute.\n\texec?: {\n\t\t// +usage=A command to be executed inside the container to assess its health. Each space delimited token of the command is a separate array element. Commands exiting 0 are considered to be successful probes, whilst all other exit codes are considered failures.\n\t\tcommand: [...string]\n\t}\n\n\t// +usage=Instructions for assessing container health by executing an HTTP GET request. Either this attribute or the exec attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the tcpSocket attribute.\n\thttpGet?: {\n\t\t// +usage=The endpoint, relative to the port, to which the HTTP GET request should be directed.\n\t\tpath: string\n\t\t// +usage=The TCP socket within the container to which the HTTP GET request should be directed.\n\t\tport: int\n\t\thttpHeaders?: [...{\n\t\t\tname:  string\n\t\t\tvalue: string\n\t\t}]\n\t}\n\n\t// +usage=Instructions for assessing container health by probing a TCP socket. Either this attribute or the exec attribute or the httpGet attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the httpGet attribute.\n\ttcpSocket?: {\n\t\t// +usage=The TCP socket within the container that should be probed to assess container health.\n\t\tport: int\n\t}\n\n\t// +usage=Number of seconds after the container is started before the first probe is initiated.\n\tinitialDelaySeconds: *0 | int\n\n\t// +usage=How often, in seconds, to execute the probe.\n\tperiodSeconds: *10 | int\n\n\t// +usage=Number of seconds after which the probe times out.\n\ttimeoutSeconds: *1 | int\n\n\t// +usage=Minimum consecutive successes for the probe to be considered successful after having failed.\n\tsuccessThreshold: *1 | int\n\n\t// +usage=Number of consecutive failures required to determine the container is not alive (liveness probe) or not ready (readiness probe).\n\tfailureThreshold: *3 | int\n}\n"
        }
      },
      "status": {
        "customStatus": "ready: {\n\treadyReplicas: *0 | int\n} & {\n\tif context.output.status.readyReplicas != _|_ {\n\t\treadyReplicas: context.output.status.readyReplicas\n\t}\n}\nmessage: \"Ready:\\(ready.readyReplicas)/\\(context.output.spec.replicas)\"",
        "healthPolicy": "ready: {\n\tupdatedReplicas:    *0 | int\n\treadyReplicas:      *0 | int\n\treplicas:           *0 | int\n\tobservedGeneration: *0 | int\n} & {\n\tif context.output.status.updatedReplicas != _|_ {\n\t\tupdatedReplicas: context.output.status.updatedReplicas\n\t}\n\tif context.output.status.readyReplicas != _|_ {\n\t\treadyReplicas: context.output.status.readyReplicas\n\t}\n\tif context.output.status.replicas != _|_ {\n\t\treplicas: context.output.status.replicas\n\t}\n\tif context.output.status.observedGeneration != _|_ {\n\t\tobservedGeneration: context.output.status.observedGeneration\n\t}\n}\nisHealth: (context.output.spec.replicas == ready.readyReplicas) && (context.output.spec.replicas == ready.updatedReplicas) && (context.output.spec.replicas == ready.replicas) && (ready.observedGeneration == context.output.metadata.generation || ready.observedGeneration > context.output.metadata.generation)"
      },
      "workload": {
        "definition": {
          "apiVersion": "apps/v1",
          "kind": "Deployment"
        },
        "type": "deployments.apps"
      }
    }
  },
  {
    "apiVersion": "admissionregistration.k8s.io/v1",
    "kind": "MutatingWebhookConfiguration",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission",
      "namespace": "default"
    },
    "webhooks": [
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/mutating-core-oam-dev-v1beta1-approllout"
          }
        },
        "failurePolicy": "Ignore",
        "name": "mutating.core.oam.dev.v1beta1.approllouts",
        "sideEffects": "None",
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1beta1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "approllouts"
            ],
            "scope": "Namespaced"
          }
        ],
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "timeoutSeconds": 5
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/mutate-standard-oam-dev-v1alpha1-podspecworkload"
          }
        },
        "failurePolicy": "Ignore",
        "name": "mcontainerized.kb.io",
        "sideEffects": "None",
        "admissionReviewVersions": [
          "v1beta1"
        ],
        "rules": [
          {
            "apiGroups": [
              "standard.oam.dev"
            ],
            "apiVersions": [
              "v1alpha1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "podspecworkloads"
            ]
          }
        ]
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/mutating-core-oam-dev-v1beta1-applications"
          }
        },
        "failurePolicy": "Ignore",
        "name": "mutating.core.oam.dev.v1beta1.applications",
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "sideEffects": "None",
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1beta1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "applications"
            ]
          }
        ]
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/mutating-core-oam-dev-v1beta1-componentdefinitions"
          }
        },
        "failurePolicy": "Ignore",
        "name": "mutating.core.oam-dev.v1beta1.componentdefinitions",
        "sideEffects": "None",
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1beta1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "componentdefinitions"
            ]
          }
        ]
      }
    ]
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "PolicyDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Determining the destination where components should be deployed to, and support override configuration"
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "envbinding",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "#PatchParams: {\n\t// +usage=Specify the name of the patch component, if empty, all components will be merged\n\tname?: string\n\t// +usage=Specify the type of the patch component.\n\ttype?: string\n\tproperties?: {...}\n\ttraits?: [...{\n\t\ttype: string\n\t\tproperties?: {...}\n\t\t// +usage=Specify if the trait shoued be remove, default false\n\t\tdisable: *false | bool\n\t}]\n}\nparameter: envs: [...{\n\tname: string\n\tplacement?: {\n\t\tclusterSelector?: {\n\t\t\t// +usage=Specify cluster name, defualt local\n\t\t\tname: *\"local\" | string\n\t\t\tlabels?: [string]: string\n\t\t}\n\t\tnamespaceSelector?: {\n\t\t\t// +usage=Specify namespace name.\n\t\t\tname?: string\n\t\t\tlabels?: [string]: string\n\t\t}\n\t}\n\tselector?: components: [...string]\n\tpatch?: components: [...#PatchParams]\n}]\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "PolicyDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Apply periodical health checking to the application."
      },
      "name": "health",
      "namespace": "default"
    },
    "spec": {
      "manageHealthCheck": true,
      "schematic": {
        "cue": {
          "template": "output: {\n\tapiVersion: \"core.oam.dev/v1alpha2\"\n\tkind:       \"HealthScope\"\n\tspec: {\n\t\t\"probe-timeout\":  parameter.probeTimeout\n\t\t\"probe-interval\": parameter.probeInterval\n\t\tappReferences: [{\n\t\t\tappName: context.appName\n\t\t}]\n\t\tworkloadRefs: []\n\t\tmanageHealthCheck: true\n\t}\n}\nparameter: {\n\t// +usage=Specify health checking timeout(seconds), default 10s\n\tprobeTimeout: *10 | int\n\t// +usage=Specify health checking interval(seconds), default 30s\n\tprobeInterval: *30 | int\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "PolicyDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Override configuration when deploying resources"
      },
      "name": "override",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "#PatchParams: {\n\t// +usage=Specify the name of the patch component, if empty, all components will be merged\n\tname?: string\n\t// +usage=Specify the type of the patch component.\n\ttype?: string\n\tproperties?: {...}\n\ttraits?: [...{\n\t\ttype: string\n\t\tproperties?: {...}\n\t\t// +usage=Specify if the trait shoued be remove, default false\n\t\tdisable: *false | bool\n\t}]\n}\nparameter: {\n\t// +usage=Specify the overridden component configuration.\n\tcomponents: [...#PatchParams]\n\t// +usage=Specify a list of component names to use, if empty, all components will be selected.\n\tselector?: [...string]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "PolicyDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Determining the destination where components should be deployed to."
      },
      "name": "topology",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "parameter: {\n\t// +usage=Specify the names of the clusters to select.\n\tcluster?: [...string]\n\t// +usage=Specify the label selector for clusters\n\tclusterLabelSelector?: [string]: string\n\t// +usage=Deprecated: Use clusterLabelSelector instead.\n\tclusterSelector?: [string]: string\n\t// +usage=Specify the target namespace to deploy in the selected clusters, default inherit the original namespace.\n\tnamespace?: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "ScopeDefinition",
    "metadata": {
      "name": "healthscopes.core.oam.dev",
      "namespace": "default"
    },
    "spec": {
      "workloadRefsPath": "spec.workloadRefs",
      "allowComponentOverlap": true,
      "definitionRef": {
        "name": "healthscopes.core.oam.dev"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "affinity specify affinity and tolerationon K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "affinity",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: {\n\tif parameter.podAffinity != _|_ {\n\t\taffinity: podAffinity: {\n\t\t\tif parameter.podAffinity.required != _|_ {\n\t\t\t\trequiredDuringSchedulingIgnoredDuringExecution: [\n\t\t\t\t\tfor k in parameter.podAffinity.required {\n\t\t\t\t\t\tif k.labelSelector != _|_ {\n\t\t\t\t\t\t\tlabelSelector: k.labelSelector\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif k.namespace != _|_ {\n\t\t\t\t\t\t\tnamespace: k.namespace\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttopologyKey: k.topologyKey\n\t\t\t\t\t\tif k.namespaceSelector != _|_ {\n\t\t\t\t\t\t\tnamespaceSelector: k.namespaceSelector\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t}\n\t\t\tif parameter.podAffinity.preferred != _|_ {\n\t\t\t\tpreferredDuringSchedulingIgnoredDuringExecution: [\n\t\t\t\t\tfor k in parameter.podAffinity.preferred {\n\t\t\t\t\t\tweight:          k.weight\n\t\t\t\t\t\tpodAffinityTerm: k.podAffinityTerm\n\t\t\t\t\t}]\n\t\t\t}\n\t\t}\n\t}\n\tif parameter.podAntiAffinity != _|_ {\n\t\taffinity: podAntiAffinity: {\n\t\t\tif parameter.podAntiAffinity.required != _|_ {\n\t\t\t\trequiredDuringSchedulingIgnoredDuringExecution: [\n\t\t\t\t\tfor k in parameter.podAntiAffinity.required {\n\t\t\t\t\t\tif k.labelSelector != _|_ {\n\t\t\t\t\t\t\tlabelSelector: k.labelSelector\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif k.namespace != _|_ {\n\t\t\t\t\t\t\tnamespace: k.namespace\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttopologyKey: k.topologyKey\n\t\t\t\t\t\tif k.namespaceSelector != _|_ {\n\t\t\t\t\t\t\tnamespaceSelector: k.namespaceSelector\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t}\n\t\t\tif parameter.podAntiAffinity.preferred != _|_ {\n\t\t\t\tpreferredDuringSchedulingIgnoredDuringExecution: [\n\t\t\t\t\tfor k in parameter.podAntiAffinity.preferred {\n\t\t\t\t\t\tweight:          k.weight\n\t\t\t\t\t\tpodAffinityTerm: k.podAffinityTerm\n\t\t\t\t\t}]\n\t\t\t}\n\t\t}\n\t}\n\tif parameter.nodeAffinity != _|_ {\n\t\taffinity: nodeAffinity: {\n\t\t\tif parameter.nodeAffinity.required != _|_ {\n\t\t\t\trequiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: [\n\t\t\t\t\tfor k in parameter.nodeAffinity.required.nodeSelectorTerms {\n\t\t\t\t\t\tif k.matchExpressions != _|_ {\n\t\t\t\t\t\t\tmatchExpressions: k.matchExpressions\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif k.matchFields != _|_ {\n\t\t\t\t\t\t\tmatchFields: k.matchFields\n\t\t\t\t\t\t}\n\t\t\t\t\t}]\n\t\t\t}\n\t\t\tif parameter.nodeAffinity.preferred != _|_ {\n\t\t\t\tpreferredDuringSchedulingIgnoredDuringExecution: [\n\t\t\t\t\tfor k in parameter.nodeAffinity.preferred {\n\t\t\t\t\t\tweight:     k.weight\n\t\t\t\t\t\tpreference: k.preference\n\t\t\t\t\t}]\n\t\t\t}\n\t\t}\n\t}\n\tif parameter.tolerations != _|_ {\n\t\ttolerations: [\n\t\t\tfor k in parameter.tolerations {\n\t\t\t\tif k.key != _|_ {\n\t\t\t\t\tkey: k.key\n\t\t\t\t}\n\t\t\t\tif k.effect != _|_ {\n\t\t\t\t\teffect: k.effect\n\t\t\t\t}\n\t\t\t\tif k.value != _|_ {\n\t\t\t\t\tvalue: k.value\n\t\t\t\t}\n\t\t\t\toperator: k.operator\n\t\t\t\tif k.tolerationSeconds != _|_ {\n\t\t\t\t\ttolerationSeconds: k.tolerationSeconds\n\t\t\t\t}\n\t\t\t}]\n\t}\n}\n#labelSelector: {\n\tmatchLabels?: [string]: string\n\tmatchExpressions?: [...{\n\t\tkey:      string\n\t\toperator: *\"In\" | \"NotIn\" | \"Exists\" | \"DoesNotExist\"\n\t\tvalues?: [...string]\n\t}]\n}\n#podAffinityTerm: {\n\tlabelSelector?: #labelSelector\n\tnamespaces?: [...string]\n\ttopologyKey:        string\n\tnamespaceSelector?: #labelSelector\n}\n#nodeSelecor: {\n\tkey:      string\n\toperator: *\"In\" | \"NotIn\" | \"Exists\" | \"DoesNotExist\" | \"Gt\" | \"Lt\"\n\tvalues?: [...string]\n}\n#nodeSelectorTerm: {\n\tmatchExpressions?: [...#nodeSelecor]\n\tmatchFields?: [...#nodeSelecor]\n}\nparameter: {\n\t// +usage=Specify the pod affinity scheduling rules\n\tpodAffinity?: {\n\t\t// +usage=Specify the required during scheduling ignored during execution\n\t\trequired?: [...#podAffinityTerm]\n\t\t// +usage=Specify the preferred during scheduling ignored during execution\n\t\tpreferred?: [...{\n\t\t\t// +usage=Specify weight associated with matching the corresponding podAffinityTerm\n\t\t\tweight: int & >=1 & <=100\n\t\t\t// +usage=Specify a set of pods\n\t\t\tpodAffinityTerm: #podAffinityTerm\n\t\t}]\n\t}\n\t// +usage=Specify the pod anti-affinity scheduling rules\n\tpodAntiAffinity?: {\n\t\t// +usage=Specify the required during scheduling ignored during execution\n\t\trequired?: [...#podAffinityTerm]\n\t\t// +usage=Specify the preferred during scheduling ignored during execution\n\t\tpreferred?: [...{\n\t\t\t// +usage=Specify weight associated with matching the corresponding podAffinityTerm\n\t\t\tweight: int & >=1 & <=100\n\t\t\t// +usage=Specify a set of pods\n\t\t\tpodAffinityTerm: #podAffinityTerm\n\t\t}]\n\t}\n\t// +usage=Specify the node affinity scheduling rules for the pod\n\tnodeAffinity?: {\n\t\t// +usage=Specify the required during scheduling ignored during execution\n\t\trequired?: {\n\t\t\t// +usage=Specify a list of node selector\n\t\t\tnodeSelectorTerms: [...#nodeSelectorTerm]\n\t\t}\n\t\t// +usage=Specify the preferred during scheduling ignored during execution\n\t\tpreferred?: [...{\n\t\t\t// +usage=Specify weight associated with matching the corresponding nodeSelector\n\t\t\tweight: int & >=1 & <=100\n\t\t\t// +usage=Specify a node selector\n\t\t\tpreference: #nodeSelectorTerm\n\t\t}]\n\t}\n\t// +usage=Specify tolerant taint\n\ttolerations?: [...{\n\t\tkey?:     string\n\t\toperator: *\"Equal\" | \"Exists\"\n\t\tvalue?:   string\n\t\teffect?:  \"NoSchedule\" | \"PreferNoSchedule\" | \"NoExecute\"\n\t\t// +usage=Specify the period of time the toleration\n\t\ttolerationSeconds?: int\n\t}]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add annotations on K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "annotations",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "// +patchStrategy=jsonMergePatch\npatch: {\n\tmetadata: annotations: {\n\t\tfor k, v in parameter {\n\t\t\t\"\\(k)\": v\n\t\t}\n\t}\n\tif context.output.spec != _|_ && context.output.spec.template != _|_ {\n\t\tspec: template: metadata: annotations: {\n\t\t\tfor k, v in parameter {\n\t\t\t\t\"\\(k)\": v\n\t\t\t}\n\t\t}\n\t}\n}\nparameter: [string]: string | null\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add command on K8s pod for your workload which follows the pod spec in path 'spec.template'"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "command",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "schematic": {
        "cue": {
          "template": "#PatchParams: {\n\t// +usage=Specify the name of the target container, if not set, use the component name\n\tcontainerName: *\"\" | string\n\t// +usage=Specify the command to use in the target container, if not set, it will not be changed\n\tcommand: *null | [...string]\n\t// +usage=Specify the args to use in the target container, if set, it will override existing args\n\targs: *null | [...string]\n\t// +usage=Specify the args to add in the target container, existing args will be kept, cannot be used with `args`\n\taddArgs: *null | [...string]\n\t// +usage=Specify the existing args to delete in the target container, cannot be used with `args`\n\tdelArgs: *null | [...string]\n}\nPatchContainer: {\n\t_params:         #PatchParams\n\tname:            _params.containerName\n\t_baseContainers: context.output.spec.template.spec.containers\n\t_matchContainers_: [ for _container_ in _baseContainers if _container_.name == name {_container_}]\n\t_baseContainer: *_|_ | {...}\n\tif len(_matchContainers_) == 0 {\n\t\terr: \"container \\(name) not found\"\n\t}\n\tif len(_matchContainers_) > 0 {\n\t\t_baseContainer: _matchContainers_[0]\n\t\tif _params.command != null {\n\t\t\t// +patchStrategy=replace\n\t\t\tcommand: _params.command\n\t\t}\n\t\tif (_params.addArgs != null || _params.delArgs != null) && _params.args != null {\n\t\t\terr: \"cannot set addArgs/delArgs and args at the same time\"\n\t\t}\n\t\t_delArgs: {...}\n\t\tif _params.delArgs != null {\n\t\t\t_delArgs: {for k in _params.delArgs {\"\\(k)\": \"\"}}\n\t\t}\n\t\tif _params.delArgs == null {\n\t\t\t_delArgs: {}\n\t\t}\n\t\t_args: [...string]\n\t\tif _params.args != null {\n\t\t\t_args: _params.args\n\t\t}\n\t\tif _params.args == null && _baseContainer.args != _|_ {\n\t\t\t_args: _baseContainer.args\n\t\t}\n\t\tif _params.args == null && _baseContainer.args == _|_ {\n\t\t\t_args: []\n\t\t}\n\t\t_argsMap: {for a in _args {\"\\(a)\": \"\"}}\n\t\t_addArgs: [...string]\n\t\tif _params.addArgs != null {\n\t\t\t_addArgs: _params.addArgs\n\t\t}\n\t\tif _params.addArgs == null {\n\t\t\t_addArgs: []\n\t\t}\n\n\t\t// +patchStrategy=replace\n\t\targs: [ for a in _args if _delArgs[a] == _|_ {a}] + [ for a in _addArgs if _delArgs[a] == _|_ && _argsMap[a] == _|_ {a}]\n\t}\n}\n// +patchStrategy=open\npatch: spec: template: spec: {\n\tif parameter.containers == _|_ {\n\t\t// +patchKey=name\n\t\tcontainers: [{\n\t\t\tPatchContainer & {_params: {\n\t\t\t\tif parameter.containerName == \"\" {\n\t\t\t\t\tcontainerName: context.name\n\t\t\t\t}\n\t\t\t\tif parameter.containerName != \"\" {\n\t\t\t\t\tcontainerName: parameter.containerName\n\t\t\t\t}\n\t\t\t\tcommand: parameter.command\n\t\t\t\targs:    parameter.args\n\t\t\t\taddArgs: parameter.addArgs\n\t\t\t\tdelArgs: parameter.delArgs\n\t\t\t}}\n\t\t}]\n\t}\n\tif parameter.containers != _|_ {\n\t\t// +patchKey=name\n\t\tcontainers: [ for c in parameter.containers {\n\t\t\tif c.containerName == \"\" {\n\t\t\t\terr: \"container name must be set for containers\"\n\t\t\t}\n\t\t\tif c.containerName != \"\" {\n\t\t\t\tPatchContainer & {_params: c}\n\t\t\t}\n\t\t}]\n\t}\n}\nparameter: *#PatchParams | close({\n\t// +usage=Specify the commands for multiple containers\n\tcontainers: [...#PatchParams]\n})\nerrs: [ for c in patch.spec.template.spec.containers if c.err != _|_ {c.err}]\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Create/Attach configmaps on K8s pod for your workload which follows the pod spec in path 'spec.template'. This definition is DEPRECATED, please specify configmap in 'storage' instead."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "configmap",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: {\n\tcontainers: [{\n\t\t// +patchKey=name\n\t\tvolumeMounts: [\n\t\t\tfor v in parameter.volumes {\n\t\t\t\t{\n\t\t\t\t\tname:      \"volume-\\(v.name)\"\n\t\t\t\t\tmountPath: v.mountPath\n\t\t\t\t\treadOnly:  v.readOnly\n\t\t\t\t}\n\t\t\t},\n\t\t]\n\t}, ...]\n\t// +patchKey=name\n\tvolumes: [\n\t\tfor v in parameter.volumes {\n\t\t\t{\n\t\t\t\tname: \"volume-\\(v.name)\"\n\t\t\t\tconfigMap: name: v.name\n\t\t\t}\n\t\t},\n\t]\n}\noutputs: {\n\tfor v in parameter.volumes {\n\t\tif v.data != _|_ {\n\t\t\t\"\\(v.name)\": {\n\t\t\t\tapiVersion: \"v1\"\n\t\t\t\tkind:       \"ConfigMap\"\n\t\t\t\tmetadata: name: v.name\n\t\t\t\tdata: v.data\n\t\t\t}\n\t\t}\n\t}\n}\nparameter: {\n\t// +usage=Specify mounted configmap names and their mount paths in the container\n\tvolumes: [...{\n\t\tname:      string\n\t\tmountPath: string\n\t\treadOnly:  *false | bool\n\t\tdata?: [string]: string\n\t}]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Set the image of the container."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "container-image",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "#PatchParams: {\n\t// +usage=Specify the name of the target container, if not set, use the component name\n\tcontainerName: *\"\" | string\n\t// +usage=Specify the image of the container\n\timage: string\n\t// +usage=Specify the image pull policy of the container\n\timagePullPolicy: *\"\" | \"IfNotPresent\" | \"Always\" | \"Never\"\n}\nPatchContainer: {\n\t_params:         #PatchParams\n\tname:            _params.containerName\n\t_baseContainers: context.output.spec.template.spec.containers\n\t_matchContainers_: [ for _container_ in _baseContainers if _container_.name == name {_container_}]\n\t_baseContainer: *_|_ | {...}\n\tif len(_matchContainers_) == 0 {\n\t\terr: \"container \\(name) not found\"\n\t}\n\tif len(_matchContainers_) > 0 {\n\t\t// +patchStrategy=retainKeys\n\t\timage: _params.image\n\n\t\tif _params.imagePullPolicy != \"\" {\n\t\t\t// +patchStrategy=retainKeys\n\t\t\timagePullPolicy: _params.imagePullPolicy\n\t\t}\n\t}\n}\npatch: spec: template: spec: {\n\tif parameter.containers == _|_ {\n\t\t// +patchKey=name\n\t\tcontainers: [{\n\t\t\tPatchContainer & {_params: {\n\t\t\t\tif parameter.containerName == \"\" {\n\t\t\t\t\tcontainerName: context.name\n\t\t\t\t}\n\t\t\t\tif parameter.containerName != \"\" {\n\t\t\t\t\tcontainerName: parameter.containerName\n\t\t\t\t}\n\t\t\t\timage:           parameter.image\n\t\t\t\timagePullPolicy: parameter.imagePullPolicy\n\t\t\t}}\n\t\t}]\n\t}\n\tif parameter.containers != _|_ {\n\t\t// +patchKey=name\n\t\tcontainers: [ for c in parameter.containers {\n\t\t\tif c.containerName == \"\" {\n\t\t\t\terr: \"containerName must be set for containers\"\n\t\t\t}\n\t\t\tif c.containerName != \"\" {\n\t\t\t\tPatchContainer & {_params: c}\n\t\t\t}\n\t\t}]\n\t}\n}\nparameter: *#PatchParams | close({\n\t// +usage=Specify the container image for multiple containers\n\tcontainers: [...#PatchParams]\n})\nerrs: [ for c in patch.spec.template.spec.containers if c.err != _|_ {c.err}]\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Automatically scale the component based on CPU usage."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "cpuscaler",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "deployments.apps"
      ],
      "schematic": {
        "cue": {
          "template": "outputs: cpuscaler: {\n\tapiVersion: \"autoscaling/v1\"\n\tkind:       \"HorizontalPodAutoscaler\"\n\tmetadata: name: context.name\n\tspec: {\n\t\tscaleTargetRef: {\n\t\t\tapiVersion: parameter.targetAPIVersion\n\t\t\tkind:       parameter.targetKind\n\t\t\tname:       context.name\n\t\t}\n\t\tminReplicas:                    parameter.min\n\t\tmaxReplicas:                    parameter.max\n\t\ttargetCPUUtilizationPercentage: parameter.cpuUtil\n\t}\n}\nparameter: {\n\t// +usage=Specify the minimal number of replicas to which the autoscaler can scale down\n\tmin: *1 | int\n\t// +usage=Specify the maximum number of of replicas to which the autoscaler can scale up\n\tmax: *10 | int\n\t// +usage=Specify the average CPU utilization, for example, 50 means the CPU usage is 50%\n\tcpuUtil: *50 | int\n\t// +usage=Specify the apiVersion of scale target\n\ttargetAPIVersion: *\"apps/v1\" | string\n\t// +usage=Specify the kind of scale target\n\ttargetKind: *\"Deployment\" | string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add env on K8s pod for your workload which follows the pod spec in path 'spec.template'"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "env",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "schematic": {
        "cue": {
          "template": "#PatchParams: {\n\t// +usage=Specify the name of the target container, if not set, use the component name\n\tcontainerName: *\"\" | string\n\t// +usage=Specify if replacing the whole environment settings for the container\n\treplace: *false | bool\n\t// +usage=Specify the  environment variables to merge, if key already existing, override its value\n\tenv: [string]: string\n\t// +usage=Specify which existing environment variables to unset\n\tunset: *[] | [...string]\n}\nPatchContainer: {\n\t_params: #PatchParams\n\tname:    _params.containerName\n\t_delKeys: {for k in _params.unset {\"\\(k)\": \"\"}}\n\t_baseContainers: context.output.spec.template.spec.containers\n\t_matchContainers_: [ for _container_ in _baseContainers if _container_.name == name {_container_}]\n\t_baseContainer: *_|_ | {...}\n\tif len(_matchContainers_) == 0 {\n\t\terr: \"container \\(name) not found\"\n\t}\n\tif len(_matchContainers_) > 0 {\n\t\t_baseContainer: _matchContainers_[0]\n\t\t_baseEnv:       _baseContainer.env\n\t\tif _baseEnv == _|_ {\n\t\t\t// +patchStrategy=replace\n\t\t\tenv: [ for k, v in _params.env if _delKeys[k] == _|_ {\n\t\t\t\tname:  k\n\t\t\t\tvalue: v\n\t\t\t}]\n\t\t}\n\t\tif _baseEnv != _|_ {\n\t\t\t_baseEnvMap: {for envVar in _baseEnv {\"\\(envVar.name)\": envVar}}\n\t\t\t// +patchStrategy=replace\n\t\t\tenv: [ for envVar in _baseEnv if _delKeys[envVar.name] == _|_ && !_params.replace {\n\t\t\t\tname: envVar.name\n\t\t\t\tif _params.env[envVar.name] != _|_ {\n\t\t\t\t\tvalue: _params.env[envVar.name]\n\t\t\t\t}\n\t\t\t\tif _params.env[envVar.name] == _|_ {\n\t\t\t\t\tif envVar.value != _|_ {\n\t\t\t\t\t\tvalue: envVar.value\n\t\t\t\t\t}\n\t\t\t\t\tif envVar.valueFrom != _|_ {\n\t\t\t\t\t\tvalueFrom: envVar.valueFrom\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}] + [ for k, v in _params.env if _delKeys[k] == _|_ && (_params.replace || _baseEnvMap[k] == _|_) {\n\t\t\t\tname:  k\n\t\t\t\tvalue: v\n\t\t\t}]\n\t\t}\n\t}\n}\npatch: spec: template: spec: {\n\tif parameter.containers == _|_ {\n\t\t// +patchKey=name\n\t\tcontainers: [{\n\t\t\tPatchContainer & {_params: {\n\t\t\t\tif parameter.containerName == \"\" {\n\t\t\t\t\tcontainerName: context.name\n\t\t\t\t}\n\t\t\t\tif parameter.containerName != \"\" {\n\t\t\t\t\tcontainerName: parameter.containerName\n\t\t\t\t}\n\t\t\t\treplace: parameter.replace\n\t\t\t\tenv:     parameter.env\n\t\t\t\tunset:   parameter.unset\n\t\t\t}}\n\t\t}]\n\t}\n\tif parameter.containers != _|_ {\n\t\t// +patchKey=name\n\t\tcontainers: [ for c in parameter.containers {\n\t\t\tif c.containerName == \"\" {\n\t\t\t\terr: \"containerName must be set for containers\"\n\t\t\t}\n\t\t\tif c.containerName != \"\" {\n\t\t\t\tPatchContainer & {_params: c}\n\t\t\t}\n\t\t}]\n\t}\n}\nparameter: *#PatchParams | close({\n\t// +usage=Specify the environment variables for multiple containers\n\tcontainers: [...#PatchParams]\n})\nerrs: [ for c in patch.spec.template.spec.containers if c.err != _|_ {c.err}]\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Expose port to enable web traffic for your component."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "expose",
      "namespace": "default"
    },
    "spec": {
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "outputs: service: {\n\tapiVersion: \"v1\"\n\tkind:       \"Service\"\n\tmetadata: name: context.name\n\tspec: {\n\t\tselector: \"app.oam.dev/component\": context.name\n\t\tports: [\n\t\t\tfor p in parameter.port {\n\t\t\t\tport:       p\n\t\t\t\ttargetPort: p\n\t\t\t},\n\t\t]\n\t\ttype: parameter.type\n\t}\n}\nparameter: {\n\t// +usage=Specify the exposion ports\n\tport: [...int]\n\t// +usage=Specify what kind of Service you want. options: \"ClusterIP\",\"NodePort\",\"LoadBalancer\",\"ExternalName\"\n\ttype: *\"ClusterIP\" | \"NodePort\" | \"LoadBalancer\" | \"ExternalName\"\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Enable public web traffic for the component, the ingress API matches K8s v1.20+."
      },
      "name": "gateway",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "// trait template can have multiple outputs in one trait\noutputs: service: {\n\tapiVersion: \"v1\"\n\tkind:       \"Service\"\n\tmetadata: name: context.name\n\tspec: {\n\t\tselector: \"app.oam.dev/component\": context.name\n\t\tports: [\n\t\t\tfor k, v in parameter.http {\n\t\t\t\tport:       v\n\t\t\t\ttargetPort: v\n\t\t\t},\n\t\t]\n\t}\n}\noutputs: ingress: {\n\tapiVersion: \"networking.k8s.io/v1\"\n\tkind:       \"Ingress\"\n\tmetadata: {\n\t\tname: context.name\n\t\tannotations: {\n\t\t\tif !parameter.classInSpec {\n\t\t\t\t\"kubernetes.io/ingress.class\": parameter.class\n\t\t\t}\n\t\t}\n\t}\n\tspec: {\n\t\tif parameter.classInSpec {\n\t\t\tingressClassName: parameter.class\n\t\t}\n\t\tif parameter.secretName != _|_ {\n\t\t\ttls: [{\n\t\t\t\thosts: [\n\t\t\t\t\tparameter.domain,\n\t\t\t\t]\n\t\t\t\tsecretName: parameter.secretName\n\t\t\t}]\n\t\t}\n\t\trules: [{\n\t\t\tif parameter.domain != _|_ {\n\t\t\t\thost: parameter.domain\n\t\t\t}\n\t\t\thttp: paths: [\n\t\t\t\tfor k, v in parameter.http {\n\t\t\t\t\tpath:     k\n\t\t\t\t\tpathType: \"ImplementationSpecific\"\n\t\t\t\t\tbackend: service: {\n\t\t\t\t\t\tname: context.name\n\t\t\t\t\t\tport: number: v\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t]\n\t\t}]\n\t}\n}\nparameter: {\n\t// +usage=Specify the domain you want to expose\n\tdomain?: string\n\n\t// +usage=Specify the mapping relationship between the http path and the workload port\n\thttp: [string]: int\n\n\t// +usage=Specify the class of ingress to use\n\tclass: *\"nginx\" | string\n\n\t// +usage=Set ingress class in '.spec.ingressClassName' instead of 'kubernetes.io/ingress.class' annotation.\n\tclassInSpec: *false | bool\n\n\t// +usage=Specify the secret name you want to quote.\n\tsecretName?: string\n}\n"
        }
      },
      "status": {
        "customStatus": "let igs = context.outputs.ingress.status.loadBalancer.ingress\nif igs == _|_ {\n  message: \"No loadBalancer found, visiting by using 'vela port-forward \" + context.appName + \"'\\n\"\n}\nif len(igs) > 0 {\n  if igs[0].ip != _|_ {\n  \tif igs[0].host != _|_ {\n\t    message: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host + \", IP: \" + igs[0].ip\n  \t}\n  \tif igs[0].host == _|_ {\n\t    message: \"Host not specified, visit the cluster or load balancer in front of the cluster\"\n  \t}\n  }\n  if igs[0].ip == _|_ {\n  \tif igs[0].host != _|_ {\n\t\t  message: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host\n\t\t}\n  \tif igs[0].host != _|_ {\n\t    message: \"Host not specified, visit the cluster or load balancer in front of the cluster\"\n\t\t}\n  }\n}",
        "healthPolicy": "isHealth: len(context.outputs.service.spec.clusterIP) > 0"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add host aliases on K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "hostalias",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "patch: {\n\t// +patchKey=ip\n\tspec: template: spec: hostAliases: parameter.hostAliases\n}\nparameter: {\n\t// +usage=Specify the hostAliases to add\n\thostAliases: [...{\n\t\tip: string\n\t\thostnames: [...string]\n\t}]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Import dashboards to Grafana"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "import-grafana-dashboard",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [],
      "conflictsWith": [],
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "outputs: registerdatasource: {\n\tapiVersion: \"grafana.extension.oam.dev/v1alpha1\"\n\tkind:       \"ImportDashboard\"\n\tspec: {\n\t\tgrafana: {\n\t\t\tservice:                   parameter.grafanaServiceName\n\t\t\tnamespace:                 parameter.grafanaServiceNamespace\n\t\t\tcredentialSecret:          parameter.credentialSecret\n\t\t\tcredentialSecretNamespace: parameter.credentialSecretNamespace\n\t\t}\n\t\turls: parameter.urls\n\t}\n}\nparameter: {\n\tgrafanaServiceName:        string\n\tgrafanaServiceNamespace:   *\"default\" | string\n\tcredentialSecret:          string\n\tcredentialSecretNamespace: *\"default\" | string\n\turls: [...string]\n\n}\n"
        }
      },
      "workloadRefPath": ""
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Enable public web traffic for the component, the ingress API matches K8s v1.20+."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "ingress-1-20",
      "namespace": "default"
    },
    "spec": {
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "// trait template can have multiple outputs in one trait\noutputs: service: {\n\tapiVersion: \"v1\"\n\tkind:       \"Service\"\n\tmetadata: name: context.name\n\tspec: {\n\t\tselector: \"app.oam.dev/component\": context.name\n\t\tports: [\n\t\t\tfor k, v in parameter.http {\n\t\t\t\tport:       v\n\t\t\t\ttargetPort: v\n\t\t\t},\n\t\t]\n\t}\n}\noutputs: ingress: {\n\tapiVersion: \"networking.k8s.io/v1\"\n\tkind:       \"Ingress\"\n\tmetadata: {\n\t\tname: context.name\n\t\tannotations: \"kubernetes.io/ingress.class\": parameter.class\n\t}\n\tspec: rules: [{\n\t\thost: parameter.domain\n\t\thttp: paths: [\n\t\t\tfor k, v in parameter.http {\n\t\t\t\tpath:     k\n\t\t\t\tpathType: \"ImplementationSpecific\"\n\t\t\t\tbackend: service: {\n\t\t\t\t\tname: context.name\n\t\t\t\t\tport: number: v\n\t\t\t\t}\n\t\t\t},\n\t\t]\n\t}]\n}\nparameter: {\n\t// +usage=Specify the domain you want to expose\n\tdomain: string\n\n\t// +usage=Specify the mapping relationship between the http path and the workload port\n\thttp: [string]: int\n\n\t// +usage=Specify the class of ingress to use\n\tclass: *\"nginx\" | string\n}\n"
        }
      },
      "status": {
        "customStatus": "let igs = context.outputs.ingress.status.loadBalancer.ingress\nif igs == _|_ {\n  message: \"No loadBalancer found, visiting by using 'vela port-forward \" + context.appName + \"'\\n\"\n}\nif len(igs) > 0 {\n  if igs[0].ip != _|_ {\n\t  message: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host + \", IP: \" + igs[0].ip\n  }\n  if igs[0].ip == _|_ {\n\t  message: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host\n  }\n}",
        "healthPolicy": "isHealth: len(context.outputs.service.spec.clusterIP) > 0"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Enable public web traffic for the component."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "ingress",
      "namespace": "default"
    },
    "spec": {
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "// trait template can have multiple outputs in one trait\noutputs: service: {\n\tapiVersion: \"v1\"\n\tkind:       \"Service\"\n\tmetadata: name: context.name\n\tspec: {\n\t\tselector: \"app.oam.dev/component\": context.name\n\t\tports: [\n\t\t\tfor k, v in parameter.http {\n\t\t\t\tport:       v\n\t\t\t\ttargetPort: v\n\t\t\t},\n\t\t]\n\t}\n}\noutputs: ingress: {\n\tapiVersion: \"networking.k8s.io/v1beta1\"\n\tkind:       \"Ingress\"\n\tmetadata: name: context.name\n\tspec: rules: [{\n\t\thost: parameter.domain\n\t\thttp: paths: [\n\t\t\tfor k, v in parameter.http {\n\t\t\t\tpath: k\n\t\t\t\tbackend: {\n\t\t\t\t\tserviceName: context.name\n\t\t\t\t\tservicePort: v\n\t\t\t\t}\n\t\t\t},\n\t\t]\n\t}]\n}\nparameter: {\n\t// +usage=Specify the domain you want to expose\n\tdomain: string\n\n\t// +usage=Specify the mapping relationship between the http path and the workload port\n\thttp: [string]: int\n}\n"
        }
      },
      "status": {
        "customStatus": "let igs = context.outputs.ingress.status.loadBalancer.ingress\nif igs == _|_ {\n\tmessage: \"No loadBalancer found, visiting by using 'vela port-forward \" + context.appName + \"'\\n\"\n}\nif len(igs) > 0 {\n\tif igs[0].ip != _|_ {\n\t\tmessage: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host + \", IP: \" + igs[0].ip\n\t}\n\tif igs[0].ip == _|_ {\n\t\tmessage: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host\n\t}\n}",
        "healthPolicy": "isHealth: len(context.outputs.service.spec.clusterIP) > 0"
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "add an init container and use shared volume with pod"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "init-container",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "deployments.apps"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: {\n\t// +patchKey=name\n\tcontainers: [{\n\t\tname: context.name\n\t\t// +patchKey=name\n\t\tvolumeMounts: [{\n\t\t\tname:      parameter.mountName\n\t\t\tmountPath: parameter.appMountPath\n\t\t}]\n\t}]\n\tinitContainers: [{\n\t\tname:  parameter.name\n\t\timage: parameter.image\n\t\tif parameter.cmd != _|_ {\n\t\t\tcommand: parameter.cmd\n\t\t}\n\t\tif parameter.args != _|_ {\n\t\t\targs: parameter.args\n\t\t}\n\t\tif parameter[\"env\"] != _|_ {\n\t\t\tenv: parameter.env\n\t\t}\n\n\t\t// +patchKey=name\n\t\tvolumeMounts: [{\n\t\t\tname:      parameter.mountName\n\t\t\tmountPath: parameter.initMountPath\n\t\t}]\n\t}]\n\t// +patchKey=name\n\tvolumes: [{\n\t\tname: parameter.mountName\n\t\temptyDir: {}\n\t}]\n}\nparameter: {\n\t// +usage=Specify the name of init container\n\tname: string\n\n\t// +usage=Specify the image of init container\n\timage: string\n\n\t// +usage=Specify the commands run in the init container\n\tcmd?: [...string]\n\n\t// +usage=Specify the args run in the init container\n\targs?: [...string]\n\n\t// +usage=Specify the env run in the init container\n\tenv?: [...{\n\t\t// +usage=Environment variable name\n\t\tname: string\n\t\t// +usage=The value of the environment variable\n\t\tvalue?: string\n\t\t// +usage=Specifies a source the value of this var should come from\n\t\tvalueFrom?: {\n\t\t\t// +usage=Selects a key of a secret in the pod's namespace\n\t\t\tsecretKeyRef?: {\n\t\t\t\t// +usage=The name of the secret in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the secret to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t\t// +usage=Selects a key of a config map in the pod's namespace\n\t\t\tconfigMapKeyRef?: {\n\t\t\t\t// +usage=The name of the config map in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the config map to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t}]\n\n\t// +usage=Specify the mount name of shared volume\n\tmountName: *\"workdir\" | string\n\n\t// +usage=Specify the mount path of app container\n\tappMountPath: string\n\n\t// +usage=Specify the mount path of init container\n\tinitMountPath: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Patch the output following Json Merge Patch strategy, following RFC 7396."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "json-merge-patch",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "parameter: {...}\n// +patchStrategy=jsonMergePatch\npatch: parameter\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Patch the output following Json Patch strategy, following RFC 6902."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "json-patch",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "parameter: operations: [...{...}]\n// +patchStrategy=jsonPatch\npatch: parameter\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add labels on K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "labels",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "// +patchStrategy=jsonMergePatch\npatch: {\n\tmetadata: labels: {\n\t\tfor k, v in parameter {\n\t\t\t\"\\(k)\": v\n\t\t}\n\t}\n\tif context.output.spec != _|_ && context.output.spec.template != _|_ {\n\t\tspec: template: metadata: labels: {\n\t\t\tfor k, v in parameter {\n\t\t\t\t\"\\(k)\": v\n\t\t\t}\n\t\t}\n\t}\n}\nparameter: [string]: string | null\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add lifecycle hooks for every container of K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "lifecycle",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: containers: [...{\n\tlifecycle: {\n\t\tif parameter.postStart != _|_ {\n\t\t\tpostStart: parameter.postStart\n\t\t}\n\t\tif parameter.preStop != _|_ {\n\t\t\tpreStop: parameter.preStop\n\t\t}\n\t}\n}]\nparameter: {\n\tpostStart?: #LifeCycleHandler\n\tpreStop?:   #LifeCycleHandler\n}\n#Port: int & >=1 & <=65535\n#LifeCycleHandler: {\n\texec?: command: [...string]\n\thttpGet?: {\n\t\tpath?:  string\n\t\tport:   #Port\n\t\thost?:  string\n\t\tscheme: *\"HTTP\" | \"HTTPS\"\n\t\thttpHeaders?: [...{\n\t\t\tname:  string\n\t\t\tvalue: string\n\t\t}]\n\t}\n\ttcpSocket?: {\n\t\tport:  #Port\n\t\thost?: string\n\t}\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "nocalhost develop configuration."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "nocalhost",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "import (\n\t\"encoding/json\"\n)\n\noutputs: nocalhostService: {\n\tapiVersion: \"v1\"\n\tkind:       \"Service\"\n\tmetadata: name: context.name\n\tspec: {\n\t\tselector: \"app.oam.dev/component\": context.name\n\t\tports: [\n\t\t\t{\n\t\t\t\tport:       parameter.port\n\t\t\t\ttargetPort: parameter.port\n\t\t\t},\n\t\t]\n\t\ttype: \"ClusterIP\"\n\t}\n}\npatch: metadata: annotations: {\n\t\"dev.nocalhost/application-name\":      context.appName\n\t\"dev.nocalhost/application-namespace\": context.namespace\n\t\"dev.nocalhost\":                       json.Marshal({\n\t\tname:        context.name\n\t\tserviceType: parameter.serviceType\n\t\tcontainers: [\n\t\t\t{\n\t\t\t\tname: context.name\n\t\t\t\tdev: {\n\t\t\t\t\tif parameter.gitUrl != _|_ {\n\t\t\t\t\t\tgitUrl: parameter.gitUrl\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.image == \"go\" {\n\t\t\t\t\t\timage: \"nocalhost-docker.pkg.coding.net/nocalhost/dev-images/golang:latest\"\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.image == \"java\" {\n\t\t\t\t\t\timage: \"nocalhost-docker.pkg.coding.net/nocalhost/dev-images/java:latest\"\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.image == \"python\" {\n\t\t\t\t\t\timage: \"nocalhost-docker.pkg.coding.net/nocalhost/dev-images/python:latest\"\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.image == \"node\" {\n\t\t\t\t\t\timage: \"nocalhost-docker.pkg.coding.net/nocalhost/dev-images/node:latest\"\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.image == \"ruby\" {\n\t\t\t\t\t\timage: \"nocalhost-docker.pkg.coding.net/nocalhost/dev-images/ruby:latest\"\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.image != \"go\" && parameter.image != \"java\" && parameter.image != \"python\" && parameter.image != \"node\" && parameter.image != \"ruby\" {\n\t\t\t\t\t\timage: parameter.image\n\t\t\t\t\t}\n\t\t\t\t\tshell:   parameter.shell\n\t\t\t\t\tworkDir: parameter.workDir\n\t\t\t\t\tif parameter.storageClass != _|_ {\n\t\t\t\t\t\tstorageClass: parameter.storageClass\n\t\t\t\t\t}\n\t\t\t\t\tresources: {\n\t\t\t\t\t\tlimits:   parameter.resources.limits\n\t\t\t\t\t\trequests: parameter.resources.requests\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.persistentVolumeDirs != _|_ {\n\t\t\t\t\t\tpersistentVolumeDirs: [\n\t\t\t\t\t\t\tfor v in parameter.persistentVolumeDirs {\n\t\t\t\t\t\t\t\tpath:     v.path\n\t\t\t\t\t\t\t\tcapacity: v.capacity\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.command != _|_ {\n\t\t\t\t\t\tcommand: parameter.command\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.debug != _|_ {\n\t\t\t\t\t\tdebug: parameter.debug\n\t\t\t\t\t}\n\t\t\t\t\thotReload: parameter.hotReload\n\t\t\t\t\tif parameter.sync != _|_ {\n\t\t\t\t\t\tsync: parameter.sync\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.env != _|_ {\n\t\t\t\t\t\tenv: [\n\t\t\t\t\t\t\tfor v in parameter.env {\n\t\t\t\t\t\t\t\tname:  v.name\n\t\t\t\t\t\t\t\tvalue: v.value\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t]\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.portForward != _|_ {\n\t\t\t\t\t\tportForward: parameter.portForward\n\t\t\t\t\t}\n\t\t\t\t\tif parameter.portForward == _|_ {\n\t\t\t\t\t\tportForward: [\"\\(parameter.port)\" + \":\" + \"\\(parameter.port)\"]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t]\n\t})\n}\nlanguage: \"go\" | \"java\" | \"python\" | \"node\" | \"ruby\"\nparameter: {\n\tport:          int\n\tserviceType:   *\"deployment\" | string\n\tgitUrl?:       string\n\timage:         language | string\n\tshell:         *\"bash\" | string\n\tworkDir:       *\"/home/nocalhost-dev\" | string\n\tstorageClass?: string\n\tcommand: {\n\t\trun:   *[\"sh\", \"run.sh\"] | [...string]\n\t\tdebug: *[\"sh\", \"debug.sh\"] | [...string]\n\t}\n\tdebug?: remoteDebugPort?: int\n\thotReload: *true | bool\n\tsync: {\n\t\ttype:              *\"send\" | string\n\t\tfilePattern:       *[\"./\"] | [...string]\n\t\tignoreFilePattern: *[\".git\", \".vscode\", \".idea\", \".gradle\", \"build\"] | [...string]\n\t}\n\tenv?: [...{\n\t\tname:  string\n\t\tvalue: string\n\t}]\n\tportForward?: [...string]\n\tpersistentVolumeDirs?: [...{\n\t\tpath:     string\n\t\tcapacity: string\n\t}]\n\tresources: {\n\t\tlimits: {\n\t\t\tmemory: *\"2Gi\" | string\n\t\t\tcpu:    *\"2\" | string\n\t\t}\n\t\trequests: {\n\t\t\tmemory: *\"512Mi\" | string\n\t\t\tcpu:    *\"0.5\" | string\n\t\t}\n\t}\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "affinity specify node affinity and toleration on K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true",
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "node-affinity",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: {\n\tif parameter.affinity != _|_ {\n\t\taffinity: nodeAffinity: requiredDuringSchedulingIgnoredDuringExecution: nodeSelectorTerms: [{\n\t\t\tmatchExpressions: [\n\t\t\t\tfor k, v in parameter.affinity {\n\t\t\t\t\tkey:      k\n\t\t\t\t\toperator: \"In\"\n\t\t\t\t\tvalues:   v\n\t\t\t\t},\n\t\t\t]}]\n\t}\n\tif parameter.tolerations != _|_ {\n\t\ttolerations: [\n\t\t\tfor k, v in parameter.tolerations {\n\t\t\t\teffect:   \"NoSchedule\"\n\t\t\t\tkey:      k\n\t\t\t\toperator: \"Equal\"\n\t\t\t\tvalue:    v\n\t\t\t}]\n\t}\n}\nparameter: {\n\taffinity?: [string]: [...string]\n\ttolerations?: [string]: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Enable public web traffic for the component without creating a Service."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "pure-ingress",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [],
      "conflictsWith": [],
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "outputs: ingress: {\n\tapiVersion: \"networking.k8s.io/v1beta1\"\n\tkind:       \"Ingress\"\n\tmetadata: name: context.name\n\tspec: rules: [{\n\t\thost: parameter.domain\n\t\thttp: paths: [\n\t\t\tfor k, v in parameter.http {\n\t\t\t\tpath: k\n\t\t\t\tbackend: {\n\t\t\t\t\tserviceName: context.name\n\t\t\t\t\tservicePort: v\n\t\t\t\t}\n\t\t\t},\n\t\t]\n\t}]\n}\nparameter: {\n\t// +usage=Specify the domain you want to expose\n\tdomain: string\n\n\t// +usage=Specify the mapping relationship between the http path and the workload port\n\thttp: [string]: int\n}\n"
        }
      },
      "status": {
        "customStatus": "let igs = context.outputs.ingress.status.loadBalancer.ingress\nif igs == _|_ {\n\tmessage: \"No loadBalancer found, visiting by using 'vela port-forward \" + context.appName + \" --route'\\n\"\n}\nif len(igs) > 0 {\n\tif igs[0].ip != _|_ {\n\t\tmessage: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host + \", IP: \" + igs[0].ip\n\t}\n\tif igs[0].ip == _|_ {\n\t\tmessage: \"Visiting URL: \" + context.outputs.ingress.spec.rules[0].host\n\t}\n}"
      },
      "workloadRefPath": ""
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Create a Persistent Volume Claim and mount the PVC as volume to the  first container in the pod. This definition is DEPRECATED, please specify pvc in 'storage' instead."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "pvc",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "deployments.apps"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: {\n\tcontainers: [{\n\t\tif parameter.volumeMode == \"Block\" {\n\t\t\t// +patchKey=name\n\t\t\tvolumeDevices: [\n\t\t\t\tfor v in parameter.volumesToMount {\n\t\t\t\t\t{\n\t\t\t\t\t\tname:       v.name\n\t\t\t\t\t\tdevicePath: v.devicePath\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t]\n\t\t}\n\t\tif parameter.volumeMode == \"Filesystem\" {\n\t\t\t// +patchKey=name\n\t\t\tvolumeMounts: [\n\t\t\t\tfor v in parameter.volumesToMount {\n\t\t\t\t\t{\n\t\t\t\t\t\tname:      v.name\n\t\t\t\t\t\tmountPath: v.mountPath\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t]\n\t\t}\n\t}]\n\n\t// +patchKey=name\n\tvolumes: [\n\t\tfor v in parameter.volumesToMount {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tpersistentVolumeClaim: claimName: parameter.claimName\n\t\t\t}\n\t\t},\n\t]\n}\noutputs: \"\\(parameter.claimName)\": {\n\tapiVersion: \"v1\"\n\tkind:       \"PersistentVolumeClaim\"\n\tmetadata: name: parameter.claimName\n\tspec: {\n\t\taccessModes: parameter.accessModes\n\t\tvolumeMode:  parameter.volumeMode\n\t\tif parameter.volumeName != _|_ {\n\t\t\tvolumeName: parameter.volumeName\n\t\t}\n\n\t\tif parameter.storageClassName != _|_ {\n\t\t\tstorageClassName: parameter.storageClassName\n\t\t}\n\t\tresources: requests: storage: parameter.resources.requests.storage\n\t\tif parameter.resources.limits.storage != _|_ {\n\t\t\tresources: limits: storage: parameter.resources.limits.storage\n\t\t}\n\t\tif parameter.dataSourceRef != _|_ {\n\t\t\tdataSourceRef: parameter.dataSourceRef\n\t\t}\n\t\tif parameter.dataSource != _|_ {\n\t\t\tdataSource: parameter.dataSource\n\t\t}\n\t\tif parameter.selector != _|_ {\n\t\t\tdataSource: parameter.selector\n\t\t}\n\t}\n}\nparameter: {\n\tclaimName:   string\n\tvolumeMode:  *\"Filesystem\" | string\n\tvolumeName?: string\n\taccessModes: [...string]\n\tstorageClassName?: string\n\tresources: {\n\t\trequests: storage: =~\"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$\"\n\t\tlimits?: storage:  =~\"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$\"\n\t}\n\tdataSourceRef?: {\n\t\tname:     string\n\t\tkind:     string\n\t\tapiGroup: string\n\t}\n\tdataSource?: {\n\t\tname:     string\n\t\tkind:     string\n\t\tapiGroup: string\n\t}\n\tselector?: {\n\t\tmatchLabels?: [string]: string\n\t\tmatchExpressions?: {\n\t\t\tkey: string\n\t\t\tvalues: [...string]\n\t\t\toperator: string\n\t\t}\n\t}\n\tvolumesToMount: [...{\n\t\tname: string\n\t\tif volumeMode == \"Block\" {\n\t\t\tdevicePath: string\n\t\t}\n\t\tif volumeMode == \"Filesystem\" {\n\t\t\tmountPath: string\n\t\t}\n\t}]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add a datasource to Grafana"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "register-grafana-datasource",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [],
      "conflictsWith": [],
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "outputs: registerdatasource: {\n\tapiVersion: \"grafana.extension.oam.dev/v1alpha1\"\n\tkind:       \"DatasourceRegistration\"\n\tspec: {\n\t\tgrafana: {\n\t\t\tservice:                   parameter.grafanaServiceName\n\t\t\tnamespace:                 parameter.grafanaServiceNamespace\n\t\t\tcredentialSecret:          parameter.credentialSecret\n\t\t\tcredentialSecretNamespace: parameter.credentialSecretNamespace\n\t\t}\n\t\tdatasource: {\n\t\t\tname:      parameter.name\n\t\t\ttype:      parameter.type\n\t\t\taccess:    parameter.access\n\t\t\tservice:   parameter.service\n\t\t\tnamespace: parameter.namespace\n\t\t}\n\t}\n}\nparameter: {\n\tgrafanaServiceName:        string\n\tgrafanaServiceNamespace:   *\"default\" | string\n\tcredentialSecret:          string\n\tcredentialSecretNamespace: string\n\tname:                      string\n\ttype:                      string\n\taccess:                    *\"proxy\" | string\n\tservice:                   string\n\tnamespace:                 *\"default\" | string\n}\n"
        }
      },
      "workloadRefPath": ""
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add resource requests and limits on K8s pod for your workload which follows the pod spec in path 'spec.template.'"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "resource",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: containers: [...{\n\tresources: {\n\t\tif parameter.cpu != _|_ && parameter.memory != _|_ && parameter.requests == _|_ && parameter.limits == _|_ {\n\t\t\trequests: {\n\t\t\t\tcpu:    parameter.cpu\n\t\t\t\tmemory: parameter.memory\n\t\t\t}\n\t\t\tlimits: {\n\t\t\t\tcpu:    parameter.cpu\n\t\t\t\tmemory: parameter.memory\n\t\t\t}\n\t\t}\n\n\t\tif parameter.requests != _|_ {\n\t\t\trequests: {\n\t\t\t\tcpu:    parameter.requests.cpu\n\t\t\t\tmemory: parameter.requests.memory\n\t\t\t}\n\t\t}\n\t\tif parameter.limits != _|_ {\n\t\t\tlimits: {\n\t\t\t\tcpu:    parameter.limits.cpu\n\t\t\t\tmemory: parameter.limits.memory\n\t\t\t}\n\t\t}\n\t}\n}]\nparameter: {\n\t// +usage=Specify the amount of cpu for requests and limits\n\tcpu?: *1 | number\n\t// +usage=Specify the amount of memory for requests and limits\n\tmemory?: *\"2048Mi\" | =~\"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$\"\n\t// +usage=Specify the resources in requests\n\trequests?: {\n\t\t// +usage=Specify the amount of cpu for requests\n\t\tcpu: *1 | number\n\t\t// +usage=Specify the amount of memory for requests\n\t\tmemory: *\"2048Mi\" | =~\"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$\"\n\t}\n\t// +usage=Specify the resources in limits\n\tlimits?: {\n\t\t// +usage=Specify the amount of cpu for limits\n\t\tcpu: *1 | number\n\t\t// +usage=Specify the amount of memory for limits\n\t\tmemory: *\"2048Mi\" | =~\"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$\"\n\t}\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Manually scale K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "name": "scaler",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "parameter: {\n\t// +usage=Specify the number of workload\n\treplicas: *1 | int\n}\n// +patchStrategy=retainKeys\npatch: spec: replicas: parameter.replicas\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Specify serviceAccount for your workload which follows the pod spec in path 'spec.template'."
      },
      "name": "service-account",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": false,
      "schematic": {
        "cue": {
          "template": "parameter: {\n\t// +usage=Specify the name of ServiceAccount\n\tname: string\n}\n// +patchStrategy=retainKeys\npatch: spec: template: spec: serviceAccountName: parameter.name\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Binding secrets of cloud resources to component env. This definition is DEPRECATED, please use 'storage' instead."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "service-binding",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "schematic": {
        "cue": {
          "template": "patch: spec: template: spec: {\n\t// +patchKey=name\n\tcontainers: [{\n\t\tname: context.name\n\t\t// +patchKey=name\n\t\tenv: [\n\t\t\tfor envName, v in parameter.envMappings {\n\t\t\t\tname: envName\n\t\t\t\tvalueFrom: secretKeyRef: {\n\t\t\t\t\tname: v.secret\n\t\t\t\t\tif v[\"key\"] != _|_ {\n\t\t\t\t\t\tkey: v.key\n\t\t\t\t\t}\n\t\t\t\t\tif v[\"key\"] == _|_ {\n\t\t\t\t\t\tkey: envName\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\t]\n\t}]\n}\nparameter: {\n\t// +usage=The mapping of environment variables to secret\n\tenvMappings: [string]: #KeySecret\n}\n#KeySecret: {\n\tkey?:   string\n\tsecret: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Inject a sidecar container to K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "sidecar",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "*"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: {\n\t// +patchKey=name\n\tspec: template: spec: containers: [{\n\t\tname:  parameter.name\n\t\timage: parameter.image\n\t\tif parameter.cmd != _|_ {\n\t\t\tcommand: parameter.cmd\n\t\t}\n\t\tif parameter.args != _|_ {\n\t\t\targs: parameter.args\n\t\t}\n\t\tif parameter[\"env\"] != _|_ {\n\t\t\tenv: parameter.env\n\t\t}\n\t\tif parameter[\"volumes\"] != _|_ {\n\t\t\tvolumeMounts: [ for v in parameter.volumes {\n\t\t\t\t{\n\t\t\t\t\tmountPath: v.path\n\t\t\t\t\tname:      v.name\n\t\t\t\t}\n\t\t\t}]\n\t\t}\n\t\tif parameter[\"livenessProbe\"] != _|_ {\n\t\t\tlivenessProbe: parameter.livenessProbe\n\t\t}\n\n\t\tif parameter[\"readinessProbe\"] != _|_ {\n\t\t\treadinessProbe: parameter.readinessProbe\n\t\t}\n\t}]\n}\nparameter: {\n\t// +usage=Specify the name of sidecar container\n\tname: string\n\n\t// +usage=Specify the image of sidecar container\n\timage: string\n\n\t// +usage=Specify the commands run in the sidecar\n\tcmd?: [...string]\n\n\t// +usage=Specify the args in the sidecar\n\targs?: [...string]\n\n\t// +usage=Specify the env in the sidecar\n\tenv?: [...{\n\t\t// +usage=Environment variable name\n\t\tname: string\n\t\t// +usage=The value of the environment variable\n\t\tvalue?: string\n\t\t// +usage=Specifies a source the value of this var should come from\n\t\tvalueFrom?: {\n\t\t\t// +usage=Selects a key of a secret in the pod's namespace\n\t\t\tsecretKeyRef?: {\n\t\t\t\t// +usage=The name of the secret in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the secret to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t\t// +usage=Selects a key of a config map in the pod's namespace\n\t\t\tconfigMapKeyRef?: {\n\t\t\t\t// +usage=The name of the config map in the pod's namespace to select from\n\t\t\t\tname: string\n\t\t\t\t// +usage=The key of the config map to select from. Must be a valid secret key\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t}]\n\n\t// +usage=Specify the shared volume path\n\tvolumes?: [...{\n\t\tname: string\n\t\tpath: string\n\t}]\n\n\t// +usage=Instructions for assessing whether the container is alive.\n\tlivenessProbe?: #HealthProbe\n\n\t// +usage=Instructions for assessing whether the container is in a suitable state to serve traffic.\n\treadinessProbe?: #HealthProbe\n}\n#HealthProbe: {\n\n\t// +usage=Instructions for assessing container health by executing a command. Either this attribute or the httpGet attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the httpGet attribute and the tcpSocket attribute.\n\texec?: {\n\t\t// +usage=A command to be executed inside the container to assess its health. Each space delimited token of the command is a separate array element. Commands exiting 0 are considered to be successful probes, whilst all other exit codes are considered failures.\n\t\tcommand: [...string]\n\t}\n\n\t// +usage=Instructions for assessing container health by executing an HTTP GET request. Either this attribute or the exec attribute or the tcpSocket attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the tcpSocket attribute.\n\thttpGet?: {\n\t\t// +usage=The endpoint, relative to the port, to which the HTTP GET request should be directed.\n\t\tpath: string\n\t\t// +usage=The TCP socket within the container to which the HTTP GET request should be directed.\n\t\tport: int\n\t\thttpHeaders?: [...{\n\t\t\tname:  string\n\t\t\tvalue: string\n\t\t}]\n\t}\n\n\t// +usage=Instructions for assessing container health by probing a TCP socket. Either this attribute or the exec attribute or the httpGet attribute MUST be specified. This attribute is mutually exclusive with both the exec attribute and the httpGet attribute.\n\ttcpSocket?: {\n\t\t// +usage=The TCP socket within the container that should be probed to assess container health.\n\t\tport: int\n\t}\n\n\t// +usage=Number of seconds after the container is started before the first probe is initiated.\n\tinitialDelaySeconds: *0 | int\n\n\t// +usage=How often, in seconds, to execute the probe.\n\tperiodSeconds: *10 | int\n\n\t// +usage=Number of seconds after which the probe times out.\n\ttimeoutSeconds: *1 | int\n\n\t// +usage=Minimum consecutive successes for the probe to be considered successful after having failed.\n\tsuccessThreshold: *1 | int\n\n\t// +usage=Number of consecutive failures required to determine the container is not alive (liveness probe) or not ready (readiness probe).\n\tfailureThreshold: *3 | int\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add storages on K8s pod for your workload which follows the pod spec in path 'spec.template'."
      },
      "name": "storage",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "deployments.apps"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "pvcVolumesList: *[\n\t\tfor v in parameter.pvc {\n\t\t{\n\t\t\tname: \"pvc-\" + v.name\n\t\t\tpersistentVolumeClaim: claimName: v.name\n\t\t}\n\t},\n] | []\nconfigMapVolumesList: *[\n\t\t\tfor v in parameter.configMap if v.mountPath != _|_ {\n\t\t{\n\t\t\tname: \"configmap-\" + v.name\n\t\t\tconfigMap: {\n\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\tname:        v.name\n\t\t\t\tif v.items != _|_ {\n\t\t\t\t\titems: v.items\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n] | []\nsecretVolumesList: *[\n\t\t\tfor v in parameter.secret if v.mountPath != _|_ {\n\t\t{\n\t\t\tname: \"secret-\" + v.name\n\t\t\tsecret: {\n\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\tsecretName:  v.name\n\t\t\t\tif v.items != _|_ {\n\t\t\t\t\titems: v.items\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n] | []\nemptyDirVolumesList: *[\n\t\t\tfor v in parameter.emptyDir {\n\t\t{\n\t\t\tname: \"emptydir-\" + v.name\n\t\t\temptyDir: medium: v.medium\n\t\t}\n\t},\n] | []\npvcVolumeMountsList: *[\n\t\t\tfor v in parameter.pvc {\n\t\tif v.volumeMode == \"Filesystem\" {\n\t\t\t{\n\t\t\t\tname:      \"pvc-\" + v.name\n\t\t\t\tmountPath: v.mountPath\n\t\t\t}\n\t\t}\n\t},\n] | []\nconfigMapVolumeMountsList: *[\n\t\t\t\tfor v in parameter.configMap if v.mountPath != _|_ {\n\t\t{\n\t\t\tname:      \"configmap-\" + v.name\n\t\t\tmountPath: v.mountPath\n\t\t}\n\t},\n] | []\nconfigMapEnvMountsList: *[\n\t\t\tfor v in parameter.configMap if v.mountToEnv != _|_ {\n\t\t{\n\t\t\tname: v.mountToEnv.envName\n\t\t\tvalueFrom: configMapKeyRef: {\n\t\t\t\tname: v.name\n\t\t\t\tkey:  v.mountToEnv.configMapKey\n\t\t\t}\n\t\t}\n\t},\n] | []\nconfigMountToEnvsList: *[\n\t\t\tfor v in parameter.configMap if v.mountToEnvs != _|_ for k in v.mountToEnvs {\n\t\t{\n\t\t\tname: k.envName\n\t\t\tvalueFrom: configMapKeyRef: {\n\t\t\t\tname: v.name\n\t\t\t\tkey:  k.configMapKey\n\t\t\t}\n\t\t}\n\t},\n] | []\nsecretVolumeMountsList: *[\n\t\t\tfor v in parameter.secret if v.mountPath != _|_ {\n\t\t{\n\t\t\tname:      \"secret-\" + v.name\n\t\t\tmountPath: v.mountPath\n\t\t}\n\t},\n] | []\nsecretEnvMountsList: *[\n\t\t\tfor v in parameter.secret if v.mountToEnv != _|_ {\n\t\t{\n\t\t\tname: v.mountToEnv.envName\n\t\t\tvalueFrom: secretKeyRef: {\n\t\t\t\tname: v.name\n\t\t\t\tkey:  v.mountToEnv.secretKey\n\t\t\t}\n\t\t}\n\t},\n] | []\nsecretMountToEnvsList: *[\n\t\t\tfor v in parameter.secret if v.mountToEnvs != _|_ for k in v.mountToEnvs {\n\t\t{\n\t\t\tname: k.envName\n\t\t\tvalueFrom: secretKeyRef: {\n\t\t\t\tname: v.name\n\t\t\t\tkey:  k.secretKey\n\t\t\t}\n\t\t}\n\t},\n] | []\nemptyDirVolumeMountsList: *[\n\t\t\t\tfor v in parameter.emptyDir {\n\t\t{\n\t\t\tname:      \"emptydir-\" + v.name\n\t\t\tmountPath: v.mountPath\n\t\t}\n\t},\n] | []\nvolumeDevicesList: *[\n\t\t\tfor v in parameter.pvc if v.volumeMode == \"Block\" {\n\t\t{\n\t\t\tname:       \"pvc-\" + v.name\n\t\t\tdevicePath: v.mountPath\n\t\t}\n\t},\n] | []\npatch: spec: template: spec: {\n\t// +patchKey=name\n\tvolumes: pvcVolumesList + configMapVolumesList + secretVolumesList + emptyDirVolumesList\n\n\tcontainers: [{\n\t\t// +patchKey=name\n\t\tenv: configMapEnvMountsList + secretEnvMountsList + configMountToEnvsList + secretMountToEnvsList\n\t\t// +patchKey=name\n\t\tvolumeDevices: volumeDevicesList\n\t\t// +patchKey=name\n\t\tvolumeMounts: pvcVolumeMountsList + configMapVolumeMountsList + secretVolumeMountsList + emptyDirVolumeMountsList\n\t}, ...]\n\n}\noutputs: {\n\tfor v in parameter.pvc {\n\t\tif v.mountOnly == false {\n\t\t\t\"pvc-\\(v.name)\": {\n\t\t\t\tapiVersion: \"v1\"\n\t\t\t\tkind:       \"PersistentVolumeClaim\"\n\t\t\t\tmetadata: name: v.name\n\t\t\t\tspec: {\n\t\t\t\t\taccessModes: v.accessModes\n\t\t\t\t\tvolumeMode:  v.volumeMode\n\t\t\t\t\tif v.volumeName != _|_ {\n\t\t\t\t\t\tvolumeName: v.volumeName\n\t\t\t\t\t}\n\t\t\t\t\tif v.storageClassName != _|_ {\n\t\t\t\t\t\tstorageClassName: v.storageClassName\n\t\t\t\t\t}\n\n\t\t\t\t\tif v.resources.requests.storage == _|_ {\n\t\t\t\t\t\tresources: requests: storage: \"8Gi\"\n\t\t\t\t\t}\n\t\t\t\t\tif v.resources.requests.storage != _|_ {\n\t\t\t\t\t\tresources: requests: storage: v.resources.requests.storage\n\t\t\t\t\t}\n\t\t\t\t\tif v.resources.limits.storage != _|_ {\n\t\t\t\t\t\tresources: limits: storage: v.resources.limits.storage\n\t\t\t\t\t}\n\t\t\t\t\tif v.dataSourceRef != _|_ {\n\t\t\t\t\t\tdataSourceRef: v.dataSourceRef\n\t\t\t\t\t}\n\t\t\t\t\tif v.dataSource != _|_ {\n\t\t\t\t\t\tdataSource: v.dataSource\n\t\t\t\t\t}\n\t\t\t\t\tif v.selector != _|_ {\n\t\t\t\t\t\tdataSource: v.selector\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor v in parameter.configMap {\n\t\tif v.mountOnly == false {\n\t\t\t\"configmap-\\(v.name)\": {\n\t\t\t\tapiVersion: \"v1\"\n\t\t\t\tkind:       \"ConfigMap\"\n\t\t\t\tmetadata: name: v.name\n\t\t\t\tif v.data != _|_ {\n\t\t\t\t\tdata: v.data\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor v in parameter.secret {\n\t\tif v.mountOnly == false {\n\t\t\t\"secret-\\(v.name)\": {\n\t\t\t\tapiVersion: \"v1\"\n\t\t\t\tkind:       \"Secret\"\n\t\t\t\tmetadata: name: v.name\n\t\t\t\tif v.data != _|_ {\n\t\t\t\t\tdata: v.data\n\t\t\t\t}\n\t\t\t\tif v.stringData != _|_ {\n\t\t\t\t\tstringData: v.stringData\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\nparameter: {\n\t// +usage=Declare pvc type storage\n\tpvc?: [...{\n\t\tname:              string\n\t\tmountOnly:         *false | bool\n\t\tmountPath:         string\n\t\tvolumeMode:        *\"Filesystem\" | string\n\t\tvolumeName?:       string\n\t\taccessModes:       *[\"ReadWriteOnce\"] | [...string]\n\t\tstorageClassName?: string\n\t\tresources?: {\n\t\t\trequests: storage: =~\"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$\"\n\t\t\tlimits?: storage:  =~\"^([1-9][0-9]{0,63})(E|P|T|G|M|K|Ei|Pi|Ti|Gi|Mi|Ki)$\"\n\t\t}\n\t\tdataSourceRef?: {\n\t\t\tname:     string\n\t\t\tkind:     string\n\t\t\tapiGroup: string\n\t\t}\n\t\tdataSource?: {\n\t\t\tname:     string\n\t\t\tkind:     string\n\t\t\tapiGroup: string\n\t\t}\n\t\tselector?: {\n\t\t\tmatchLabels?: [string]: string\n\t\t\tmatchExpressions?: {\n\t\t\t\tkey: string\n\t\t\t\tvalues: [...string]\n\t\t\t\toperator: string\n\t\t\t}\n\t\t}\n\t}]\n\n\t// +usage=Declare config map type storage\n\tconfigMap?: [...{\n\t\tname:      string\n\t\tmountOnly: *false | bool\n\t\tmountToEnv?: {\n\t\t\tenvName:      string\n\t\t\tconfigMapKey: string\n\t\t}\n\t\tmountToEnvs?: [...{\n\t\t\tenvName:      string\n\t\t\tconfigMapKey: string\n\t\t}]\n\t\tmountPath?:  string\n\t\tdefaultMode: *420 | int\n\t\treadOnly:    *false | bool\n\t\tdata?: {...}\n\t\titems?: [...{\n\t\t\tkey:  string\n\t\t\tpath: string\n\t\t\tmode: *511 | int\n\t\t}]\n\t}]\n\n\t// +usage=Declare secret type storage\n\tsecret?: [...{\n\t\tname:      string\n\t\tmountOnly: *false | bool\n\t\tmountToEnv?: {\n\t\t\tenvName:   string\n\t\t\tsecretKey: string\n\t\t}\n\t\tmountToEnvs?: [...{\n\t\t\tenvName:   string\n\t\t\tsecretKey: string\n\t\t}]\n\t\tmountPath?:  string\n\t\tdefaultMode: *420 | int\n\t\treadOnly:    *false | bool\n\t\tstringData?: {...}\n\t\tdata?: {...}\n\t\titems?: [...{\n\t\t\tkey:  string\n\t\t\tpath: string\n\t\t\tmode: *511 | int\n\t\t}]\n\t}]\n\n\t// +usage=Declare empty dir type storage\n\temptyDir?: [...{\n\t\tname:      string\n\t\tmountPath: string\n\t\tmedium:    *\"\" | \"Memory\"\n\t}]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "TraitDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Add volumes on K8s pod for your workload which follows the pod spec in path 'spec.template'. This definition is DEPRECATED, please use 'storage' instead."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "volumes",
      "namespace": "default"
    },
    "spec": {
      "appliesToWorkloads": [
        "deployments.apps"
      ],
      "podDisruptive": true,
      "schematic": {
        "cue": {
          "template": "patch: {\n\t// +patchKey=name\n\tspec: template: spec: volumes: [\n\t\tfor v in parameter.volumes {\n\t\t\t{\n\t\t\t\tname: v.name\n\t\t\t\tif v.type == \"pvc\" {\n\t\t\t\t\tpersistentVolumeClaim: claimName: v.claimName\n\t\t\t\t}\n\t\t\t\tif v.type == \"configMap\" {\n\t\t\t\t\tconfigMap: {\n\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\tname:        v.cmName\n\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif v.type == \"secret\" {\n\t\t\t\t\tsecret: {\n\t\t\t\t\t\tdefaultMode: v.defaultMode\n\t\t\t\t\t\tsecretName:  v.secretName\n\t\t\t\t\t\tif v.items != _|_ {\n\t\t\t\t\t\t\titems: v.items\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif v.type == \"emptyDir\" {\n\t\t\t\t\temptyDir: medium: v.medium\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t]\n}\nparameter: {\n\t// +usage=Declare volumes and volumeMounts\n\tvolumes?: [...{\n\t\tname: string\n\t\t// +usage=Specify volume type, options: \"pvc\",\"configMap\",\"secret\",\"emptyDir\"\n\t\ttype: \"pvc\" | \"configMap\" | \"secret\" | \"emptyDir\"\n\t\tif type == \"pvc\" {\n\t\t\tclaimName: string\n\t\t}\n\t\tif type == \"configMap\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tcmName:      string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"secret\" {\n\t\t\tdefaultMode: *420 | int\n\t\t\tsecretName:  string\n\t\t\titems?: [...{\n\t\t\t\tkey:  string\n\t\t\t\tpath: string\n\t\t\t\tmode: *511 | int\n\t\t\t}]\n\t\t}\n\t\tif type == \"emptyDir\" {\n\t\t\tmedium: *\"\" | \"Memory\"\n\t\t}\n\t}]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "admissionregistration.k8s.io/v1",
    "kind": "ValidatingWebhookConfiguration",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission",
      "namespace": "default"
    },
    "webhooks": [
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/validating-core-oam-dev-v1beta1-approllout"
          }
        },
        "failurePolicy": "Ignore",
        "name": "validating.core.oam.dev.v1beta1.approllouts",
        "sideEffects": "None",
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1beta1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "approllouts"
            ],
            "scope": "Namespaced"
          }
        ],
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "timeoutSeconds": 5
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/validating-core-oam-dev-v1alpha2-traitdefinitions"
          }
        },
        "failurePolicy": "Ignore",
        "name": "validating.core.oam.dev.v1alpha2.traitdefinitions",
        "sideEffects": "None",
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1alpha2"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "traitdefinitions"
            ],
            "scope": "Cluster"
          }
        ],
        "timeoutSeconds": 5
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/validate-standard-oam-dev-v1alpha1-podspecworkload"
          }
        },
        "failurePolicy": "Fail",
        "name": "vcontainerized.kb.io",
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "sideEffects": "None",
        "rules": [
          {
            "apiGroups": [
              "standard.oam.dev"
            ],
            "apiVersions": [
              "v1alpha1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "podspecworkloads"
            ]
          }
        ]
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/validating-core-oam-dev-v1beta1-applications"
          }
        },
        "failurePolicy": "Ignore",
        "name": "validating.core.oam.dev.v1beta1.applications",
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "sideEffects": "None",
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1beta1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "applications"
            ]
          }
        ]
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/validating-core-oam-dev-v1beta1-componentdefinitions"
          }
        },
        "failurePolicy": "Ignore",
        "name": "validating.core.oam-dev.v1beta1.componentdefinitions",
        "sideEffects": "None",
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1beta1"
            ],
            "operations": [
              "CREATE",
              "UPDATE"
            ],
            "resources": [
              "componentdefinitions"
            ]
          }
        ]
      },
      {
        "clientConfig": {
          "caBundle": "Cg==",
          "service": {
            "name": "vela-core-legacy-webhook",
            "namespace": "default",
            "path": "/validating-core-oam-dev-v1beta1-initializers"
          }
        },
        "failurePolicy": "Ignore",
        "name": "validating.core.oam-dev.v1beta1.initializers",
        "sideEffects": "None",
        "admissionReviewVersions": [
          "v1beta1",
          "v1"
        ],
        "rules": [
          {
            "apiGroups": [
              "core.oam.dev"
            ],
            "apiVersions": [
              "v1beta1"
            ],
            "operations": [
              "CREATE",
              "UPDATE",
              "DELETE"
            ],
            "resources": [
              "initializers"
            ]
          }
        ]
      }
    ]
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Apply components of an application in parallel for your workflow steps"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "apply-application-in-parallel",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\noutput: op.#ApplyApplicationInParallel & {}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Apply application for your workflow steps"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "apply-application",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\n// apply application\noutput: op.#ApplyApplication & {}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Apply raw kubernetes objects for your workflow steps"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "apply-object",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\napply: op.#Apply & {\n\tvalue:   parameter.value\n\tcluster: parameter.cluster\n}\nparameter: {\n\t// +usage=Specify the value of the object\n\tvalue: {...}\n\t// +usage=Specify the cluster of the object\n\tcluster: *\"\" | string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Apply remaining components and traits"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "apply-remaining",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\n// apply remaining components and traits\napply: op.#ApplyRemaining & {\n\tparameter\n}\nparameter: {\n\t// +usage=Declare the name of the component\n\texceptions?: [...string]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "check or install depends-on Application"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "depends-on-app",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n\t\"encoding/yaml\"\n)\n\ndependsOn: op.#Read & {\n\tvalue: {\n\t\tapiVersion: \"core.oam.dev/v1beta1\"\n\t\tkind:       \"Application\"\n\t\tmetadata: {\n\t\t\tname:      parameter.name\n\t\t\tnamespace: parameter.namespace\n\t\t}\n\t}\n}\nload: op.#Steps & {\n\tif dependsOn.err != _|_ {\n\t\tconfigMap: op.#Read & {\n\t\t\tvalue: {\n\t\t\t\tapiVersion: \"v1\"\n\t\t\t\tkind:       \"ConfigMap\"\n\t\t\t\tmetadata: {\n\t\t\t\t\tname:      parameter.name\n\t\t\t\t\tnamespace: parameter.namespace\n\t\t\t\t}\n\t\t\t}\n\t\t}         @step(1)\n\t\ttemplate: configMap.value.data[\"application\"]\n\t\tapply:    op.#Apply & {\n\t\t\tvalue: yaml.Unmarshal(template)\n\t\t}     @step(2)\n\t\twait: op.#ConditionalWait & {\n\t\t\tcontinue: apply.value.status.status == \"running\"\n\t\t} @step(3)\n\t}\n\n\tif dependsOn.err == _|_ {\n\t\twait: op.#ConditionalWait & {\n\t\t\tcontinue: dependsOn.value.status.status == \"running\"\n\t\t}\n\t}\n}\nparameter: {\n\t// +usage=Specify the name of the dependent Application\n\tname: string\n\t// +usage=Specify the namespace of the dependent Application\n\tnamespace: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Deploy cloud resource and bind secret to clusters"
      },
      "name": "deploy-cloud-resource",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\napp: op.#DeployCloudResource & {\n\tenv:    parameter.env\n\tpolicy: parameter.policy\n\t// context.namespace indicates the namespace of the app\n\tnamespace: context.namespace\n\t// context.namespace indicates the name of the app\n\tname: context.name\n}\nparameter: {\n\t// +usage=Declare the name of the env-binding policy, if empty, the first env-binding policy will be used\n\tpolicy: *\"\" | string\n\t// +usage=Declare the name of the env in policy\n\tenv: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Deploy components with policies."
      },
      "name": "deploy",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\ndeploy: op.#Deploy & {\n\tpolicies:                 parameter.policies\n\tparallelism:              parameter.parallelism\n\tignoreTerraformComponent: parameter.ignoreTerraformComponent\n}\nparameter: {\n\t//+usage=If set false, the workflow will be suspend before this step.\n\tauto: *true | bool\n\t//+usage=Declare the policies used for this step.\n\tpolicies?: [...string]\n\t//+usage=Maximum number of concurrent delivered components.\n\tparallelism: *5 | int\n\t//+usage=If set false, this step will apply the components with the terraform workload.\n\tignoreTerraformComponent: *true | bool\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Deploy env binding component to target env"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "deploy2env",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\napp: op.#ApplyEnvBindApp & {\n\tenv:      parameter.env\n\tpolicy:   parameter.policy\n\tparallel: parameter.parallel\n\tapp:      context.name\n\t// context.namespace indicates the namespace of the app\n\tnamespace: context.namespace\n}\nparameter: {\n\t// +usage=Declare the name of the env-binding policy, if empty, the first env-binding policy will be used\n\tpolicy: *\"\" | string\n\t// +usage=Declare the name of the env in policy\n\tenv: string\n\t// +usage=components are applied in parallel\n\tparallel: *false | bool\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Deploy application to runtime clusters"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "deploy2runtime",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\napp: op.#Steps & {\n\tload: op.#Load @step(1)\n\tclusters: [...string]\n\tif parameter.clusters == _|_ {\n\t\tlistClusters: op.#ListClusters @step(2)\n\t\tclusters:     listClusters.outputs.clusters\n\t}\n\tif parameter.clusters != _|_ {\n\t\tclusters: parameter.clusters\n\t}\n\n\tapply: op.#Steps & {\n\t\tfor _, cluster_ in clusters {\n\t\t\tfor name, c in load.value {\n\t\t\t\t\"\\(cluster_)-\\(name)\": op.#ApplyComponent & {\n\t\t\t\t\tvalue:   c\n\t\t\t\t\tcluster: cluster_\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} @step(3)\n}\nparameter: {\n\t// +usage=Declare the runtime clusters to apply, if empty, all runtime clusters will be used\n\tclusters?: [...string]\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Export data to config map for your workflow steps"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "export2config",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\napply: op.#Apply & {\n\tvalue: {\n\t\tapiVersion: \"v1\"\n\t\tkind:       \"ConfigMap\"\n\t\tmetadata: {\n\t\t\tname: parameter.configName\n\t\t\tif parameter.namespace != _|_ {\n\t\t\t\tnamespace: parameter.namespace\n\t\t\t}\n\t\t\tif parameter.namespace == _|_ {\n\t\t\t\tnamespace: context.namespace\n\t\t\t}\n\t\t}\n\t\tdata: parameter.data\n\t}\n\tcluster: parameter.cluster\n}\nparameter: {\n\t// +usage=Specify the name of the config map\n\tconfigName: string\n\t// +usage=Specify the namespace of the config map\n\tnamespace?: string\n\t// +usage=Specify the data of config map\n\tdata: {}\n\t// +usage=Specify the cluster of the config map\n\tcluster: *\"\" | string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Export data to secret for your workflow steps"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "export2secret",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\napply: op.#Apply & {\n\tvalue: {\n\t\tapiVersion: \"v1\"\n\t\tkind:       \"Secret\"\n\t\tif parameter.type != _|_ {\n\t\t\ttype: parameter.type\n\t\t}\n\t\tmetadata: {\n\t\t\tname: parameter.secretName\n\t\t\tif parameter.namespace != _|_ {\n\t\t\t\tnamespace: parameter.namespace\n\t\t\t}\n\t\t\tif parameter.namespace == _|_ {\n\t\t\t\tnamespace: context.namespace\n\t\t\t}\n\t\t}\n\t\tstringData: parameter.data\n\t}\n\tcluster: parameter.cluster\n}\nparameter: {\n\t// +usage=Specify the name of the secret\n\tsecretName: string\n\t// +usage=Specify the namespace of the secret\n\tnamespace?: string\n\t// +usage=Specify the type of the secret\n\ttype?: string\n\t// +usage=Specify the data of secret\n\tdata: {}\n\t// +usage=Specify the cluster of the config map\n\tcluster: *\"\" | string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Generate a JDBC connection based on Component of alibaba-rds"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "generate-jdbc-connection",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n\t\"encoding/base64\"\n)\n\noutput: op.#Read & {\n\tvalue: {\n\t\tapiVersion: \"v1\"\n\t\tkind:       \"Secret\"\n\t\tmetadata: {\n\t\t\tname: parameter.name\n\t\t\tif parameter.namespace != _|_ {\n\t\t\t\tnamespace: parameter.namespace\n\t\t\t}\n\t\t}\n\t}\n}\ndbHost:   op.#ConvertString & {bt: base64.Decode(null, output.value.data[\"DB_HOST\"])}\ndbPort:   op.#ConvertString & {bt: base64.Decode(null, output.value.data[\"DB_PORT\"])}\ndbName:   op.#ConvertString & {bt: base64.Decode(null, output.value.data[\"DB_NAME\"])}\nusername: op.#ConvertString & {bt: base64.Decode(null, output.value.data[\"DB_USER\"])}\npassword: op.#ConvertString & {bt: base64.Decode(null, output.value.data[\"DB_PASSWORD\"])}\nenv: [\n\t{name: \"url\", value:      \"jdbc://\" + dbHost.str + \":\" + dbPort.str + \"/\" + dbName.str + \"?characterEncoding=utf8&useSSL=false\"},\n\t{name: \"username\", value: username.str},\n\t{name: \"password\", value: password.str},\n]\nparameter: {\n\t// +usage=Specify the name of the secret generated by database component\n\tname: string\n\t// +usage=Specify the namespace of the secret generated by database component\n\tnamespace?: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Send message to webhook"
      },
      "name": "notification",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n\t\"encoding/base64\"\n)\n\nparameter: {\n\tlark?: {\n\t\t// +usage=Specify the the lark url, you can either sepcify it in value or use secretRef\n\t\turl: {\n\t\t\tvalue: string\n\t\t} | {\n\t\t\tsecretRef: {\n\t\t\t\t// +usage=name is the name of the secret\n\t\t\t\tname: string\n\t\t\t\t// +usage=key is the key in the secret\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t\t// +useage=Specify the message that you want to sent\n\t\tmessage: {\n\t\t\t// +usage=msg_type can be text, post, image, interactive, share_chat, share_user, audio, media, file, sticker\n\t\t\tmsg_type: string\n\t\t\t// +usage=content should be json encode string\n\t\t\tcontent: string\n\t\t}\n\t}\n\n\tdingding?: {\n\t\t// +usage=Specify the the dingding url, you can either sepcify it in value or use secretRef\n\t\turl: {\n\t\t\tvalue: string\n\t\t} | {\n\t\t\tsecretRef: {\n\t\t\t\t// +usage=name is the name of the secret\n\t\t\t\tname: string\n\t\t\t\t// +usage=key is the key in the secret\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t\t// +useage=Specify the message that you want to sent\n\t\tmessage: {\n\t\t\ttext?: *null | {\n\t\t\t\tcontent: string\n\t\t\t}\n\t\t\t// +usage=msgType can be text, link, mardown, actionCard, feedCard\n\t\t\tmsgtype: *\"text\" | \"link\" | \"markdown\" | \"actionCard\" | \"feedCard\"\n\t\t\tlink?:   *null | {\n\t\t\t\ttext?:       string\n\t\t\t\ttitle?:      string\n\t\t\t\tmessageUrl?: string\n\t\t\t\tpicUrl?:     string\n\t\t\t}\n\t\t\tmarkdown?: *null | {\n\t\t\t\ttext:  string\n\t\t\t\ttitle: string\n\t\t\t}\n\t\t\tat?: *null | {\n\t\t\t\tatMobiles?: *null | [...string]\n\t\t\t\tisAtAll?:   bool\n\t\t\t}\n\t\t\tactionCard?: *null | {\n\t\t\t\ttext:           string\n\t\t\t\ttitle:          string\n\t\t\t\thideAvatar:     string\n\t\t\t\tbtnOrientation: string\n\t\t\t\tsingleTitle:    string\n\t\t\t\tsingleURL:      string\n\t\t\t\tbtns:           *null | [...*null | {\n\t\t\t\t\ttitle:     string\n\t\t\t\t\tactionURL: string\n\t\t\t\t}]\n\t\t\t}\n\t\t\tfeedCard?: *null | {\n\t\t\t\tlinks: *null | [...*null | {\n\t\t\t\t\ttext?:       string\n\t\t\t\t\ttitle?:      string\n\t\t\t\t\tmessageUrl?: string\n\t\t\t\t\tpicUrl?:     string\n\t\t\t\t}]\n\t\t\t}\n\t\t}\n\t}\n\n\tslack?: {\n\t\t// +usage=Specify the the slack url, you can either sepcify it in value or use secretRef\n\t\turl: {\n\t\t\tvalue: string\n\t\t} | {\n\t\t\tsecretRef: {\n\t\t\t\t// +usage=name is the name of the secret\n\t\t\t\tname: string\n\t\t\t\t// +usage=key is the key in the secret\n\t\t\t\tkey: string\n\t\t\t}\n\t\t}\n\t\t// +useage=Specify the message that you want to sent\n\t\tmessage: {\n\t\t\ttext:         string\n\t\t\tblocks?:      *null | [...block]\n\t\t\tattachments?: *null | {\n\t\t\t\tblocks?: *null | [...block]\n\t\t\t\tcolor?:  string\n\t\t\t}\n\t\t\tthread_ts?: string\n\t\t\tmrkdwn?:    *true | bool\n\t\t}\n\t}\n\n\temail?: {\n\t\t// +usage=Specify the email info that you want to send from\n\t\tfrom: {\n\t\t\t// +usage=Specify the email address that you want to send from\n\t\t\taddress: string\n\t\t\t// +usage=The alias is the email alias to show after sending the email\n\t\t\talias?: string\n\t\t\t// +usage=Specify the password of the email, you can either sepcify it in value or use secretRef\n\t\t\tpassword: {\n\t\t\t\tvalue: string\n\t\t\t} | {\n\t\t\t\tsecretRef: {\n\t\t\t\t\t// +usage=name is the name of the secret\n\t\t\t\t\tname: string\n\t\t\t\t\t// +usage=key is the key in the secret\n\t\t\t\t\tkey: string\n\t\t\t\t}\n\t\t\t}\n\t\t\t// +usage=Specify the host of your email\n\t\t\thost: string\n\t\t\t// +usage=Specify the port of the email host, default to 587\n\t\t\tport: *587 | int\n\t\t}\n\t\t// +usage=Specify the email address that you want to send to\n\t\tto: [...string]\n\t\t// +usage=Specify the content of the email\n\t\tcontent: {\n\t\t\t// +usage=Specify the subject of the email\n\t\t\tsubject: string\n\t\t\t// +usage=Specify the context body of the email\n\t\t\tbody: string\n\t\t}\n\t}\n}\nblock: {\n\ttype:      string\n\tblock_id?: string\n\telements?: [...{\n\t\ttype:       string\n\t\taction_id?: string\n\t\turl?:       string\n\t\tvalue?:     string\n\t\tstyle?:     string\n\t\ttext?:      textType\n\t\tconfirm?: {\n\t\t\ttitle:   textType\n\t\t\ttext:    textType\n\t\t\tconfirm: textType\n\t\t\tdeny:    textType\n\t\t\tstyle?:  string\n\t\t}\n\t\toptions?: [...option]\n\t\tinitial_options?: [...option]\n\t\tplaceholder?:  textType\n\t\tinitial_date?: string\n\t\timage_url?:    string\n\t\talt_text?:     string\n\t\toption_groups?: [...option]\n\t\tmax_selected_items?: int\n\t\tinitial_value?:      string\n\t\tmultiline?:          bool\n\t\tmin_length?:         int\n\t\tmax_length?:         int\n\t\tdispatch_action_config?: trigger_actions_on?: [...string]\n\t\tinitial_time?: string\n\t}]\n}\ntextType: {\n\ttype:      string\n\ttext:      string\n\temoji?:    bool\n\tverbatim?: bool\n}\noption: {\n\ttext:         textType\n\tvalue:        string\n\tdescription?: textType\n\turl?:         string\n}\n// send webhook notification\nding: op.#Steps & {\n\tif parameter.dingding != _|_ {\n\t\tif parameter.dingding.url.value != _|_ {\n\t\t\tding1: op.#DingTalk & {\n\t\t\t\tmessage: parameter.dingding.message\n\t\t\t\tdingUrl: parameter.dingding.url.value\n\t\t\t}\n\t\t}\n\t\tif parameter.dingding.url.secretRef != _|_ && parameter.dingding.url.value == _|_ {\n\t\t\tread: op.#Read & {\n\t\t\t\tvalue: {\n\t\t\t\t\tapiVersion: \"v1\"\n\t\t\t\t\tkind:       \"Secret\"\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tname:      parameter.dingding.url.secretRef.name\n\t\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded:     base64.Decode(null, read.value.data[parameter.dingding.url.secretRef.key])\n\t\t\tstringValue: op.#ConvertString & {bt: decoded}\n\t\t\tding2:       op.#DingTalk & {\n\t\t\t\tmessage: parameter.dingding.message\n\t\t\t\tdingUrl: stringValue.str\n\t\t\t}\n\t\t}\n\t}\n}\nlark: op.#Steps & {\n\tif parameter.lark != _|_ {\n\t\tif parameter.lark.url.value != _|_ {\n\t\t\tlark1: op.#Lark & {\n\t\t\t\tmessage: parameter.lark.message\n\t\t\t\tlarkUrl: parameter.lark.url.value\n\t\t\t}\n\t\t}\n\t\tif parameter.lark.url.secretRef != _|_ && parameter.lark.url.value == _|_ {\n\t\t\tread: op.#Read & {\n\t\t\t\tvalue: {\n\t\t\t\t\tapiVersion: \"v1\"\n\t\t\t\t\tkind:       \"Secret\"\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tname:      parameter.lark.url.secretRef.name\n\t\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded:     base64.Decode(null, read.value.data[parameter.lark.url.secretRef.key])\n\t\t\tstringValue: op.#ConvertString & {bt: decoded}\n\t\t\tlark2:       op.#Lark & {\n\t\t\t\tmessage: parameter.lark.message\n\t\t\t\tlarkUrl: stringValue.str\n\t\t\t}\n\t\t}\n\t}\n}\nslack: op.#Steps & {\n\tif parameter.slack != _|_ {\n\t\tif parameter.slack.url.value != _|_ {\n\t\t\tslack1: op.#Slack & {\n\t\t\t\tmessage:  parameter.slack.message\n\t\t\t\tslackUrl: parameter.slack.url.value\n\t\t\t}\n\t\t}\n\t\tif parameter.slack.url.secretRef != _|_ && parameter.slack.url.value == _|_ {\n\t\t\tread: op.#Read & {\n\t\t\t\tvalue: {\n\t\t\t\t\tkind:       \"Secret\"\n\t\t\t\t\tapiVersion: \"v1\"\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tname:      parameter.slack.url.secretRef.name\n\t\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded:     base64.Decode(null, read.value.data[parameter.slack.url.secretRef.key])\n\t\t\tstringValue: op.#ConvertString & {bt: decoded}\n\t\t\tslack2:      op.#Slack & {\n\t\t\t\tmessage:  parameter.slack.message\n\t\t\t\tslackUrl: stringValue.str\n\t\t\t}\n\t\t}\n\t}\n}\nemail: op.#Steps & {\n\tif parameter.email != _|_ {\n\t\tif parameter.email.from.password.value != _|_ {\n\t\t\temail1: op.#SendEmail & {\n\t\t\t\tfrom: {\n\t\t\t\t\taddress: parameter.email.from.address\n\t\t\t\t\tif parameter.email.from.alias != _|_ {\n\t\t\t\t\t\talias: parameter.email.from.alias\n\t\t\t\t\t}\n\t\t\t\t\tpassword: parameter.email.from.password.value\n\t\t\t\t\thost:     parameter.email.from.host\n\t\t\t\t\tport:     parameter.email.from.port\n\t\t\t\t}\n\t\t\t\tto:      parameter.email.to\n\t\t\t\tcontent: parameter.email.content\n\t\t\t}\n\t\t}\n\n\t\tif parameter.email.from.password.secretRef != _|_ && parameter.email.from.password.value == _|_ {\n\t\t\tread: op.#Read & {\n\t\t\t\tvalue: {\n\t\t\t\t\tkind:       \"Secret\"\n\t\t\t\t\tapiVersion: \"v1\"\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tname:      parameter.email.from.password.secretRef.name\n\t\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded:     base64.Decode(null, read.value.data[parameter.email.from.password.secretRef.key])\n\t\t\tstringValue: op.#ConvertString & {bt: decoded}\n\t\t\temail2:      op.#SendEmail & {\n\t\t\t\tfrom: {\n\t\t\t\t\taddress: parameter.email.from.address\n\t\t\t\t\tif parameter.email.from.alias != _|_ {\n\t\t\t\t\t\talias: parameter.email.from.alias\n\t\t\t\t\t}\n\t\t\t\t\tpassword: stringValue.str\n\t\t\t\t\thost:     parameter.email.from.host\n\t\t\t\t\tport:     parameter.email.from.port\n\t\t\t\t}\n\t\t\t\tto:      parameter.email.to\n\t\t\t\tcontent: parameter.email.content\n\t\t\t}\n\t\t}\n\t}\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Read objects for your workflow steps"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "read-object",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\noutput: {\n\tif parameter.apiVersion == _|_ && parameter.kind == _|_ {\n\t\top.#Read & {\n\t\t\tvalue: {\n\t\t\t\tapiVersion: \"core.oam.dev/v1beta1\"\n\t\t\t\tkind:       \"Application\"\n\t\t\t\tmetadata: {\n\t\t\t\t\tname: parameter.name\n\t\t\t\t\tif parameter.namespace != _|_ {\n\t\t\t\t\t\tnamespace: parameter.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcluster: parameter.cluster\n\t\t}\n\t}\n\tif parameter.apiVersion != _|_ || parameter.kind != _|_ {\n\t\top.#Read & {\n\t\t\tvalue: {\n\t\t\t\tapiVersion: parameter.apiVersion\n\t\t\t\tkind:       parameter.kind\n\t\t\t\tmetadata: {\n\t\t\t\t\tname: parameter.name\n\t\t\t\t\tif parameter.namespace != _|_ {\n\t\t\t\t\t\tnamespace: parameter.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcluster: parameter.cluster\n\t\t}\n\t}\n}\nparameter: {\n\t// +usage=Specify the apiVersion of the object, defaults to core.oam.dev/v1beta1\n\tapiVersion?: string\n\t// +usage=Specify the kind of the object, defaults to Application\n\tkind?: string\n\t// +usage=Specify the name of the object\n\tname: string\n\t// +usage=Specify the namespace of the object\n\tnamespace?: string\n\t// +usage=Specify the cluster of the object\n\tcluster: *\"\" | string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Sync secrets created by terraform component to runtime clusters so that runtime clusters can share the created cloud resource."
      },
      "name": "share-cloud-resource",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n)\n\napp: op.#ShareCloudResource & {\n\tenv:        parameter.env\n\tpolicy:     parameter.policy\n\tplacements: parameter.placements\n\t// context.namespace indicates the namespace of the app\n\tnamespace: context.namespace\n\t// context.namespace indicates the name of the app\n\tname: context.name\n}\nparameter: {\n\t// +usage=Declare the location to bind\n\tplacements: [...{\n\t\tnamespace?: string\n\t\tcluster?:   string\n\t}]\n\t// +usage=Declare the name of the env-binding policy, if empty, the first env-binding policy will be used\n\tpolicy: *\"\" | string\n\t// +usage=Declare the name of the env in policy\n\tenv: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "step group"
      },
      "labels": {
        "custom.definition.oam.dev/ui-hidden": "true"
      },
      "name": "step-group",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "// no parameters\nparameter: {}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Suspend your workflow"
      },
      "name": "suspend",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "parameter: {\n\t// +usage=Specify the wait duration time to resume workflow such as \"30s\", \"1min\" or \"2m15s\"\n\tduration?: string\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Send message to webhook. This definition is DEPRECATED, please use 'notification' instead."
      },
      "labels": {
        "custom.definition.oam.dev/deprecated": "true"
      },
      "name": "webhook-notification",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n\t\"encoding/base64\"\n)\n\nparameter: {\n\tdingding?: {\n\t\turl: value | secretRef\n\t\tmessage: {\n\t\t\ttext?: *null | {\n\t\t\t\tcontent: string\n\t\t\t}\n\t\t\t// +usage=msgType can be text, link, mardown, actionCard, feedCard\n\t\t\tmsgtype: string\n\t\t\tlink?:   *null | {\n\t\t\t\ttext?:       string\n\t\t\t\ttitle?:      string\n\t\t\t\tmessageUrl?: string\n\t\t\t\tpicUrl?:     string\n\t\t\t}\n\t\t\tmarkdown?: *null | {\n\t\t\t\ttext:  string\n\t\t\t\ttitle: string\n\t\t\t}\n\t\t\tat?: *null | {\n\t\t\t\tatMobiles?: *null | [...string]\n\t\t\t\tisAtAll?:   bool\n\t\t\t}\n\t\t\tactionCard?: *null | {\n\t\t\t\ttext:           string\n\t\t\t\ttitle:          string\n\t\t\t\thideAvatar:     string\n\t\t\t\tbtnOrientation: string\n\t\t\t\tsingleTitle:    string\n\t\t\t\tsingleURL:      string\n\t\t\t\tbtns:           *null | [...*null | {\n\t\t\t\t\ttitle:     string\n\t\t\t\t\tactionURL: string\n\t\t\t\t}]\n\t\t\t}\n\t\t\tfeedCard?: *null | {\n\t\t\t\tlinks: *null | [...*null | {\n\t\t\t\t\ttext?:       string\n\t\t\t\t\ttitle?:      string\n\t\t\t\t\tmessageUrl?: string\n\t\t\t\t\tpicUrl?:     string\n\t\t\t\t}]\n\t\t\t}\n\t\t}\n\t}\n\n\tslack?: {\n\t\turl: value | secretRef\n\t\tmessage: {\n\t\t\ttext:         string\n\t\t\tblocks?:      *null | [...block]\n\t\t\tattachments?: *null | {\n\t\t\t\tblocks?: *null | [...block]\n\t\t\t\tcolor?:  string\n\t\t\t}\n\t\t\tthread_ts?: string\n\t\t\tmrkdwn?:    *true | bool\n\t\t}\n\t}\n\n\temail?: {\n\t\tfrom: {\n\t\t\taddress:  string\n\t\t\talias?:   string\n\t\t\tpassword: value | secretRef\n\t\t\thost:     string\n\t\t\tport:     *587 | int\n\t\t}\n\t\tto: [...string]\n\t\tcontent: {\n\t\t\tsubject: string\n\t\t\tbody:    string\n\t\t}\n\t}\n}\nblock: {\n\ttype:      string\n\tblock_id?: string\n\telements?: [...{\n\t\ttype:       string\n\t\taction_id?: string\n\t\turl?:       string\n\t\tvalue?:     string\n\t\tstyle?:     string\n\t\ttext?:      textType\n\t\tconfirm?: {\n\t\t\ttitle:   textType\n\t\t\ttext:    textType\n\t\t\tconfirm: textType\n\t\t\tdeny:    textType\n\t\t\tstyle?:  string\n\t\t}\n\t\toptions?: [...option]\n\t\tinitial_options?: [...option]\n\t\tplaceholder?:  textType\n\t\tinitial_date?: string\n\t\timage_url?:    string\n\t\talt_text?:     string\n\t\toption_groups?: [...option]\n\t\tmax_selected_items?: int\n\t\tinitial_value?:      string\n\t\tmultiline?:          bool\n\t\tmin_length?:         int\n\t\tmax_length?:         int\n\t\tdispatch_action_config?: trigger_actions_on?: [...string]\n\t\tinitial_time?: string\n\t}]\n}\ntextType: {\n\ttype:      string\n\ttext:      string\n\temoji?:    bool\n\tverbatim?: bool\n}\noption: {\n\ttext:         textType\n\tvalue:        string\n\tdescription?: textType\n\turl?:         string\n}\nsecretRef: {\n\tname: string\n\tkey:  string\n}\nvalue: string\n// send webhook notification\nding: op.#Steps & {\n\tif parameter.dingding != _|_ {\n\t\tif parameter.dingding.url.value != _|_ {\n\t\t\tding1: op.#DingTalk & {\n\t\t\t\tmessage: parameter.dingding.message\n\t\t\t\tdingUrl: parameter.dingding.url.value\n\t\t\t}\n\t\t}\n\t\tif parameter.dingding.url.secretRef != _|_ && parameter.dingding.url.value == _|_ {\n\t\t\tread: op.#Read & {\n\t\t\t\tvalue: {\n\t\t\t\t\tapiVersion: \"v1\"\n\t\t\t\t\tkind:       \"Secret\"\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tname:      parameter.dingding.url.secretRef.name\n\t\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded:     base64.Decode(null, read.value.data[parameter.dingding.url.secretRef.key])\n\t\t\tstringValue: op.#ConvertString & {bt: decoded}\n\t\t\tding2:       op.#DingTalk & {\n\t\t\t\tmessage: parameter.dingding.message\n\t\t\t\tdingUrl: stringValue.str\n\t\t\t}\n\t\t}\n\t}\n}\nslack: op.#Steps & {\n\tif parameter.slack != _|_ {\n\t\tif parameter.slack.url.value != _|_ {\n\t\t\tslack1: op.#Slack & {\n\t\t\t\tmessage:  parameter.slack.message\n\t\t\t\tslackUrl: parameter.slack.url.value\n\t\t\t}\n\t\t}\n\t\tif parameter.slack.url.secretRef != _|_ && parameter.slack.url.value == _|_ {\n\t\t\tread: op.#Read & {\n\t\t\t\tvalue: {\n\t\t\t\t\tkind:       \"Secret\"\n\t\t\t\t\tapiVersion: \"v1\"\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tname:      parameter.slack.url.secretRef.name\n\t\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded:     base64.Decode(null, read.value.data[parameter.slack.url.secretRef.key])\n\t\t\tstringValue: op.#ConvertString & {bt: decoded}\n\t\t\tslack2:      op.#Slack & {\n\t\t\t\tmessage:  parameter.slack.message\n\t\t\t\tslackUrl: stringValue.str\n\t\t\t}\n\t\t}\n\t}\n}\nemail: op.#Steps & {\n\tif parameter.email != _|_ {\n\t\tif parameter.email.from.password.value != _|_ {\n\t\t\temail1: op.#SendEmail & {\n\t\t\t\tfrom: {\n\t\t\t\t\taddress:  parameter.email.from.value\n\t\t\t\t\talias:    parameter.email.from.alias\n\t\t\t\t\tpassword: parameter.email.from.password.value\n\t\t\t\t\thost:     parameter.email.from.host\n\t\t\t\t\tport:     parameter.email.from.port\n\t\t\t\t}\n\t\t\t\tto:      parameter.email.to\n\t\t\t\tcontent: parameter.email.content\n\t\t\t}\n\t\t}\n\n\t\tif parameter.email.from.password.secretRef != _|_ && parameter.email.from.password.value == _|_ {\n\t\t\tread: op.#Read & {\n\t\t\t\tvalue: {\n\t\t\t\t\tkind:       \"Secret\"\n\t\t\t\t\tapiVersion: \"v1\"\n\t\t\t\t\tmetadata: {\n\t\t\t\t\t\tname:      parameter.email.from.password.secretRef.name\n\t\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdecoded:     base64.Decode(null, read.value.data[parameter.email.from.password.secretRef.key])\n\t\t\tstringValue: op.#ConvertString & {bt: decoded}\n\t\t\temail2:      op.#SendEmail & {\n\t\t\t\tfrom: {\n\t\t\t\t\taddress:  parameter.email.from.value\n\t\t\t\t\talias:    parameter.email.from.alias\n\t\t\t\t\tpassword: stringValue.str\n\t\t\t\t\thost:     parameter.email.from.host\n\t\t\t\t\tport:     parameter.email.from.port\n\t\t\t\t}\n\t\t\t\tto:      parameter.email.to\n\t\t\t\tcontent: parameter.email.content\n\t\t\t}\n\t\t}\n\t}\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkflowStepDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "Send webhook request to the url"
      },
      "name": "webhook",
      "namespace": "default"
    },
    "spec": {
      "schematic": {
        "cue": {
          "template": "import (\n\t\"vela/op\"\n\t\"encoding/json\"\n\t\"encoding/base64\"\n)\n\ndata: op.#Steps & {\n\tif parameter.data == _|_ {\n\t\tread: op.#Read & {\n\t\t\tvalue: {\n\t\t\t\tapiVersion: \"core.oam.dev/v1beta1\"\n\t\t\t\tkind:       \"Application\"\n\t\t\t\tmetadata: {\n\t\t\t\t\tname:      context.name\n\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t}\n\t\t\t}\n\t\t}      @step(1)\n\t\tvalue: json.Marshal(read.value) @step(2)\n\t}\n\tif parameter.data != _|_ {\n\t\tvalue: json.Marshal(parameter.data) @step(3)\n\t}\n}\nwebhook: op.#Steps & {\n\tif parameter.url.value != _|_ {\n\t\thttp: op.#HTTPPost & {\n\t\t\turl: parameter.url.value\n\t\t\trequest: {\n\t\t\t\tbody: data.value\n\t\t\t\theader: \"Content-Type\": \"application/json\"\n\t\t\t}\n\t\t} @step(4)\n\t}\n\tif parameter.url.secretRef != _|_ && parameter.url.value == _|_ {\n\t\tread: op.#Read & {\n\t\t\tvalue: {\n\t\t\t\tapiVersion: \"v1\"\n\t\t\t\tkind:       \"Secret\"\n\t\t\t\tmetadata: {\n\t\t\t\t\tname:      parameter.url.secretRef.name\n\t\t\t\t\tnamespace: context.namespace\n\t\t\t\t}\n\t\t\t}\n\t\t} @step(5)\n\n\t\tdecoded:     base64.Decode(null, read.value.data[parameter.url.secretRef.key]) @step(6)\n\t\tstringValue: op.#ConvertString & {bt:                                          decoded} @step(7)\n\t\thttp:        op.#HTTPPost & {\n\t\t\turl: stringValue.str\n\t\t\trequest: {\n\t\t\t\tbody: data.value\n\t\t\t\theader: \"Content-Type\": \"application/json\"\n\t\t\t}\n\t\t} @step(8)\n\t}\n}\nparameter: {\n\t// +usage=Specify the webhook url\n\turl: {\n\t\tvalue: string\n\t} | {\n\t\tsecretRef: {\n\t\t\t// +usage=name is the name of the secret\n\t\t\tname: string\n\t\t\t// +usage=key is the key in the secret\n\t\t\tkey: string\n\t\t}\n\t}\n\t// +usage=Specify the data you want to send\n\tdata?: {...}\n}\n"
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "WorkloadDefinition",
    "metadata": {
      "annotations": {
        "definition.oam.dev/description": "autodetects.core.oam.dev is the default workload type of ComponentDefinition"
      },
      "name": "autodetects.core.oam.dev",
      "namespace": "default"
    },
    "spec": {
      "definitionRef": {
        "name": "autodetects.core.oam.dev"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "release-name-vela-core-legacy-cluster-gateway-admission",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-cluster-gateway-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    }
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "ClusterRole",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          "admissionregistration.k8s.io"
        ],
        "resources": [
          "validatingwebhookconfigurations",
          "mutatingwebhookconfigurations"
        ],
        "verbs": [
          "get",
          "update"
        ]
      },
      {
        "apiGroups": [
          "apiextensions.k8s.io"
        ],
        "resources": [
          "customresourcedefinitions"
        ],
        "verbs": [
          "get",
          "update"
        ]
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "ClusterRoleBinding",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "ClusterRole",
      "name": "release-name-vela-core-legacy-admission"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-vela-core-legacy-admission",
        "namespace": "default"
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "Role",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "secrets"
        ],
        "verbs": [
          "get",
          "create"
        ]
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "Role",
    "metadata": {
      "name": "release-name-vela-core-legacy-cluster-gateway-admission",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-cluster-gateway-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "secrets"
        ],
        "verbs": [
          "get",
          "create"
        ]
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "Role",
      "name": "release-name-vela-core-legacy-admission"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-vela-core-legacy-admission",
        "namespace": "default"
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
      "name": "release-name-vela-core-legacy-cluster-gateway-admission",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade,post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-cluster-gateway-admission",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "Role",
      "name": "release-name-vela-core-legacy-cluster-gateway-admission"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-vela-core-legacy-cluster-gateway-admission",
        "namespace": "default"
      }
    ]
  },
  {
    "apiVersion": "v1",
    "kind": "Pod",
    "metadata": {
      "name": "release-name-application-test",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "test",
        "helm.sh/hook-delete-policy": "hook-succeeded"
      }
    },
    "spec": {
      "serviceAccountName": "release-name-vela-core-legacy",
      "containers": [
        {
          "name": "release-name-application-test",
          "image": "oamdev/alpine-k8s:1.18.2",
          "imagePullPolicy": "IfNotPresent",
          "command": [
            "/bin/bash",
            "-ec",
            "\nset -e\n\necho \"Waiting application is ready...\"\n\necho \"waiting for application being Ready\"\nkubectl -n default wait --for=condition=Ready applications.core.oam.dev helm-test-vela-app --timeout=3m\necho \"application is Ready\"\n\n# wait for deploy being created\necho \"waiting for deployment being available\"\nkubectl -n default wait --for=condition=available deployments helm-test-express-server --timeout 3m\necho \"deployment being available\"\n\n# wait for ingress being created\nwhile ! [ `kubectl -n default get ing helm-test-express-server | grep -v NAME | wc -l` = 1 ]; do\n  echo \"waiting for ingress being created\"\n  sleep 1\ndone\n\n\n\necho \"Application and its components are created\"\n"
          ]
        }
      ],
      "restartPolicy": "Never"
    }
  },
  {
    "apiVersion": "batch/v1",
    "kind": "Job",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission-create",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-admission-create",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "template": {
        "metadata": {
          "name": "release-name-vela-core-legacy-admission-create",
          "labels": {
            "app": "vela-core-legacy-admission-create",
            "helm.sh/chart": "vela-core-legacy-1.4.1",
            "app.kubernetes.io/name": "vela-core-legacy",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/version": "1.4.1",
            "app.kubernetes.io/managed-by": "Helm"
          }
        },
        "spec": {
          "containers": [
            {
              "name": "create",
              "image": "oamdev/kube-webhook-certgen:v2.4.0",
              "imagePullPolicy": "IfNotPresent",
              "args": [
                "create",
                "--host=vela-core-legacy-webhook,vela-core-legacy-webhook.default.svc",
                "--namespace=default",
                "--secret-name=release-name-vela-core-legacy-admission",
                "--key-name=tls.key",
                "--cert-name=tls.crt"
              ]
            }
          ],
          "restartPolicy": "OnFailure",
          "serviceAccountName": "release-name-vela-core-legacy-admission",
          "securityContext": {
            "runAsGroup": 2000,
            "runAsNonRoot": true,
            "runAsUser": 2000
          }
        }
      }
    }
  },
  {
    "apiVersion": "batch/v1",
    "kind": "Job",
    "metadata": {
      "name": "release-name-vela-core-legacy-admission-patch",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "vela-core-legacy-admission-patch",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "template": {
        "metadata": {
          "name": "release-name-vela-core-legacy-admission-patch",
          "labels": {
            "app": "vela-core-legacy-admission-patch",
            "helm.sh/chart": "vela-core-legacy-1.4.1",
            "app.kubernetes.io/name": "vela-core-legacy",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/version": "1.4.1",
            "app.kubernetes.io/managed-by": "Helm"
          }
        },
        "spec": {
          "containers": [
            {
              "name": "patch",
              "image": "oamdev/kube-webhook-certgen:v2.4.0",
              "imagePullPolicy": "IfNotPresent",
              "args": [
                "patch",
                "--webhook-name=release-name-vela-core-legacy-admission",
                "--namespace=default",
                "--secret-name=release-name-vela-core-legacy-admission",
                "--patch-failure-policy=Fail"
              ]
            }
          ],
          "restartPolicy": "OnFailure",
          "serviceAccountName": "release-name-vela-core-legacy-admission",
          "securityContext": {
            "runAsGroup": 2000,
            "runAsNonRoot": true,
            "runAsUser": 2000
          }
        }
      }
    }
  },
  {
    "apiVersion": "batch/v1",
    "kind": "Job",
    "metadata": {
      "name": "release-name-vela-core-legacy-cluster-gateway-tls-secret-create",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "pre-install,pre-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "release-name-vela-core-legacy-cluster-gateway-tls-secret-create",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "template": {
        "metadata": {
          "name": "release-name-vela-core-legacy-cluster-gateway-tls-secret-create",
          "labels": {
            "app": "release-name-vela-core-legacy-cluster-gateway-tls-secret-create",
            "helm.sh/chart": "vela-core-legacy-1.4.1",
            "app.kubernetes.io/name": "vela-core-legacy",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/version": "1.4.1",
            "app.kubernetes.io/managed-by": "Helm"
          }
        },
        "spec": {
          "containers": [
            {
              "name": "create",
              "image": "oamdev/kube-webhook-certgen:v2.4.0",
              "imagePullPolicy": "IfNotPresent",
              "args": [
                "create",
                "--host=release-name-cluster-gateway-service,release-name-cluster-gateway-service.default.svc",
                "--namespace=default",
                "--secret-name=release-name-vela-core-legacy-cluster-gateway-tls-v2",
                "--cert-name=tls.crt",
                "--key-name=tls.key"
              ]
            }
          ],
          "restartPolicy": "OnFailure",
          "serviceAccountName": "release-name-vela-core-legacy-cluster-gateway-admission",
          "securityContext": {
            "runAsGroup": 2000,
            "runAsNonRoot": true,
            "runAsUser": 2000
          }
        }
      }
    }
  },
  {
    "apiVersion": "batch/v1",
    "kind": "Job",
    "metadata": {
      "name": "release-name-vela-core-legacy-cluster-gateway-tls-secret-patch",
      "namespace": "lqgAXnRcu",
      "annotations": {
        "helm.sh/hook": "post-install,post-upgrade",
        "helm.sh/hook-delete-policy": "before-hook-creation,hook-succeeded"
      },
      "labels": {
        "app": "release-name-vela-core-legacy-cluster-gateway-tls-secret-patch",
        "helm.sh/chart": "vela-core-legacy-1.4.1",
        "app.kubernetes.io/name": "vela-core-legacy",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "1.4.1",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "template": {
        "metadata": {
          "name": "release-name-vela-core-legacy-cluster-gateway-tls-secret-patch",
          "labels": {
            "app": "release-name-vela-core-legacy-cluster-gateway-tls-secret-patch",
            "helm.sh/chart": "vela-core-legacy-1.4.1",
            "app.kubernetes.io/name": "vela-core-legacy",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/version": "1.4.1",
            "app.kubernetes.io/managed-by": "Helm"
          }
        },
        "spec": {
          "containers": [
            {
              "name": "patch",
              "image": "oamdev/cluster-gateway:v1.4.0",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/patch"
              ],
              "args": [
                "--secret-namespace=default",
                "--secret-name=release-name-vela-core-legacy-cluster-gateway-tls-v2"
              ]
            }
          ],
          "restartPolicy": "OnFailure",
          "serviceAccountName": "release-name-vela-core-legacy",
          "securityContext": {
            "runAsGroup": 2000,
            "runAsNonRoot": true,
            "runAsUser": 2000
          }
        }
      }
    }
  },
  {
    "apiVersion": "core.oam.dev/v1beta1",
    "kind": "Application",
    "metadata": {
      "annotations": {
        "helm.sh/hook": "test-success",
        "helm.sh/hook-delete-policy": "hook-succeeded"
      },
      "name": "helm-test-vela-app",
      "namespace": "default"
    },
    "spec": {
      "components": [
        {
          "name": "helm-test-express-server",
          "type": "webservice",
          "properties": {
            "image": "oamdev/hello-world:v1",
            "port": 8000
          },
          "traits": [
            {
              "type": "ingress",
              "properties": {
                "domain": "testsvc.example.com",
                "http": {
                  "/": 8000
                }
              }
            }
          ]
        }
      ]
    }
  }
]