[
  {
    "apiVersion": "networking.k8s.io/v1",
    "kind": "NetworkPolicy",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "podSelector": {
        "matchLabels": {
          "component": "hub",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "policyTypes": [
        "Ingress",
        "Egress"
      ],
      "ingress": [
        {
          "ports": [
            {
              "port": "http"
            }
          ],
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-hub": "true"
                }
              }
            }
          ]
        }
      ],
      "egress": [
        {
          "ports": [
            {
              "port": 8001
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "component": "proxy",
                  "app": "jupyterhub",
                  "release": "release-name"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "port": 8888
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "component": "singleuser-server",
                  "app": "jupyterhub",
                  "release": "release-name"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 53
            },
            {
              "protocol": "TCP",
              "port": 53
            }
          ]
        },
        {
          "to": [
            {
              "ipBlock": {
                "cidr": "0.0.0.0/0"
              }
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "networking.k8s.io/v1",
    "kind": "NetworkPolicy",
    "metadata": {
      "name": "proxy",
      "labels": {
        "component": "proxy",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "podSelector": {
        "matchLabels": {
          "component": "proxy",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "policyTypes": [
        "Ingress",
        "Egress"
      ],
      "ingress": [
        {
          "ports": [
            {
              "port": "http"
            },
            {
              "port": "https"
            }
          ]
        },
        {
          "ports": [
            {
              "port": "http"
            }
          ],
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-proxy-http": "true"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "port": "api"
            }
          ],
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-proxy-api": "true"
                }
              }
            }
          ]
        }
      ],
      "egress": [
        {
          "ports": [
            {
              "port": 8081
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "component": "hub",
                  "app": "jupyterhub",
                  "release": "release-name"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "port": 8888
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "component": "singleuser-server",
                  "app": "jupyterhub",
                  "release": "release-name"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 53
            },
            {
              "protocol": "TCP",
              "port": 53
            }
          ]
        },
        {
          "to": [
            {
              "ipBlock": {
                "cidr": "0.0.0.0/0"
              }
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "networking.k8s.io/v1",
    "kind": "NetworkPolicy",
    "metadata": {
      "name": "singleuser",
      "labels": {
        "component": "singleuser",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "podSelector": {
        "matchLabels": {
          "component": "singleuser-server",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "policyTypes": [
        "Ingress",
        "Egress"
      ],
      "ingress": [
        {
          "ports": [
            {
              "port": "notebook-port"
            }
          ],
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-singleuser": "true"
                }
              }
            }
          ]
        }
      ],
      "egress": [
        {
          "ports": [
            {
              "port": 8081
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "component": "hub",
                  "app": "jupyterhub",
                  "release": "release-name"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 53
            },
            {
              "protocol": "TCP",
              "port": 53
            }
          ]
        },
        {
          "to": [
            {
              "ipBlock": {
                "cidr": "0.0.0.0/0",
                "except": [
                  "169.254.169.254/32"
                ]
              }
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodSecurityPolicy",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "default",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      },
      "annotations": {
        "seccomp.security.alpha.kubernetes.io/allowedProfileNames": "docker/default,runtime/default",
        "seccomp.security.alpha.kubernetes.io/defaultProfileName": "docker/default",
        "apparmor.security.beta.kubernetes.io/allowedProfileNames": "runtime/default",
        "apparmor.security.beta.kubernetes.io/defaultProfileName": "runtime/default"
      }
    },
    "spec": {
      "privileged": false,
      "allowPrivilegeEscalation": false,
      "requiredDropCapabilities": [
        "FOWNER",
        "FSETID",
        "KILL",
        "SETGID",
        "SETUID",
        "SETPCAP",
        "NET_BIND_SERVICE",
        "NET_RAW",
        "SYS_CHROOT",
        "MKNOD",
        "AUDIT_WRITE",
        "SETFCAP"
      ],
      "volumes": [
        "configMap",
        "emptyDir",
        "projected",
        "csi",
        "secret",
        "downwardAPI",
        "persistentVolumeClaim"
      ],
      "hostNetwork": false,
      "hostIPC": false,
      "hostPID": false,
      "runAsUser": {
        "rule": "RunAsAny"
      },
      "seLinux": {
        "rule": "RunAsAny"
      },
      "supplementalGroups": {
        "rule": "RunAsAny"
      },
      "fsGroup": {
        "rule": "RunAsAny"
      },
      "readOnlyRootFilesystem": false,
      "rule": "MustRunAsNonRoot"
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodSecurityPolicy",
    "metadata": {
      "name": "release-name-grafana-test",
      "namespace": "default",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "allowPrivilegeEscalation": true,
      "privileged": false,
      "hostNetwork": false,
      "hostIPC": false,
      "hostPID": false,
      "fsGroup": {
        "rule": "RunAsAny"
      },
      "seLinux": {
        "rule": "RunAsAny"
      },
      "supplementalGroups": {
        "rule": "RunAsAny"
      },
      "runAsUser": {
        "rule": "RunAsAny"
      },
      "volumes": [
        "configMap",
        "downwardAPI",
        "emptyDir",
        "projected",
        "csi",
        "secret"
      ],
      "rule": "MustRunAsNonRoot"
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodDisruptionBudget",
    "metadata": {
      "name": "user-placeholder",
      "labels": {
        "component": "user-placeholder",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "minAvailable": 0,
      "selector": {
        "matchLabels": {
          "component": "user-placeholder",
          "app": "jupyterhub",
          "release": "release-name"
        }
      }
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodDisruptionBudget",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "minAvailable": 1,
      "selector": {
        "matchLabels": {
          "component": "user-scheduler",
          "app": "jupyterhub",
          "release": "release-name"
        }
      }
    }
  },
  {
    "apiVersion": "policy/v1beta1",
    "kind": "PodDisruptionBudget",
    "metadata": {
      "name": "release-name-zookeeper",
      "namespace": "default",
      "labels": {
        "app.kubernetes.io/name": "zookeeper",
        "helm.sh/chart": "zookeeper-5.23.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "zookeeper"
      }
    },
    "spec": {
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "zookeeper",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "zookeeper"
        }
      },
      "maxUnavailable": 1
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      },
      "name": "release-name-grafana",
      "namespace": "qE6qSW8pmXLGc"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      },
      "name": "release-name-grafana-test",
      "namespace": "qE6qSW8pmXLGc"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "release-name-keycloa",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "keycloak",
        "helm.sh/chart": "keycloak-2.4.8",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "keycloak"
      }
    }
  },
  {
    "kind": "ServiceAccount",
    "apiVersion": "v1",
    "metadata": {
      "name": "release-name-traefik",
      "labels": {
        "app.kubernetes.io/name": "traefik",
        "helm.sh/chart": "traefik-10.6.2",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/instance": "release-name"
      },
      "annotations": null
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "type": "Opaque",
    "data": {
      "admin-user": "YWRtaW4=",
      "admin-password": "RERsNDlTZ2JDclFEREluRHQ1eEVFaEIzaDdKSlJ4bnJiOU1HM0k3YQ==",
      "ldap-toml": "dmVyYm9zZV9sb2dnaW5nID0gdHJ1ZQpbW3NlcnZlcnNdXQpob3N0ID0gImZhZGktb3BlbmxkYXAiCnBvcnQgPSAzODkKdXNlX3NzbCA9IGZhbHNlCnN0YXJ0X3RscyA9IGZhbHNlCnNzbF9za2lwX3ZlcmlmeSA9IGZhbHNlCmJpbmRfZG4gPSAiY249YWRtaW4sREM9bGRhcCxEQz1jZXRpYyxEQz1iZSIKYmluZF9wYXNzd29yZCA9ICdwYXNzd29yZDEnCnNlYXJjaF9maWx0ZXIgPSAiKHwoY249JXMpKCYoY249JXMpKG1lbWJlck9mPWNuPWFkbWluLERDPWxkYXAsREM9Y2V0aWMsREM9YmUpKSkiCnNlYXJjaF9iYXNlX2RucyA9IFsiY249YWRtaW4sZGM9bGRhcCxkYz1jZXRpYyxkYz1iZSJdCmdyb3VwX3NlYXJjaF9iYXNlX2RucyA9IFsib3U9R3JvdXBzLGRjPWxkYXAsZGM9Y2V0aWMsZGM9YmUiXQoKW1tzZXJ2ZXJzLmdyb3VwX21hcHBpbmdzXV0KZ3JvdXBfZG4gPSAiKiIKb3JnX3JvbGUgPSAiQWRtaW4iCiMjZ3JhZmFuYV9hZG1pbiA9IHRydWUKCiNncm91cF9kbiA9ICJjbj1hbWVuLERDPWxkYXAsREM9Y2V0aWMsREM9YmUiCiNvcmdfcm9sZSA9ICJWaWV3ZXIiCgpbc2VydmVycy5hdHRyaWJ1dGVzXQpuYW1lID0gImdpdmVuTmFtZSIKc3VybmFtZSA9ICJzbiIKdXNlcm5hbWUgPSAiY24iCm1lbWJlcl9vZiA9ICJtZW1iZXJPZiIKZW1haWwgPSAgImVtYWlsIg=="
    }
  },
  {
    "kind": "Secret",
    "apiVersion": "v1",
    "metadata": {
      "name": "hub-secret",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "type": "Opaque",
    "data": {
      "values.yaml": "Q2hhcnQ6CiAgTmFtZToganVweXRlcmh1YgogIFZlcnNpb246IDAuMTEuMQpSZWxlYXNlOgogIE5hbWU6IHJlbGVhc2UtbmFtZQogIE5hbWVzcGFjZTogZGVmYXVsdAogIFNlcnZpY2U6IEhlbG0KY3VsbDoKICBjb25jdXJyZW5jeTogMTAKICBlbmFibGVkOiB0cnVlCiAgZXZlcnk6IDYwMAogIG1heEFnZTogMAogIHJlbW92ZU5hbWVkU2VydmVyczogZmFsc2UKICB0aW1lb3V0OiAzNjAwCiAgdXNlcnM6IGZhbHNlCmN1c3RvbToge30KZGVidWc6CiAgZW5hYmxlZDogZmFsc2UKZW5hYmxlZDogdHJ1ZQpnbG9iYWw6IHt9Cmh1YjoKICBhY3RpdmVTZXJ2ZXJMaW1pdDogbnVsbAogIGFsbG93TmFtZWRTZXJ2ZXJzOiBmYWxzZQogIGFubm90YXRpb25zOiB7fQogIGFyZ3M6IFtdCiAgYXV0aGVudGljYXRlUHJvbWV0aGV1czogbnVsbAogIGJhc2VVcmw6IC8KICBjb21tYW5kOiBbXQogIGNvbmN1cnJlbnRTcGF3bkxpbWl0OiA2NAogIGNvbmZpZzoKICAgIEp1cHl0ZXJIdWI6CiAgICAgIGFkbWluX2FjY2VzczogdHJ1ZQogICAgICBhdXRoZW50aWNhdG9yX2NsYXNzOiBsZGFwYXV0aGVudGljYXRvci5MREFQQXV0aGVudGljYXRvcgogICAgTERBUEF1dGhlbnRpY2F0b3I6CiAgICAgIGJpbmRfZG5fdGVtcGxhdGU6CiAgICAgIC0gY249e3VzZXJuYW1lfSxkYz1sZGFwLGRjPWNldGljLGRjPWJlCiAgICAgIC0gY249e3VzZXJuYW1lfSxjbj1hZG1pbixkYz1sZGFwLGRjPWNldGljLGRjPWJlCiAgICAgIGVzY2FwZV91c2VyZG46IGZhbHNlCiAgICAgIGxvb2t1cF9kbjogZmFsc2UKICAgICAgc2VydmVyX2FkZHJlc3M6IGZhZGktb3BlbmxkYXAKICAgICAgdXNlX3NzbDogZmFsc2UKICAgICAgdXNlcl9hdHRyaWJ1dGU6IGNuCiAgY29uc2VjdXRpdmVGYWlsdXJlTGltaXQ6IDUKICBjb250YWluZXJTZWN1cml0eUNvbnRleHQ6CiAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICBydW5Bc0dyb3VwOiAxMDAwCiAgICBydW5Bc1VzZXI6IDEwMDAKICBjb29raWVTZWNyZXQ6IG51bGwKICBkYjoKICAgIHB2YzoKICAgICAgYWNjZXNzTW9kZXM6CiAgICAgIC0gUmVhZFdyaXRlT25jZQogICAgICBhbm5vdGF0aW9uczoge30KICAgICAgc2VsZWN0b3I6IHt9CiAgICAgIHN0b3JhZ2U6IDFHaQogICAgdHlwZTogc3FsaXRlLXB2YwogIGRlcGxveW1lbnRTdHJhdGVneToKICAgIHR5cGU6IFJlY3JlYXRlCiAgZXhpc3RpbmdTZWNyZXQ6IG51bGwKICBleHRyYUNvbmZpZzoge30KICBleHRyYUNvbmZpZ01hcDoge30KICBleHRyYUNvbnRhaW5lcnM6IFtdCiAgZXh0cmFFbnY6IHt9CiAgZXh0cmFWb2x1bWVNb3VudHM6IFtdCiAgZXh0cmFWb2x1bWVzOiBbXQogIGZzR2lkOiAxMDAwCiAgaW1hZ2U6CiAgICBuYW1lOiBqdXB5dGVyaHViL2s4cy1odWIKICAgIHB1bGxQb2xpY3k6ICIiCiAgICBwdWxsU2VjcmV0czogW10KICAgIHRhZzogMC4xMS4xCiAgaW5pdENvbnRhaW5lcnM6IFtdCiAgbGFiZWxzOiB7fQogIGxpdmVuZXNzUHJvYmU6CiAgICBlbmFibGVkOiB0cnVlCiAgICBmYWlsdXJlVGhyZXNob2xkOiAzMAogICAgaW5pdGlhbERlbGF5U2Vjb25kczogMzAwCiAgICBwZXJpb2RTZWNvbmRzOiAxMAogICAgdGltZW91dFNlY29uZHM6IDMKICBuYW1lZFNlcnZlckxpbWl0UGVyVXNlcjogbnVsbAogIG5ldHdvcmtQb2xpY3k6CiAgICBhbGxvd2VkSW5ncmVzc1BvcnRzOiBbXQogICAgZWdyZXNzOgogICAgLSB0bzoKICAgICAgLSBpcEJsb2NrOgogICAgICAgICAgY2lkcjogMC4wLjAuMC8wCiAgICBlbmFibGVkOiB0cnVlCiAgICBpbmdyZXNzOiBbXQogICAgaW50ZXJOYW1lc3BhY2VBY2Nlc3NMYWJlbHM6IGlnbm9yZQogIG5vZGVTZWxlY3Rvcjoge30KICBwZGI6CiAgICBlbmFibGVkOiBmYWxzZQogICAgbWluQXZhaWxhYmxlOiAxCiAgcHVibGljVVJMOiBudWxsCiAgcmVhZGluZXNzUHJvYmU6CiAgICBlbmFibGVkOiB0cnVlCiAgICBmYWlsdXJlVGhyZXNob2xkOiAxMDAwCiAgICBpbml0aWFsRGVsYXlTZWNvbmRzOiAwCiAgICBwZXJpb2RTZWNvbmRzOiAyCiAgICB0aW1lb3V0U2Vjb25kczogMQogIHJlZGlyZWN0VG9TZXJ2ZXI6IG51bGwKICByZXNvdXJjZXM6CiAgICByZXF1ZXN0czoKICAgICAgY3B1OiAyMDBtCiAgICAgIG1lbW9yeTogNTEyTWkKICBzZXJ2aWNlOgogICAgYW5ub3RhdGlvbnM6IHt9CiAgICBwb3J0czoge30KICAgIHR5cGU6IENsdXN0ZXJJUAogIHNlcnZpY2VzOiB7fQogIHNodXRkb3duT25Mb2dvdXQ6IG51bGwKICB0ZW1wbGF0ZVBhdGhzOiBbXQogIHRlbXBsYXRlVmFyczoge30KICB0b2xlcmF0aW9uczogW10KaW1hZ2VQdWxsU2VjcmV0OgogIGF1dG9tYXRpY1JlZmVyZW5jZUluamVjdGlvbjogdHJ1ZQogIGNyZWF0ZTogZmFsc2UKICBlbWFpbDogIiIKICBwYXNzd29yZDogIiIKICByZWdpc3RyeTogIiIKICB1c2VybmFtZTogIiIKaW1hZ2VQdWxsU2VjcmV0czogW10KaW5ncmVzczoKICBhbm5vdGF0aW9uczoge30KICBlbmFibGVkOiBmYWxzZQogIGhvc3RzOiBbXQogIHBhdGhTdWZmaXg6ICIiCiAgdGxzOiBbXQpwcmVQdWxsZXI6CiAgYW5ub3RhdGlvbnM6IHt9CiAgY29udGFpbmVyU2VjdXJpdHlDb250ZXh0OgogICAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogICAgcnVuQXNHcm91cDogNjU1MzQKICAgIHJ1bkFzVXNlcjogNjU1MzQKICBjb250aW51b3VzOgogICAgZW5hYmxlZDogdHJ1ZQogIGV4dHJhSW1hZ2VzOiB7fQogIGV4dHJhVG9sZXJhdGlvbnM6IFtdCiAgaG9vazoKICAgIGNvbnRhaW5lclNlY3VyaXR5Q29udGV4dDoKICAgICAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogICAgICBydW5Bc0dyb3VwOiA2NTUzNAogICAgICBydW5Bc1VzZXI6IDY1NTM0CiAgICBlbmFibGVkOiBmYWxzZQogICAgaW1hZ2U6CiAgICAgIG5hbWU6IGp1cHl0ZXJodWIvazhzLWltYWdlLWF3YWl0ZXIKICAgICAgcHVsbFBvbGljeTogIiIKICAgICAgcHVsbFNlY3JldHM6IFtdCiAgICAgIHRhZzogMC4xMS4xCiAgICBub2RlU2VsZWN0b3I6IHt9CiAgICBwb2RTY2hlZHVsaW5nV2FpdER1cmF0aW9uOiAxMAogICAgcmVzb3VyY2VzOgogICAgICByZXF1ZXN0czoKICAgICAgICBjcHU6IDAKICAgICAgICBtZW1vcnk6IDAKICAgIHRvbGVyYXRpb25zOiBbXQogIHBhdXNlOgogICAgY29udGFpbmVyU2VjdXJpdHlDb250ZXh0OgogICAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICAgIHJ1bkFzR3JvdXA6IDY1NTM0CiAgICAgIHJ1bkFzVXNlcjogNjU1MzQKICAgIGltYWdlOgogICAgICBuYW1lOiBrOHMuZ2NyLmlvL3BhdXNlCiAgICAgIHB1bGxQb2xpY3k6ICIiCiAgICAgIHB1bGxTZWNyZXRzOiBbXQogICAgICB0YWc6ICIzLjIiCiAgcHVsbFByb2ZpbGVMaXN0SW1hZ2VzOiB0cnVlCiAgcmVzb3VyY2VzOgogICAgcmVxdWVzdHM6CiAgICAgIGNwdTogMAogICAgICBtZW1vcnk6IDAKcHJveHk6CiAgYW5ub3RhdGlvbnM6IHt9CiAgY2hwOgogICAgY29udGFpbmVyU2VjdXJpdHlDb250ZXh0OgogICAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICAgIHJ1bkFzR3JvdXA6IDY1NTM0CiAgICAgIHJ1bkFzVXNlcjogNjU1MzQKICAgIGV4dHJhQ29tbWFuZExpbmVGbGFnczogW10KICAgIGV4dHJhRW52OiB7fQogICAgaW1hZ2U6CiAgICAgIG5hbWU6IGp1cHl0ZXJodWIvY29uZmlndXJhYmxlLWh0dHAtcHJveHkKICAgICAgcHVsbFBvbGljeTogIiIKICAgICAgcHVsbFNlY3JldHM6IFtdCiAgICAgIHRhZzogNC4yLjIKICAgIGxpdmVuZXNzUHJvYmU6CiAgICAgIGVuYWJsZWQ6IHRydWUKICAgICAgaW5pdGlhbERlbGF5U2Vjb25kczogNjAKICAgICAgcGVyaW9kU2Vjb25kczogMTAKICAgIG5ldHdvcmtQb2xpY3k6CiAgICAgIGFsbG93ZWRJbmdyZXNzUG9ydHM6CiAgICAgIC0gaHR0cAogICAgICAtIGh0dHBzCiAgICAgIGVncmVzczoKICAgICAgLSB0bzoKICAgICAgICAtIGlwQmxvY2s6CiAgICAgICAgICAgIGNpZHI6IDAuMC4wLjAvMAogICAgICBlbmFibGVkOiB0cnVlCiAgICAgIGluZ3Jlc3M6IFtdCiAgICAgIGludGVyTmFtZXNwYWNlQWNjZXNzTGFiZWxzOiBpZ25vcmUKICAgIG5vZGVTZWxlY3Rvcjoge30KICAgIHBkYjoKICAgICAgZW5hYmxlZDogZmFsc2UKICAgICAgbWluQXZhaWxhYmxlOiAxCiAgICByZWFkaW5lc3NQcm9iZToKICAgICAgZW5hYmxlZDogdHJ1ZQogICAgICBmYWlsdXJlVGhyZXNob2xkOiAxMDAwCiAgICAgIGluaXRpYWxEZWxheVNlY29uZHM6IDAKICAgICAgcGVyaW9kU2Vjb25kczogMgogICAgcmVzb3VyY2VzOgogICAgICByZXF1ZXN0czoKICAgICAgICBjcHU6IDIwMG0KICAgICAgICBtZW1vcnk6IDUxMk1pCiAgICB0b2xlcmF0aW9uczogW10KICBkYjoKICAgIHR5cGU6IHNxbGl0ZS1tZW1vcnkKICBkZXBsb3ltZW50U3RyYXRlZ3k6CiAgICB0eXBlOiBSZWNyZWF0ZQogIGh0dHBzOgogICAgZW5hYmxlZDogZmFsc2UKICAgIGhvc3RzOiBbXQogICAgbGV0c2VuY3J5cHQ6CiAgICAgIGFjbWVTZXJ2ZXI6IGh0dHBzOi8vYWNtZS12MDIuYXBpLmxldHNlbmNyeXB0Lm9yZy9kaXJlY3RvcnkKICAgICAgY29udGFjdEVtYWlsOiAiIgogICAgbWFudWFsOiB7fQogICAgc2VjcmV0OgogICAgICBjcnQ6IHRscy5jcnQKICAgICAga2V5OiB0bHMua2V5CiAgICAgIG5hbWU6ICIiCiAgICB0eXBlOiBsZXRzZW5jcnlwdAogIGxhYmVsczoge30KICBzZWNyZXRTeW5jOgogICAgY29udGFpbmVyU2VjdXJpdHlDb250ZXh0OgogICAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICAgIHJ1bkFzR3JvdXA6IDY1NTM0CiAgICAgIHJ1bkFzVXNlcjogNjU1MzQKICAgIGltYWdlOgogICAgICBuYW1lOiBqdXB5dGVyaHViL2s4cy1zZWNyZXQtc3luYwogICAgICBwdWxsUG9saWN5OiAiIgogICAgICBwdWxsU2VjcmV0czogW10KICAgICAgdGFnOiAwLjExLjEKICAgIHJlc291cmNlczoge30KICBzZWNyZXRUb2tlbjogYWY4Mzc3NWVjM2JmYWYwNTA3Y2U1OTZkZjUxZDQ5MWU3ZWQ1NDQ1MGFkYzQ1NDAzOGZhNzQwNTQ5NTQ2NWYxOQogIHNlcnZpY2U6CiAgICBhbm5vdGF0aW9uczoge30KICAgIGV4dHJhUG9ydHM6IFtdCiAgICBsYWJlbHM6IHt9CiAgICBsb2FkQmFsYW5jZXJJUDogbnVsbAogICAgbG9hZEJhbGFuY2VyU291cmNlUmFuZ2VzOiBbXQogICAgbm9kZVBvcnRzOiB7fQogICAgdHlwZTogQ2x1c3RlcklQCiAgdHJhZWZpazoKICAgIGNvbnRhaW5lclNlY3VyaXR5Q29udGV4dDoKICAgICAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogICAgICBydW5Bc0dyb3VwOiA2NTUzNAogICAgICBydW5Bc1VzZXI6IDY1NTM0CiAgICBleHRyYUR5bmFtaWNDb25maWc6IHt9CiAgICBleHRyYUVudjoge30KICAgIGV4dHJhUG9ydHM6IFtdCiAgICBleHRyYVN0YXRpY0NvbmZpZzoge30KICAgIGV4dHJhVm9sdW1lTW91bnRzOiBbXQogICAgZXh0cmFWb2x1bWVzOiBbXQogICAgaHN0czoKICAgICAgaW5jbHVkZVN1YmRvbWFpbnM6IGZhbHNlCiAgICAgIG1heEFnZTogMTU3MjQ4MDAKICAgICAgcHJlbG9hZDogZmFsc2UKICAgIGltYWdlOgogICAgICBuYW1lOiB0cmFlZmlrCiAgICAgIHB1bGxQb2xpY3k6ICIiCiAgICAgIHB1bGxTZWNyZXRzOiBbXQogICAgICB0YWc6IHYyLjMuNwogICAgbmV0d29ya1BvbGljeToKICAgICAgYWxsb3dlZEluZ3Jlc3NQb3J0czoKICAgICAgLSBodHRwCiAgICAgIC0gaHR0cHMKICAgICAgZWdyZXNzOgogICAgICAtIHRvOgogICAgICAgIC0gaXBCbG9jazoKICAgICAgICAgICAgY2lkcjogMC4wLjAuMC8wCiAgICAgIGVuYWJsZWQ6IHRydWUKICAgICAgaW5ncmVzczogW10KICAgICAgaW50ZXJOYW1lc3BhY2VBY2Nlc3NMYWJlbHM6IGlnbm9yZQogICAgbm9kZVNlbGVjdG9yOiB7fQogICAgcGRiOgogICAgICBlbmFibGVkOiBmYWxzZQogICAgICBtaW5BdmFpbGFibGU6IDEKICAgIHJlc291cmNlczoge30KICAgIHRvbGVyYXRpb25zOiBbXQpyYmFjOgogIGVuYWJsZWQ6IHRydWUKc2NoZWR1bGluZzoKICBjb3JlUG9kczoKICAgIG5vZGVBZmZpbml0eToKICAgICAgbWF0Y2hOb2RlUHVycG9zZTogcHJlZmVyCiAgcG9kUHJpb3JpdHk6CiAgICBkZWZhdWx0UHJpb3JpdHk6IDAKICAgIGVuYWJsZWQ6IGZhbHNlCiAgICBnbG9iYWxEZWZhdWx0OiBmYWxzZQogICAgdXNlclBsYWNlaG9sZGVyUHJpb3JpdHk6IC0xMAogIHVzZXJQbGFjZWhvbGRlcjoKICAgIGNvbnRhaW5lclNlY3VyaXR5Q29udGV4dDoKICAgICAgYWxsb3dQcml2aWxlZ2VFc2NhbGF0aW9uOiBmYWxzZQogICAgICBydW5Bc0dyb3VwOiA2NTUzNAogICAgICBydW5Bc1VzZXI6IDY1NTM0CiAgICBlbmFibGVkOiB0cnVlCiAgICByZXBsaWNhczogMAogIHVzZXJQb2RzOgogICAgbm9kZUFmZmluaXR5OgogICAgICBtYXRjaE5vZGVQdXJwb3NlOiBwcmVmZXIKICB1c2VyU2NoZWR1bGVyOgogICAgY29udGFpbmVyU2VjdXJpdHlDb250ZXh0OgogICAgICBhbGxvd1ByaXZpbGVnZUVzY2FsYXRpb246IGZhbHNlCiAgICAgIHJ1bkFzR3JvdXA6IDY1NTM0CiAgICAgIHJ1bkFzVXNlcjogNjU1MzQKICAgIGVuYWJsZWQ6IHRydWUKICAgIGltYWdlOgogICAgICBuYW1lOiBrOHMuZ2NyLmlvL2t1YmUtc2NoZWR1bGVyCiAgICAgIHB1bGxQb2xpY3k6ICIiCiAgICAgIHB1bGxTZWNyZXRzOiBbXQogICAgICB0YWc6IHYxLjE5LjcKICAgIGxvZ0xldmVsOiA0CiAgICBub2RlU2VsZWN0b3I6IHt9CiAgICBwZGI6CiAgICAgIGVuYWJsZWQ6IHRydWUKICAgICAgbWluQXZhaWxhYmxlOiAxCiAgICBwbHVnaW5zOgogICAgICBzY29yZToKICAgICAgICBkaXNhYmxlZDoKICAgICAgICAtIG5hbWU6IFNlbGVjdG9yU3ByZWFkCiAgICAgICAgLSBuYW1lOiBUYWludFRvbGVyYXRpb24KICAgICAgICAtIG5hbWU6IFBvZFRvcG9sb2d5U3ByZWFkCiAgICAgICAgLSBuYW1lOiBOb2RlUmVzb3VyY2VzQmFsYW5jZWRBbGxvY2F0aW9uCiAgICAgICAgLSBuYW1lOiBOb2RlUmVzb3VyY2VzTGVhc3RBbGxvY2F0ZWQKICAgICAgICAtIG5hbWU6IE5vZGVQcmVmZXJBdm9pZFBvZHMKICAgICAgICAtIG5hbWU6IE5vZGVBZmZpbml0eQogICAgICAgIC0gbmFtZTogSW50ZXJQb2RBZmZpbml0eQogICAgICAgIC0gbmFtZTogSW1hZ2VMb2NhbGl0eQogICAgICAgIGVuYWJsZWQ6CiAgICAgICAgLSBuYW1lOiBOb2RlUHJlZmVyQXZvaWRQb2RzCiAgICAgICAgICB3ZWlnaHQ6IDE2MTA1MQogICAgICAgIC0gbmFtZTogTm9kZUFmZmluaXR5CiAgICAgICAgICB3ZWlnaHQ6IDE0NjMxCiAgICAgICAgLSBuYW1lOiBJbnRlclBvZEFmZmluaXR5CiAgICAgICAgICB3ZWlnaHQ6IDEzMzEKICAgICAgICAtIG5hbWU6IE5vZGVSZXNvdXJjZXNNb3N0QWxsb2NhdGVkCiAgICAgICAgICB3ZWlnaHQ6IDEyMQogICAgICAgIC0gbmFtZTogSW1hZ2VMb2NhbGl0eQogICAgICAgICAgd2VpZ2h0OiAxMQogICAgcmVwbGljYXM6IDIKICAgIHJlc291cmNlczoKICAgICAgcmVxdWVzdHM6CiAgICAgICAgY3B1OiA1MG0KICAgICAgICBtZW1vcnk6IDI1Nk1pCiAgICB0b2xlcmF0aW9uczogW10Kc2luZ2xldXNlcjoKICBjbG91ZE1ldGFkYXRhOgogICAgYmxvY2tXaXRoSXB0YWJsZXM6IHRydWUKICAgIGlwOiAxNjkuMjU0LjE2OS4yNTQKICBjbWQ6IGp1cHl0ZXJodWItc2luZ2xldXNlcgogIGNwdToge30KICBkZWZhdWx0VXJsOiBudWxsCiAgZXZlbnRzOiB0cnVlCiAgZXh0cmFBbm5vdGF0aW9uczoge30KICBleHRyYUNvbnRhaW5lcnM6IFtdCiAgZXh0cmFFbnY6IHt9CiAgZXh0cmFMYWJlbHM6CiAgICBodWIuanVweXRlci5vcmcvbmV0d29yay1hY2Nlc3MtaHViOiAidHJ1ZSIKICBleHRyYU5vZGVBZmZpbml0eToKICAgIHByZWZlcnJlZDogW10KICAgIHJlcXVpcmVkOiBbXQogIGV4dHJhUG9kQWZmaW5pdHk6CiAgICBwcmVmZXJyZWQ6IFtdCiAgICByZXF1aXJlZDogW10KICBleHRyYVBvZEFudGlBZmZpbml0eToKICAgIHByZWZlcnJlZDogW10KICAgIHJlcXVpcmVkOiBbXQogIGV4dHJhUG9kQ29uZmlnOiB7fQogIGV4dHJhUmVzb3VyY2U6CiAgICBndWFyYW50ZWVzOiB7fQogICAgbGltaXRzOiB7fQogIGV4dHJhVG9sZXJhdGlvbnM6IFtdCiAgZnNHaWQ6IDEwMAogIGltYWdlOgogICAgbmFtZToganVweXRlcmh1Yi9rOHMtc2luZ2xldXNlci1zYW1wbGUKICAgIHB1bGxQb2xpY3k6ICIiCiAgICBwdWxsU2VjcmV0czogW10KICAgIHRhZzogMC4xMS4xCiAgaW5pdENvbnRhaW5lcnM6IFtdCiAgbGlmZWN5Y2xlSG9va3M6IHt9CiAgbWVtb3J5OgogICAgZ3VhcmFudGVlOiAxRwogIG5ldHdvcmtQb2xpY3k6CiAgICBhbGxvd2VkSW5ncmVzc1BvcnRzOiBbXQogICAgZWdyZXNzOgogICAgLSB0bzoKICAgICAgLSBpcEJsb2NrOgogICAgICAgICAgY2lkcjogMC4wLjAuMC8wCiAgICAgICAgICBleGNlcHQ6CiAgICAgICAgICAtIDE2OS4yNTQuMTY5LjI1NC8zMgogICAgZW5hYmxlZDogdHJ1ZQogICAgaW5ncmVzczogW10KICAgIGludGVyTmFtZXNwYWNlQWNjZXNzTGFiZWxzOiBpZ25vcmUKICBuZXR3b3JrVG9vbHM6CiAgICBpbWFnZToKICAgICAgbmFtZToganVweXRlcmh1Yi9rOHMtbmV0d29yay10b29scwogICAgICBwdWxsUG9saWN5OiAiIgogICAgICBwdWxsU2VjcmV0czogW10KICAgICAgdGFnOiAwLjExLjEKICBub2RlU2VsZWN0b3I6IHt9CiAgcG9kTmFtZVRlbXBsYXRlOiBudWxsCiAgcHJvZmlsZUxpc3Q6CiAgLSBkZWZhdWx0OiB0cnVlCiAgICBkZXNjcmlwdGlvbjogJ1RvIGF2b2lkIHRvbyBtdWNoIGJlbGxzIGFuZCB3aGlzdGxlczogUHl0aG9uLicKICAgIGRpc3BsYXlfbmFtZTogTWluaW1hbCBlbnZpcm9ubWVudAogIC0gZGVzY3JpcHRpb246ICdJZiB5b3Ugd2FudCB0aGUgYWRkaXRpb25hbCBiZWxscyBhbmQgd2hpc3RsZXM6IFB5dGhvbiwgUiwgYW5kIEp1bGlhLicKICAgIGRpc3BsYXlfbmFtZTogRGF0YXNjaWVuY2UgZW52aXJvbm1lbnQKICAgIGt1YmVzcGF3bmVyX292ZXJyaWRlOgogICAgICBpbWFnZToganVweXRlci9kYXRhc2NpZW5jZS1ub3RlYm9vazo3ZDQyN2U3YTRkZGUKICAtIGRlc2NyaXB0aW9uOiBUaGUgSnVweXRlciBTdGFja3Mgc3BhcmsgaW1hZ2UKICAgIGRpc3BsYXlfbmFtZTogU3BhcmsgZW52aXJvbm1lbnQKICAgIGt1YmVzcGF3bmVyX292ZXJyaWRlOgogICAgICBpbWFnZToganVweXRlci9hbGwtc3Bhcmstbm90ZWJvb2s6bGF0ZXN0CiAgLSBkZXNjcmlwdGlvbjogVGVuc29yRmxvdyBOb3RlYm9vawogICAgZGlzcGxheV9uYW1lOiB0ZW5zb3JmbG93IGVudmlyb25tZW50CiAgICBrdWJlc3Bhd25lcl9vdmVycmlkZToKICAgICAgaW1hZ2U6IGp1cHl0ZXIvdGVuc29yZmxvdy1ub3RlYm9vazpsYXRlc3QKICBzZXJ2aWNlQWNjb3VudE5hbWU6IG51bGwKICBzdGFydFRpbWVvdXQ6IDMwMAogIHN0b3JhZ2U6CiAgICBjYXBhY2l0eTogNUdpCiAgICBkeW5hbWljOgogICAgICBwdmNOYW1lVGVtcGxhdGU6IGNsYWltLXt1c2VybmFtZX17c2VydmVybmFtZX0KICAgICAgc3RvcmFnZUFjY2Vzc01vZGVzOgogICAgICAtIFJlYWRXcml0ZU9uY2UKICAgICAgdm9sdW1lTmFtZVRlbXBsYXRlOiB2b2x1bWUte3VzZXJuYW1lfXtzZXJ2ZXJuYW1lfQogICAgZXh0cmFMYWJlbHM6IHt9CiAgICBleHRyYVZvbHVtZU1vdW50czogW10KICAgIGV4dHJhVm9sdW1lczogW10KICAgIGhvbWVNb3VudFBhdGg6IC9ob21lL2pvdnlhbgogICAgc3RhdGljOgogICAgICBzdWJQYXRoOiAne3VzZXJuYW1lfScKICAgIHR5cGU6IGR5bmFtaWMKICB1aWQ6IDEwMDAKdHJhZWZpa0luZ3Jlc3M6CiAgZW5hYmxlZDogdHJ1ZQogIGhvc3Q6IGp1cHl0ZXJodWIuZXhhbXBsZS5jZXRpYy5iZQogIHRsczogZmFsc2U=",
      "proxy.token": "YWY4Mzc3NWVjM2JmYWYwNTA3Y2U1OTZkZjUxZDQ5MWU3ZWQ1NDQ1MGFkYzQ1NDAzOGZhNzQwNTQ5NTQ2NWYxOQ=="
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
      "name": "release-name-keycloak",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "keycloak",
        "helm.sh/chart": "keycloak-2.4.8",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "keycloak"
      }
    },
    "type": "Opaque",
    "data": {
      "admin-password": "cGFzc3dvcmQx",
      "management-password": "cGFzc3dvcmQy",
      "database-password": "WjJKSEhlemk0YUFB"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
      "name": "release-name-openldap",
      "labels": {
        "app": "openldap",
        "chart": "openldap-1.2.7",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "type": "Opaque",
    "data": {
      "LDAP_ADMIN_PASSWORD": "WjJKSEhlemk0YUFB",
      "LDAP_CONFIG_PASSWORD": "cGFzc3dvcmQy"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
      "name": "release-name-spark-secret",
      "labels": {
        "app.kubernetes.io/name": "spark",
        "helm.sh/chart": "spark-4.1.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "type": "Opaque",
    "data": null
  },
  {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
      "name": "release-name-superset",
      "labels": {
        "app": "superset",
        "chart": "superset-1.2.0",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "type": "Opaque",
    "data": {
      "init_superset.sh": "L3Vzci9sb2NhbC9iaW4vc3VwZXJzZXQtaW5pdCAtLXVzZXJuYW1lIGFkbWluIC0tZmlyc3RuYW1lIGFkbWluIC0tbGFzdG5hbWUgdXNlciAtLWVtYWlsIGFkbWluQGZhYi5vcmcgLS1wYXNzd29yZCBhZG1pbgpzdXBlcnNldCBydW4=",
      "superset_config.py": "ZnJvbSBmbGFza19hcHBidWlsZGVyLnNlY3VyaXR5Lm1hbmFnZXIgaW1wb3J0IEFVVEhfREIsQVVUSF9MREFQCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBTdXBlcnNldCBzcGVjaWZpYyBjb25maWcKIy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQpST1dfTElNSVQgPSA1MDAwClNVUEVSU0VUX1dPUktFUlMgPSAyClNVUEVSU0VUX1dFQlNFUlZFUl9QT1JUID0gODA4OAojLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBGbGFzayBBcHAgQnVpbGRlciBjb25maWd1cmF0aW9uCiMtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KIyBZb3VyIEFwcCBzZWNyZXQga2V5ClNFQ1JFVF9LRVkgPSAnXDJcMXRoaXNpc215c2NyZXRrZXlcMVwyXGVceVx5XGgnCiMgVGhlIFNRTEFsY2hlbXkgY29ubmVjdGlvbiBzdHJpbmcgdG8geW91ciBkYXRhYmFzZSBiYWNrZW5kCiMgVGhpcyBjb25uZWN0aW9uIGRlZmluZXMgdGhlIHBhdGggdG8gdGhlIGRhdGFiYXNlIHRoYXQgc3RvcmVzIHlvdXIKIyBzdXBlcnNldCBtZXRhZGF0YSAoc2xpY2VzLCBjb25uZWN0aW9ucywgdGFibGVzLCBkYXNoYm9hcmRzLCAuLi4pLgojIE5vdGUgdGhhdCB0aGUgY29ubmVjdGlvbiBpbmZvcm1hdGlvbiB0byBjb25uZWN0IHRvIHRoZSBkYXRhc291cmNlcwojIHlvdSB3YW50IHRvIGV4cGxvcmUgYXJlIG1hbmFnZWQgZGlyZWN0bHkgaW4gdGhlIHdlYiBVSQpTUUxBTENIRU1ZX0RBVEFCQVNFX1VSSSA9ICdzcWxpdGU6Ly8vL3Zhci9saWIvc3VwZXJzZXQvc3VwZXJzZXQuZGInCiMgRmxhc2stV1RGIGZsYWcgZm9yIENTUkYKV1RGX0NTUkZfRU5BQkxFRCA9IFRydWUKIyBBZGQgZW5kcG9pbnRzIHRoYXQgbmVlZCB0byBiZSBleGVtcHQgZnJvbSBDU1JGIHByb3RlY3Rpb24KV1RGX0NTUkZfRVhFTVBUX0xJU1QgPSBbXQojIFNldCB0aGlzIEFQSSBrZXkgdG8gZW5hYmxlIE1hcGJveCB2aXN1YWxpemF0aW9ucwpNQVBCT1hfQVBJX0tFWSA9ICcnCkRFQlVHPVRydWUKTE9HX0ZPUk1BVCA9ICclKGFzY3RpbWUpczolKGxldmVsbmFtZSlzOiUobmFtZSlzOiUobWVzc2FnZSlzJwpMT0dfTEVWRUwgPSAnREVCVUcnCkFVVEhfVFlQRSA9IEFVVEhfTERBUApBVVRIX0xEQVBfU0VSVkVSID0gImxkYXA6Ly9mYWRpLW9wZW5sZGFwOjM4OSIKQVVUSF9MREFQX1VTRV9UTFMgPSBGYWxzZQpBVVRIX1VTRVJfUkVHSVNUUkFUSU9OID0gVHJ1ZQpBVVRIX0xEQVBfU0VBUkNIID0gImRjPWxkYXAsZGM9Y2V0aWMsZGM9YmUiCkFVVEhfTERBUF9CSU5EX1VTRVIgPSAiY249YWRtaW4sZGM9bGRhcCxkYz1jZXRpYyxkYz1iZSIKQVVUSF9MREFQX0JJTkRfUEFTU1dPUkQgPSAiWjJKSEhlemk0YUFBIgpBVVRIX0xEQVBfVUlEX0ZJRUxEID0gImNuIg=="
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "data": {
      "grafana.ini": "[analytics]\ncheck_for_updates = true\n[auth.azuread]\nallow_sign_up = true\nallowed_domains = \nallowed_groups = \nauth_url = https://login.microsoftonline.com/<your_tenant_id>/oauth2/v2.0/authorize\nclient_id = <your_application_id>\nclient_secret = <your_client_secret>\nenabled = false\nname = Azure AD\nscopes = openid email profile\ntoken_url = https://login.microsoftonline.com/<your_tenant_id>/oauth2/v2.0/token\n[auth.generic_oauth]\nallow_sign_up = true\napi_url = http://<your_keycloak_URL>/auth/realms/<your_realm>/protocol/openid-connect/userinfo\nauth_url = http://<your_keycloak_URL>/auth/realms/<your_realm>/protocol/openid-connect/auth\nclient_id = <your_client_id>\nclient_secret = <your_client_secret>\nenabled = false\nname = Keycloak\nscopes = openid email profile\ntls_skip_verify_insecure = false\ntoken_url = http://<your_keycloak_URL>/auth/realms/<your_realm>/protocol/openid-connect/token\n[auth.ldap]\nallow_sign_up = true\nconfig_file = /etc/grafana/ldap.toml\nenabled = true\n[grafana_net]\nurl = https://grafana.net\n[log]\nmode = console\n[paths]\ndata = /var/lib/grafana/data\nlogs = /var/log/grafana\nplugins = /var/lib/grafana/plugins\nprovisioning = /etc/grafana/provisioning\n[server]\nroot_url = http://grafana.example.cetic.be\n"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-grafana-test",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "data": {
      "run.sh": "@test \"Test Health\" {\n  url=\"http://release-name-grafana/api/health\"\n\n  code=$(wget --server-response --spider --timeout 10 --tries 1 ${url} 2>&1 | awk '/^  HTTP/{print $2}')\n  [ \"$code\" == \"200\" ]\n}"
    }
  },
  {
    "kind": "ConfigMap",
    "apiVersion": "v1",
    "metadata": {
      "name": "hub-config",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "data": {
      "jupyterhub_config.py": "import os\nimport re\nimport sys\n\nfrom binascii import a2b_hex\n\nfrom tornado.httpclient import AsyncHTTPClient\nfrom kubernetes import client\nfrom jupyterhub.utils import url_path_join\n\n# Make sure that modules placed in the same directory as the jupyterhub config are added to the pythonpath\nconfiguration_directory = os.path.dirname(os.path.realpath(__file__))\nsys.path.insert(0, configuration_directory)\n\nfrom z2jh import get_config, set_config_if_not_none\n\n\ndef camelCaseify(s):\n    \"\"\"convert snake_case to camelCase\n\n    For the common case where some_value is set from someValue\n    so we don't have to specify the name twice.\n    \"\"\"\n    return re.sub(r\"_([a-z])\", lambda m: m.group(1).upper(), s)\n\n\n# Configure JupyterHub to use the curl backend for making HTTP requests,\n# rather than the pure-python implementations. The default one starts\n# being too slow to make a large number of requests to the proxy API\n# at the rate required.\nAsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n\nc.JupyterHub.spawner_class = \"kubespawner.KubeSpawner\"\n\n# Connect to a proxy running in a different pod. Note that *_SERVICE_*\n# environment variables are set by Kubernetes for Services\nc.ConfigurableHTTPProxy.api_url = (\n    f\"http://proxy-api:{os.environ['PROXY_API_SERVICE_PORT']}\"\n)\nc.ConfigurableHTTPProxy.should_start = False\n\n# Do not shut down user pods when hub is restarted\nc.JupyterHub.cleanup_servers = False\n\n# Check that the proxy has routes appropriately setup\nc.JupyterHub.last_activity_interval = 60\n\n# Don't wait at all before redirecting a spawning user to the progress page\nc.JupyterHub.tornado_settings = {\n    \"slow_spawn_timeout\": 0,\n}\n\n\n# configure the hub db connection\ndb_type = get_config(\"hub.db.type\")\nif db_type == \"sqlite-pvc\":\n    c.JupyterHub.db_url = \"sqlite:///jupyterhub.sqlite\"\nelif db_type == \"sqlite-memory\":\n    c.JupyterHub.db_url = \"sqlite://\"\nelse:\n    set_config_if_not_none(c.JupyterHub, \"db_url\", \"hub.db.url\")\n\n\n# c.JupyterHub configuration from Helm chart's configmap\nfor trait, cfg_key in (\n    (\"concurrent_spawn_limit\", None),\n    (\"active_server_limit\", None),\n    (\"base_url\", None),\n    # ('cookie_secret', None),  # requires a Hex -> Byte transformation\n    (\"allow_named_servers\", None),\n    (\"named_server_limit_per_user\", None),\n    (\"authenticate_prometheus\", None),\n    (\"redirect_to_server\", None),\n    (\"shutdown_on_logout\", None),\n    (\"template_paths\", None),\n    (\"template_vars\", None),\n):\n    if cfg_key is None:\n        cfg_key = camelCaseify(trait)\n    set_config_if_not_none(c.JupyterHub, trait, \"hub.\" + cfg_key)\n\n# a required Hex -> Byte transformation\ncookie_secret_hex = get_config(\"hub.cookieSecret\")\nif cookie_secret_hex:\n    c.JupyterHub.cookie_secret = a2b_hex(cookie_secret_hex)\n\n# hub_bind_url configures what the JupyterHub process within the hub pod's\n# container should listen to.\nhub_container_port = 8081\nc.JupyterHub.hub_bind_url = f\"http://:{hub_container_port}\"\n\n# hub_connect_url is the URL for connecting to the hub for use by external\n# JupyterHub services such as the proxy. Note that *_SERVICE_* environment\n# variables are set by Kubernetes for Services.\nc.JupyterHub.hub_connect_url = f\"http://hub:{os.environ['HUB_SERVICE_PORT']}\"\n\n# implement common labels\n# this duplicates the jupyterhub.commonLabels helper\ncommon_labels = c.KubeSpawner.common_labels = {}\ncommon_labels[\"app\"] = get_config(\n    \"nameOverride\",\n    default=get_config(\"Chart.Name\", \"jupyterhub\"),\n)\ncommon_labels[\"heritage\"] = \"jupyterhub\"\nchart_name = get_config(\"Chart.Name\")\nchart_version = get_config(\"Chart.Version\")\nif chart_name and chart_version:\n    common_labels[\"chart\"] = \"{}-{}\".format(\n        chart_name,\n        chart_version.replace(\"+\", \"_\"),\n    )\nrelease = get_config(\"Release.Name\")\nif release:\n    common_labels[\"release\"] = release\n\nc.KubeSpawner.namespace = os.environ.get(\"POD_NAMESPACE\", \"default\")\n\n# Max number of consecutive failures before the Hub restarts itself\n# requires jupyterhub 0.9.2\nset_config_if_not_none(\n    c.Spawner,\n    \"consecutive_failure_limit\",\n    \"hub.consecutiveFailureLimit\",\n)\n\nfor trait, cfg_key in (\n    (\"pod_name_template\", None),\n    (\"start_timeout\", None),\n    (\"image_pull_policy\", \"image.pullPolicy\"),\n    # ('image_pull_secrets', 'image.pullSecrets'), # Managed manually below\n    (\"events_enabled\", \"events\"),\n    (\"extra_labels\", None),\n    (\"extra_annotations\", None),\n    (\"uid\", None),\n    (\"fs_gid\", None),\n    (\"service_account\", \"serviceAccountName\"),\n    (\"storage_extra_labels\", \"storage.extraLabels\"),\n    (\"tolerations\", \"extraTolerations\"),\n    (\"node_selector\", None),\n    (\"node_affinity_required\", \"extraNodeAffinity.required\"),\n    (\"node_affinity_preferred\", \"extraNodeAffinity.preferred\"),\n    (\"pod_affinity_required\", \"extraPodAffinity.required\"),\n    (\"pod_affinity_preferred\", \"extraPodAffinity.preferred\"),\n    (\"pod_anti_affinity_required\", \"extraPodAntiAffinity.required\"),\n    (\"pod_anti_affinity_preferred\", \"extraPodAntiAffinity.preferred\"),\n    (\"lifecycle_hooks\", None),\n    (\"init_containers\", None),\n    (\"extra_containers\", None),\n    (\"mem_limit\", \"memory.limit\"),\n    (\"mem_guarantee\", \"memory.guarantee\"),\n    (\"cpu_limit\", \"cpu.limit\"),\n    (\"cpu_guarantee\", \"cpu.guarantee\"),\n    (\"extra_resource_limits\", \"extraResource.limits\"),\n    (\"extra_resource_guarantees\", \"extraResource.guarantees\"),\n    (\"environment\", \"extraEnv\"),\n    (\"profile_list\", None),\n    (\"extra_pod_config\", None),\n):\n    if cfg_key is None:\n        cfg_key = camelCaseify(trait)\n    set_config_if_not_none(c.KubeSpawner, trait, \"singleuser.\" + cfg_key)\n\nimage = get_config(\"singleuser.image.name\")\nif image:\n    tag = get_config(\"singleuser.image.tag\")\n    if tag:\n        image = \"{}:{}\".format(image, tag)\n\n    c.KubeSpawner.image = image\n\n# Combine imagePullSecret.create (single), imagePullSecrets (list), and\n# singleuser.image.pullSecrets (list).\nimage_pull_secrets = []\nif get_config(\"imagePullSecret.automaticReferenceInjection\") and (\n    get_config(\"imagePullSecret.create\") or get_config(\"imagePullSecret.enabled\")\n):\n    image_pull_secrets.append(\"image-pull-secret\")\nif get_config(\"imagePullSecrets\"):\n    image_pull_secrets.extend(get_config(\"imagePullSecrets\"))\nif get_config(\"singleuser.image.pullSecrets\"):\n    image_pull_secrets.extend(get_config(\"singleuser.image.pullSecrets\"))\nif image_pull_secrets:\n    c.KubeSpawner.image_pull_secrets = image_pull_secrets\n\n# scheduling:\nif get_config(\"scheduling.userScheduler.enabled\"):\n    c.KubeSpawner.scheduler_name = os.environ[\"HELM_RELEASE_NAME\"] + \"-user-scheduler\"\nif get_config(\"scheduling.podPriority.enabled\"):\n    c.KubeSpawner.priority_class_name = (\n        os.environ[\"HELM_RELEASE_NAME\"] + \"-default-priority\"\n    )\n\n# add node-purpose affinity\nmatch_node_purpose = get_config(\"scheduling.userPods.nodeAffinity.matchNodePurpose\")\nif match_node_purpose:\n    node_selector = dict(\n        matchExpressions=[\n            dict(\n                key=\"hub.jupyter.org/node-purpose\",\n                operator=\"In\",\n                values=[\"user\"],\n            )\n        ],\n    )\n    if match_node_purpose == \"prefer\":\n        c.KubeSpawner.node_affinity_preferred.append(\n            dict(\n                weight=100,\n                preference=node_selector,\n            ),\n        )\n    elif match_node_purpose == \"require\":\n        c.KubeSpawner.node_affinity_required.append(node_selector)\n    elif match_node_purpose == \"ignore\":\n        pass\n    else:\n        raise ValueError(\n            \"Unrecognized value for matchNodePurpose: %r\" % match_node_purpose\n        )\n\n# add dedicated-node toleration\nfor key in (\n    \"hub.jupyter.org/dedicated\",\n    # workaround GKE not supporting / in initial node taints\n    \"hub.jupyter.org_dedicated\",\n):\n    c.KubeSpawner.tolerations.append(\n        dict(\n            key=key,\n            operator=\"Equal\",\n            value=\"user\",\n            effect=\"NoSchedule\",\n        )\n    )\n\n# Configure dynamically provisioning pvc\nstorage_type = get_config(\"singleuser.storage.type\")\n\nif storage_type == \"dynamic\":\n    pvc_name_template = get_config(\"singleuser.storage.dynamic.pvcNameTemplate\")\n    c.KubeSpawner.pvc_name_template = pvc_name_template\n    volume_name_template = get_config(\"singleuser.storage.dynamic.volumeNameTemplate\")\n    c.KubeSpawner.storage_pvc_ensure = True\n    set_config_if_not_none(\n        c.KubeSpawner, \"storage_class\", \"singleuser.storage.dynamic.storageClass\"\n    )\n    set_config_if_not_none(\n        c.KubeSpawner,\n        \"storage_access_modes\",\n        \"singleuser.storage.dynamic.storageAccessModes\",\n    )\n    set_config_if_not_none(\n        c.KubeSpawner, \"storage_capacity\", \"singleuser.storage.capacity\"\n    )\n\n    # Add volumes to singleuser pods\n    c.KubeSpawner.volumes = [\n        {\n            \"name\": volume_name_template,\n            \"persistentVolumeClaim\": {\"claimName\": pvc_name_template},\n        }\n    ]\n    c.KubeSpawner.volume_mounts = [\n        {\n            \"mountPath\": get_config(\"singleuser.storage.homeMountPath\"),\n            \"name\": volume_name_template,\n        }\n    ]\nelif storage_type == \"static\":\n    pvc_claim_name = get_config(\"singleuser.storage.static.pvcName\")\n    c.KubeSpawner.volumes = [\n        {\"name\": \"home\", \"persistentVolumeClaim\": {\"claimName\": pvc_claim_name}}\n    ]\n\n    c.KubeSpawner.volume_mounts = [\n        {\n            \"mountPath\": get_config(\"singleuser.storage.homeMountPath\"),\n            \"name\": \"home\",\n            \"subPath\": get_config(\"singleuser.storage.static.subPath\"),\n        }\n    ]\n\nc.KubeSpawner.volumes.extend(get_config(\"singleuser.storage.extraVolumes\", []))\nc.KubeSpawner.volume_mounts.extend(\n    get_config(\"singleuser.storage.extraVolumeMounts\", [])\n)\n\nc.JupyterHub.services = []\n\nif get_config(\"cull.enabled\", False):\n    cull_cmd = [\"python3\", \"-m\", \"jupyterhub_idle_culler\"]\n    base_url = c.JupyterHub.get(\"base_url\", \"/\")\n    cull_cmd.append(\"--url=http://localhost:8081\" + url_path_join(base_url, \"hub/api\"))\n\n    cull_timeout = get_config(\"cull.timeout\")\n    if cull_timeout:\n        cull_cmd.append(\"--timeout=%s\" % cull_timeout)\n\n    cull_every = get_config(\"cull.every\")\n    if cull_every:\n        cull_cmd.append(\"--cull-every=%s\" % cull_every)\n\n    cull_concurrency = get_config(\"cull.concurrency\")\n    if cull_concurrency:\n        cull_cmd.append(\"--concurrency=%s\" % cull_concurrency)\n\n    if get_config(\"cull.users\"):\n        cull_cmd.append(\"--cull-users\")\n\n    if get_config(\"cull.removeNamedServers\"):\n        cull_cmd.append(\"--remove-named-servers\")\n\n    cull_max_age = get_config(\"cull.maxAge\")\n    if cull_max_age:\n        cull_cmd.append(\"--max-age=%s\" % cull_max_age)\n\n    c.JupyterHub.services.append(\n        {\n            \"name\": \"cull-idle\",\n            \"admin\": True,\n            \"command\": cull_cmd,\n        }\n    )\n\nfor name, service in get_config(\"hub.services\", {}).items():\n    # jupyterhub.services is a list of dicts, but\n    # in the helm chart it is a dict of dicts for easier merged-config\n    service.setdefault(\"name\", name)\n    # handle camelCase->snake_case of api_token\n    api_token = service.pop(\"apiToken\", None)\n    if api_token:\n        service[\"api_token\"] = api_token\n    c.JupyterHub.services.append(service)\n\n\nset_config_if_not_none(c.Spawner, \"cmd\", \"singleuser.cmd\")\nset_config_if_not_none(c.Spawner, \"default_url\", \"singleuser.defaultUrl\")\n\ncloud_metadata = get_config(\"singleuser.cloudMetadata\", {})\n\nif (\n    cloud_metadata.get(\"blockWithIptables\") == True\n    or cloud_metadata.get(\"enabled\") == False\n):\n    # Use iptables to block access to cloud metadata by default\n    network_tools_image_name = get_config(\"singleuser.networkTools.image.name\")\n    network_tools_image_tag = get_config(\"singleuser.networkTools.image.tag\")\n    ip_block_container = client.V1Container(\n        name=\"block-cloud-metadata\",\n        image=f\"{network_tools_image_name}:{network_tools_image_tag}\",\n        command=[\n            \"iptables\",\n            \"-A\",\n            \"OUTPUT\",\n            \"-d\",\n            cloud_metadata.get(\"ip\", \"169.254.169.254\"),\n            \"-j\",\n            \"DROP\",\n        ],\n        security_context=client.V1SecurityContext(\n            privileged=True,\n            run_as_user=0,\n            capabilities=client.V1Capabilities(add=[\"NET_ADMIN\"]),\n        ),\n    )\n\n    c.KubeSpawner.init_containers.append(ip_block_container)\n\n\nif get_config(\"debug.enabled\", False):\n    c.JupyterHub.log_level = \"DEBUG\"\n    c.Spawner.debug = True\n\n\n# load hub.config values\nfor section, sub_cfg in get_config(\"hub.config\", {}).items():\n    c[section].update(sub_cfg)\n\n# execute hub.extraConfig string\nextra_config = get_config(\"hub.extraConfig\", {})\nif isinstance(extra_config, str):\n    from textwrap import indent, dedent\n\n    msg = dedent(\n        \"\"\"\n    hub.extraConfig should be a dict of strings,\n    but found a single string instead.\n\n    extraConfig as a single string is deprecated\n    as of the jupyterhub chart version 0.6.\n\n    The keys can be anything identifying the\n    block of extra configuration.\n\n    Try this instead:\n\n        hub:\n          extraConfig:\n            myConfig: |\n              {}\n\n    This configuration will still be loaded,\n    but you are encouraged to adopt the nested form\n    which enables easier merging of multiple extra configurations.\n    \"\"\"\n    )\n    print(msg.format(indent(extra_config, \" \" * 10).lstrip()), file=sys.stderr)\n    extra_config = {\"deprecated string\": extra_config}\n\nfor key, config_py in sorted(extra_config.items()):\n    print(\"Loading extra config: %s\" % key)\n    exec(config_py)\n",
      "z2jh.py": "\"\"\"\nUtility methods for use in jupyterhub_config.py and dynamic subconfigs.\n\nMethods here can be imported by extraConfig in values.yaml\n\"\"\"\nfrom collections import Mapping\nfrom functools import lru_cache\nimport os\n\nimport yaml\n\n\n# memoize so we only load config once\n@lru_cache()\ndef _load_config():\n    \"\"\"Load configuration from disk\n\n    Memoized to only load once\n    \"\"\"\n    cfg = {}\n    for source in (\"config\", \"secret\"):\n        path = f\"/etc/jupyterhub/{source}/values.yaml\"\n        if os.path.exists(path):\n            print(f\"Loading {path}\")\n            with open(path) as f:\n                values = yaml.safe_load(f)\n            cfg = _merge_dictionaries(cfg, values)\n        else:\n            print(f\"No config at {path}\")\n    return cfg\n\n\ndef _merge_dictionaries(a, b):\n    \"\"\"Merge two dictionaries recursively.\n\n    Simplified From https://stackoverflow.com/a/7205107\n    \"\"\"\n    merged = a.copy()\n    for key in b:\n        if key in a:\n            if isinstance(a[key], Mapping) and isinstance(b[key], Mapping):\n                merged[key] = _merge_dictionaries(a[key], b[key])\n            else:\n                merged[key] = b[key]\n        else:\n            merged[key] = b[key]\n    return merged\n\n\ndef get_config(key, default=None):\n    \"\"\"\n    Find a config item of a given name & return it\n\n    Parses everything as YAML, so lists and dicts are available too\n\n    get_config(\"a.b.c\") returns config['a']['b']['c']\n    \"\"\"\n    value = _load_config()\n    # resolve path in yaml\n    for level in key.split(\".\"):\n        if not isinstance(value, dict):\n            # a parent is a scalar or null,\n            # can't resolve full path\n            return default\n        if level not in value:\n            return default\n        else:\n            value = value[level]\n    return value\n\n\ndef set_config_if_not_none(cparent, name, key):\n    \"\"\"\n    Find a config item of a given name, set the corresponding Jupyter\n    configuration item if not None\n    \"\"\"\n    data = get_config(key)\n    if data is not None:\n        setattr(cparent, name, data)\n"
    }
  },
  {
    "kind": "ConfigMap",
    "apiVersion": "v1",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "data": {
      "config.yaml": "apiVersion: kubescheduler.config.k8s.io/v1beta1\nkind: KubeSchedulerConfiguration\nleaderElection:\n  resourceLock: endpoints\n  resourceName: user-scheduler-lock\n  resourceNamespace: default\nprofiles:\n  - schedulerName: release-name-user-scheduler\n    plugins:\n      score:\n        disabled:\n        - name: SelectorSpread\n        - name: TaintToleration\n        - name: PodTopologySpread\n        - name: NodeResourcesBalancedAllocation\n        - name: NodeResourcesLeastAllocated\n        - name: NodePreferAvoidPods\n        - name: NodeAffinity\n        - name: InterPodAffinity\n        - name: ImageLocality\n        enabled:\n        - name: NodePreferAvoidPods\n          weight: 161051\n        - name: NodeAffinity\n          weight: 14631\n        - name: InterPodAffinity\n          weight: 1331\n        - name: NodeResourcesMostAllocated\n          weight: 121\n        - name: ImageLocality\n          weight: 11\n",
      "policy.cfg": "{\"alwaysCheckAllPredicates\":false,\"apiVersion\":\"v1\",\"hardPodAffinitySymmetricWeight\":100,\"kind\":\"Policy\",\"predicates\":[{\"name\":\"PodFitsResources\"},{\"name\":\"HostName\"},{\"name\":\"PodFitsHostPorts\"},{\"name\":\"MatchNodeSelector\"},{\"name\":\"NoDiskConflict\"},{\"name\":\"PodToleratesNodeTaints\"},{\"name\":\"MaxEBSVolumeCount\"},{\"name\":\"MaxGCEPDVolumeCount\"},{\"name\":\"MaxAzureDiskVolumeCount\"},{\"name\":\"MaxCSIVolumeCountPred\"},{\"name\":\"CheckVolumeBinding\"},{\"name\":\"NoVolumeZoneConflict\"},{\"name\":\"MatchInterPodAffinity\"}],\"priorities\":[{\"name\":\"NodePreferAvoidPodsPriority\",\"weight\":161051},{\"name\":\"NodeAffinityPriority\",\"weight\":14641},{\"name\":\"InterPodAffinityPriority\",\"weight\":1331},{\"name\":\"MostRequestedPriority\",\"weight\":121},{\"name\":\"ImageLocalityPriority\",\"weight\":11}]}"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-keycloa-env-vars",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "keycloak",
        "helm.sh/chart": "keycloak-2.4.8",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "keycloak"
      }
    },
    "data": {
      "KEYCLOAK_CREATE_ADMIN_USER": "true",
      "KEYCLOAK_ADMIN_USER": "admin",
      "KEYCLOAK_MANAGEMENT_USER": "manager",
      "KEYCLOAK_HTTP_PORT": "8080",
      "KEYCLOAK_PROXY_ADDRESS_FORWARDING": "false",
      "KEYCLOAK_ENABLE_STATISTICS": "false",
      "KEYCLOAK_DATABASE_HOST": "fadi-postgresql",
      "KEYCLOAK_DATABASE_PORT": "5432",
      "KEYCLOAK_DATABASE_NAME": "postgres",
      "KEYCLOAK_DATABASE_USER": "admin",
      "KEYCLOAK_CACHE_OWNERS_COUNT": "1",
      "KEYCLOAK_AUTH_CACHE_OWNERS_COUNT": "1",
      "KEYCLOAK_ENABLE_TLS": "false"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-nifi-config",
      "labels": {
        "app": "nifi",
        "chart": "nifi-1.0.6",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "data": {
      "authorizers.xml": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n-->\n<!--\n    This file lists the userGroupProviders, accessPolicyProviders, and authorizers to use when running securely. In order\n    to use a specific authorizer it must be configured here and it's identifier must be specified in the nifi.properties file.\n    If the authorizer is a managedAuthorizer, it may need to be configured with an accessPolicyProvider and an userGroupProvider.\n    This file allows for configuration of them, but they must be configured in order:\n    ...\n    all userGroupProviders\n    all accessPolicyProviders\n    all Authorizers\n    ...\n-->\n<authorizers>\n    <!--\n        The FileUserGroupProvider will provide support for managing users and groups which is backed by a file\n        on the local file system.\n        - Users File - The file where the FileUserGroupProvider will store users and groups.\n        - Legacy Authorized Users File - The full path to an existing authorized-users.xml that will be automatically\n            be used to load the users and groups into the Users File.\n        - Initial User Identity [unique key] - The identity of a users and systems to seed the Users File. The name of\n            each property must be unique, for example: \"Initial User Identity A\", \"Initial User Identity B\",\n            \"Initial User Identity C\" or \"Initial User Identity 1\", \"Initial User Identity 2\", \"Initial User Identity 3\"\n            NOTE: Any identity mapping rules specified in nifi.properties will also be applied to the user identities,\n            so the values should be the unmapped identities (i.e. full DN from a certificate).\n    -->\n    <userGroupProvider>\n        <identifier>file-user-group-provider</identifier>\n        <class>org.apache.nifi.authorization.FileUserGroupProvider</class>\n        <property name=\"Users File\">./auth-conf/users.xml</property>\n        <property name=\"Legacy Authorized Users File\"></property>\n        <property name=\"Initial User Identity 0\">CN=release-name-nifi-0.release-name-nifi-headless.default.svc.cluster.local, OU=NIFI</property>\n        <property name=\"Initial User Identity admin\">cn=admin,dc=ldap,dc=example,dc=be</property>\n    </userGroupProvider>\n    <!--\n        The LdapUserGroupProvider will retrieve users and groups from an LDAP server. The users and groups\n        are not configurable.\n        'Authentication Strategy' - How the connection to the LDAP server is authenticated. Possible\n            values are ANONYMOUS, SIMPLE, LDAPS, or START_TLS.\n        'Manager DN' - The DN of the manager that is used to bind to the LDAP server to search for users.\n        'Manager Password' - The password of the manager that is used to bind to the LDAP server to\n            search for users.\n        'TLS - Keystore' - Path to the Keystore that is used when connecting to LDAP using LDAPS or START_TLS.\n        'TLS - Keystore Password' - Password for the Keystore that is used when connecting to LDAP\n            using LDAPS or START_TLS.\n        'TLS - Keystore Type' - Type of the Keystore that is used when connecting to LDAP using\n            LDAPS or START_TLS (i.e. JKS or PKCS12).\n        'TLS - Truststore' - Path to the Truststore that is used when connecting to LDAP using LDAPS or START_TLS.\n        'TLS - Truststore Password' - Password for the Truststore that is used when connecting to\n            LDAP using LDAPS or START_TLS.\n        'TLS - Truststore Type' - Type of the Truststore that is used when connecting to LDAP using\n            LDAPS or START_TLS (i.e. JKS or PKCS12).\n        'TLS - Client Auth' - Client authentication policy when connecting to LDAP using LDAPS or START_TLS.\n            Possible values are REQUIRED, WANT, NONE.\n        'TLS - Protocol' - Protocol to use when connecting to LDAP using LDAPS or START_TLS. (i.e. TLS,\n            TLSv1.1, TLSv1.2, etc).\n        'TLS - Shutdown Gracefully' - Specifies whether the TLS should be shut down gracefully\n            before the target context is closed. Defaults to false.\n        'Referral Strategy' - Strategy for handling referrals. Possible values are FOLLOW, IGNORE, THROW.\n        'Connect Timeout' - Duration of connect timeout. (i.e. 10 secs).\n        'Read Timeout' - Duration of read timeout. (i.e. 10 secs).\n        'Url' - Space-separated list of URLs of the LDAP servers (i.e. ldap://<hostname>:<port>).\n        'Page Size' - Sets the page size when retrieving users and groups. If not specified, no paging is performed.\n        'Sync Interval' - Duration of time between syncing users and groups (i.e. 30 mins). Minimum allowable value is 10 secs.\n        'User Search Base' - Base DN for searching for users (i.e. ou=users,o=nifi). Required to search users.\n        'User Object Class' - Object class for identifying users (i.e. person). Required if searching users.\n        'User Search Scope' - Search scope for searching users (ONE_LEVEL, OBJECT, or SUBTREE). Required if searching users.\n        'User Search Filter' - Filter for searching for users against the 'User Search Base' (i.e. (memberof=cn=team1,ou=groups,o=nifi) ). Optional.\n        'User Identity Attribute' - Attribute to use to extract user identity (i.e. cn). Optional. If not set, the entire DN is used.\n        'User Group Name Attribute' - Attribute to use to define group membership (i.e. memberof). Optional. If not set\n            group membership will not be calculated through the users. Will rely on group membership being defined\n            through 'Group Member Attribute' if set. The value of this property is the name of the attribute in the user ldap entry that\n            associates them with a group. The value of that user attribute could be a dn or group name for instance. What value is expected\n            is configured in the 'User Group Name Attribute - Referenced Group Attribute'.\n        'User Group Name Attribute - Referenced Group Attribute' - If blank, the value of the attribute defined in 'User Group Name Attribute'\n            is expected to be the full dn of the group. If not blank, this property will define the attribute of the group ldap entry that\n            the value of the attribute defined in 'User Group Name Attribute' is referencing (i.e. name). Use of this property requires that\n            'Group Search Base' is also configured.\n        'Group Search Base' - Base DN for searching for groups (i.e. ou=groups,o=nifi). Required to search groups.\n        'Group Object Class' - Object class for identifying groups (i.e. groupOfNames). Required if searching groups.\n        'Group Search Scope' - Search scope for searching groups (ONE_LEVEL, OBJECT, or SUBTREE). Required if searching groups.\n        'Group Search Filter' - Filter for searching for groups against the 'Group Search Base'. Optional.\n        'Group Name Attribute' - Attribute to use to extract group name (i.e. cn). Optional. If not set, the entire DN is used.\n        'Group Member Attribute' - Attribute to use to define group membership (i.e. member). Optional. If not set\n            group membership will not be calculated through the groups. Will rely on group membership being defined\n            through 'User Group Name Attribute' if set. The value of this property is the name of the attribute in the group ldap entry that\n            associates them with a user. The value of that group attribute could be a dn or memberUid for instance. What value is expected\n            is configured in the 'Group Member Attribute - Referenced User Attribute'. (i.e. member: cn=User 1,ou=users,o=nifi vs. memberUid: user1)\n        'Group Member Attribute - Referenced User Attribute' - If blank, the value of the attribute defined in 'Group Member Attribute'\n            is expected to be the full dn of the user. If not blank, this property will define the attribute of the user ldap entry that\n            the value of the attribute defined in 'Group Member Attribute' is referencing (i.e. uid). Use of this property requires that\n            'User Search Base' is also configured. (i.e. member: cn=User 1,ou=users,o=nifi vs. memberUid: user1)\n        NOTE: Any identity mapping rules specified in nifi.properties will also be applied to the user identities.\n            Group names are not mapped.\n    -->\n    <userGroupProvider>\n        <identifier>ldap-user-group-provider</identifier>\n        <class>org.apache.nifi.ldap.tenants.LdapUserGroupProvider</class>\n        <property name=\"Authentication Strategy\">SIMPLE</property>\n        <property name=\"Manager DN\">cn=admin,dc=ldap,dc=example,dc=be</property>\n        <property name=\"Manager Password\">Z2JHHezi4aAA</property>\n        <property name=\"TLS - Keystore\">/opt/nifi/nifi-current/conf/release-name-nifi-0.release-name-nifi-headless..svc.cluster.local/keystore.jks</property>\n        <property name=\"TLS - Keystore Password\">changeMe</property>\n        <property name=\"TLS - Keystore Type\">jks</property>\n        <property name=\"TLS - Truststore\">/opt/nifi/nifi-current/conf/release-name-nifi-0.release-name-nifi-headless..svc.cluster.local/truststore.jks</property>\n        <property name=\"TLS - Truststore Password\">changeMe</property>\n        <property name=\"TLS - Truststore Type\">JKS</property>\n        <property name=\"TLS - Client Auth\">NONE</property>\n        <property name=\"TLS - Protocol\">TLS</property>\n        <property name=\"TLS - Shutdown Gracefully\">false</property>\n        <property name=\"Referral Strategy\">IGNORE</property>\n        <property name=\"Connect Timeout\">10 secs</property>\n        <property name=\"Read Timeout\">10 secs</property>\n        <property name=\"Url\">ldap://fadi-openldap:389</property>\n        <property name=\"Page Size\"></property>\n        <property name=\"Sync Interval\">30 mins</property>\n        <property name=\"User Search Base\">cn=admin,dc=ldap,dc=cetic,dc=be</property>\n        <property name=\"User Object Class\">person</property>\n        <property name=\"User Search Scope\">ONE_LEVEL</property>\n        <property name=\"User Search Filter\">(objectClass=*)</property>\n        <property name=\"User Identity Attribute\"></property>\n        <property name=\"User Group Name Attribute\"></property>\n        <property name=\"User Group Name Attribute - Referenced Group Attribute\"></property>\n        <property name=\"Group Search Base\"></property>\n        <property name=\"Group Object Class\">group</property>\n        <property name=\"Group Search Scope\">ONE_LEVEL</property>\n        <property name=\"Group Search Filter\"></property>\n        <property name=\"Group Name Attribute\"></property>\n        <property name=\"Group Member Attribute\"></property>\n        <property name=\"Group Member Attribute - Referenced User Attribute\"></property>\n    </userGroupProvider>\n\n    <!--\n        The CompositeUserGroupProvider will provide support for retrieving users and groups from multiple sources.\n        - User Group Provider [unique key] - The identifier of user group providers to load from. The name of\n            each property must be unique, for example: \"User Group Provider A\", \"User Group Provider B\",\n            \"User Group Provider C\" or \"User Group Provider 1\", \"User Group Provider 2\", \"User Group Provider 3\"\n            NOTE: Any identity mapping rules specified in nifi.properties are not applied in this implementation. This behavior\n            would need to be applied by the base implementation.\n    -->\n    <userGroupProvider>\n        <identifier>composite-configurable-user-group-provider</identifier>\n        <class>org.apache.nifi.authorization.CompositeConfigurableUserGroupProvider</class>\n        <property name=\"Configurable User Group Provider\">file-user-group-provider</property>\n        <property name=\"User Group Provider 1\">ldap-user-group-provider</property>\n    </userGroupProvider>\n\n    <!--\n        The CompositeConfigurableUserGroupProvider will provide support for retrieving users and groups from multiple sources.\n        Additionally, a single configurable user group provider is required. Users from the configurable user group provider\n        are configurable, however users loaded from one of the User Group Provider [unique key] will not be.\n        - Configurable User Group Provider - A configurable user group provider.\n        - User Group Provider [unique key] - The identifier of user group providers to load from. The name of\n            each property must be unique, for example: \"User Group Provider A\", \"User Group Provider B\",\n            \"User Group Provider C\" or \"User Group Provider 1\", \"User Group Provider 2\", \"User Group Provider 3\"\n            NOTE: Any identity mapping rules specified in nifi.properties are not applied in this implementation. This behavior\n            would need to be applied by the base implementation.\n    -->\n    <!-- To enable the composite-configurable-user-group-provider remove 2 lines. This is 1 of 2.\n    <userGroupProvider>\n        <identifier>composite-configurable-user-group-provider</identifier>\n        <class>org.apache.nifi.authorization.CompositeConfigurableUserGroupProvider</class>\n        <property name=\"Configurable User Group Provider\">file-user-group-provider</property>\n        <property name=\"User Group Provider 1\"></property>\n    </userGroupProvider>\n    To enable the composite-configurable-user-group-provider remove 2 lines. This is 2 of 2. -->\n\n    <!--\n        The FileAccessPolicyProvider will provide support for managing access policies which is backed by a file\n        on the local file system.\n        - User Group Provider - The identifier for an User Group Provider defined above that will be used to access\n            users and groups for use in the managed access policies.\n        - Authorizations File - The file where the FileAccessPolicyProvider will store policies.\n        - Initial Admin Identity - The identity of an initial admin user that will be granted access to the UI and\n            given the ability to create additional users, groups, and policies. The value of this property could be\n            a DN when using certificates or LDAP, or a Kerberos principal. This property will only be used when there\n            are no other policies defined. If this property is specified then a Legacy Authorized Users File can not be specified.\n            NOTE: Any identity mapping rules specified in nifi.properties will also be applied to the initial admin identity,\n            so the value should be the unmapped identity. This identity must be found in the configured User Group Provider.\n        - Legacy Authorized Users File - The full path to an existing authorized-users.xml that will be automatically\n            converted to the new authorizations model. If this property is specified then an Initial Admin Identity can\n            not be specified, and this property will only be used when there are no other users, groups, and policies defined.\n            NOTE: Any users in the legacy users file must be found in the configured User Group Provider.\n        - Node Identity [unique key] - The identity of a NiFi cluster node. When clustered, a property for each node\n            should be defined, so that every node knows about every other node. If not clustered these properties can be ignored.\n            The name of each property must be unique, for example for a three node cluster:\n            \"Node Identity A\", \"Node Identity B\", \"Node Identity C\" or \"Node Identity 1\", \"Node Identity 2\", \"Node Identity 3\"\n            NOTE: Any identity mapping rules specified in nifi.properties will also be applied to the node identities,\n            so the values should be the unmapped identities (i.e. full DN from a certificate). This identity must be found\n            in the configured User Group Provider.\n    -->\n    <accessPolicyProvider>\n        <identifier>file-access-policy-provider</identifier>\n        <class>org.apache.nifi.authorization.FileAccessPolicyProvider</class>\n        <property name=\"User Group Provider\">file-user-group-provider</property>\n        <property name=\"Authorizations File\">./auth-conf/authorizations.xml</property>\n        <property name=\"Initial Admin Identity\">cn=admin,dc=ldap,dc=example,dc=be</property>\n        <property name=\"Legacy Authorized Users File\"></property>\n        <property name=\"Node Identity 0\">CN=release-name-nifi-0.release-name-nifi-headless.default.svc.cluster.local, OU=NIFI</property>\n        <property name=\"Node Identity\"></property>\n    </accessPolicyProvider>\n     <!--\n        The StandardManagedAuthorizer. This authorizer implementation must be configured with the\n        Access Policy Provider which it will use to access and manage users, groups, and policies.\n        These users, groups, and policies will be used to make all access decisions during authorization\n        requests.\n        - Access Policy Provider - The identifier for an Access Policy Provider defined above.\n    -->\n    <authorizer>\n        <identifier>managed-authorizer</identifier>\n        <class>org.apache.nifi.authorization.StandardManagedAuthorizer</class>\n        <property name=\"Access Policy Provider\">file-access-policy-provider</property>\n    </authorizer>\n    <!--\n        NOTE: This Authorizer has been replaced with the more granular approach configured above with the Standard\n        Managed Authorizer. However, it is still available for backwards compatibility reasons.\n        The FileAuthorizer is NiFi's provided authorizer and has the following properties:\n        - Authorizations File - The file where the FileAuthorizer will store policies.\n        - Users File - The file where the FileAuthorizer will store users and groups.\n        - Initial Admin Identity - The identity of an initial admin user that will be granted access to the UI and\n            given the ability to create additional users, groups, and policies. The value of this property could be\n            a DN when using certificates or LDAP, or a Kerberos principal. This property will only be used when there\n            are no other users, groups, and policies defined. If this property is specified then a Legacy Authorized\n            Users File can not be specified.\n            NOTE: Any identity mapping rules specified in nifi.properties will also be applied to the initial admin identity,\n            so the value should be the unmapped identity.\n        - Legacy Authorized Users File - The full path to an existing authorized-users.xml that will be automatically\n            converted to the new authorizations model. If this property is specified then an Initial Admin Identity can\n            not be specified, and this property will only be used when there are no other users, groups, and policies defined.\n        - Node Identity [unique key] - The identity of a NiFi cluster node. When clustered, a property for each node\n            should be defined, so that every node knows about every other node. If not clustered these properties can be ignored.\n            The name of each property must be unique, for example for a three node cluster:\n            \"Node Identity A\", \"Node Identity B\", \"Node Identity C\" or \"Node Identity 1\", \"Node Identity 2\", \"Node Identity 3\"\n            NOTE: Any identity mapping rules specified in nifi.properties will also be applied to the node identities,\n            so the values should be the unmapped identities (i.e. full DN from a certificate).\n    -->\n    <authorizer>\n        <identifier>file-provider</identifier>\n        <class>org.apache.nifi.authorization.FileAuthorizer</class>\n        <property name=\"Authorizations File\">./auth-conf/authorizations.xml</property>\n        <property name=\"Users File\">./auth-conf/users.xml</property>\n        <property name=\"Initial Admin Identity\">cn=admin,dc=ldap,dc=example,dc=be</property>\n        <property name=\"Legacy Authorized Users File\"></property>\n\n    </authorizer>\n</authorizers>\n",
      "bootstrap-notification-services.xml": "<?xml version=\"1.0\"?>\n<!--\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n-->\n<services>\n    <!-- This file is used to define how interested parties are notified when events in NiFi's lifecycle occur. -->\n    <!-- The format of this file is:\n        <services>\n            <service>\n                <id>service-identifier</id>\n                <class>org.apache.nifi.notifications.DesiredNotificationService</class>\n                <property name=\"property name\">property value</property>\n                <property name=\"another property\">another property value</property>\n            </service>\n        </services>\n        \n        This file can contain 0 to many different service definitions.\n        The id can then be referenced from the bootstrap.conf file in order to configure the notification service\n        to be used when particular lifecycle events occur.\n    -->\n    \n<!--\n     <service>\n        <id>email-notification</id>\n        <class>org.apache.nifi.bootstrap.notification.email.EmailNotificationService</class>\n        <property name=\"SMTP Hostname\"></property>\n        <property name=\"SMTP Port\"></property>\n        <property name=\"SMTP Username\"></property>\n        <property name=\"SMTP Password\"></property>\n        <property name=\"SMTP TLS\"></property>\n        <property name=\"From\"></property>\n        <property name=\"To\"></property>\n     </service>\n-->\n<!--\n     <service>\n        <id>http-notification</id>\n        <class>org.apache.nifi.bootstrap.notification.http.HttpNotificationService</class>\n        <property name=\"URL\"></property>\n     </service>\n-->\n</services>\n",
      "bootstrap.conf": "#\n# Licensed to the Apache Software Foundation (ASF) under one or more\n# contributor license agreements.  See the NOTICE file distributed with\n# this work for additional information regarding copyright ownership.\n# The ASF licenses this file to You under the Apache License, Version 2.0\n# (the \"License\"); you may not use this file except in compliance with\n# the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n\n# Java command to use when running NiFi\njava=java\n\n# Username to use when running NiFi. This value will be ignored on Windows.\nrun.as=\n\n# Configure where NiFi's lib and conf directories live\nlib.dir=./lib\nconf.dir=./conf\n\n# How long to wait after telling NiFi to shutdown before explicitly killing the Process\ngraceful.shutdown.seconds=20\n\n# Disable JSR 199 so that we can use JSP's without running a JDK\njava.arg.1=-Dorg.apache.jasper.compiler.disablejsr199=true\n\n# JVM memory settings\njava.arg.2=-Xms2g\njava.arg.3=-Xmx2g\n\n# Enable Remote Debugging\n#java.arg.debug=-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000\n\njava.arg.4=-Djava.net.preferIPv4Stack=true\n\n# allowRestrictedHeaders is required for Cluster/Node communications to work properly\njava.arg.5=-Dsun.net.http.allowRestrictedHeaders=true\njava.arg.6=-Djava.protocol.handler.pkgs=sun.net.www.protocol\n\n# The G1GC is still considered experimental but has proven to be very advantageous in providing great\n# performance without significant \"stop-the-world\" delays.\n#java.arg.13=-XX:+UseG1GC\n\n#Set headless mode by default\njava.arg.14=-Djava.awt.headless=true\n\n# Master key in hexadecimal format for encrypted sensitive configuration values\nnifi.bootstrap.sensitive.key=\n\n# Sets the provider of SecureRandom to /dev/urandom to prevent blocking on VMs\njava.arg.15=-Djava.security.egd=file:/dev/urandom\n\n###\n# Notification Services for notifying interested parties when NiFi is stopped, started, dies\n###\n\n# XML File that contains the definitions of the notification services\nnotification.services.file=./conf/bootstrap-notification-services.xml\n\n# In the case that we are unable to send a notification for an event, how many times should we retry?\nnotification.max.attempts=5\n\n# Comma-separated list of identifiers that are present in the notification.services.file; which services should be used to notify when NiFi is started?\n#nifi.start.notification.services=email-notification\n\n# Comma-separated list of identifiers that are present in the notification.services.file; which services should be used to notify when NiFi is stopped?\n#nifi.stop.notification.services=email-notification\n\n# Comma-separated list of identifiers that are present in the notification.services.file; which services should be used to notify when NiFi dies?\n#nifi.dead.notification.services=email-notification\n\n\n",
      "flow.xml": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<flowController encoding-version=\"1.3\">\n    <maxTimerDrivenThreadCount>10</maxTimerDrivenThreadCount>\n    <maxEventDrivenThreadCount>5</maxEventDrivenThreadCount>\n    <registries>\n        <flowRegistry>\n            <id>b13d1c8b-ba14-44b5-9376-b0e981edb500</id>\n            <name>default</name>\n            <url>http://:80</url>\n            <description/>\n        </flowRegistry>\n    </registries>\n    <rootGroup>\n        <id>ef593595-355d-49ee-a5d7-75fe4d7674f4</id>\n        <name>Nifi Flow</name>\n        <position x=\"0.0\" y=\"0.0\"/>\n        <comment/>\n    </rootGroup>\n    <controllerServices/>\n    <reportingTasks/>\n</flowController>\n",
      "login-identity-providers-ldap.xml": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!--\n  Licensed to the Apache Software Foundation (ASF) under one or more\n  contributor license agreements.  See the NOTICE file distributed with\n  this work for additional information regarding copyright ownership.\n  The ASF licenses this file to You under the Apache License, Version 2.0\n  (the \"License\"); you may not use this file except in compliance with\n  the License.  You may obtain a copy of the License at\n      http://www.apache.org/licenses/LICENSE-2.0\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n-->\n<!--\n    This file lists the login identity providers to use when running securely. In order\n    to use a specific provider it must be configured here and it's identifier\n    must be specified in the nifi.properties file.\n-->\n<loginIdentityProviders>\n    <!--\n        Identity Provider for users logging in with username/password against an LDAP server.\n        \n        'Authentication Strategy' - How the connection to the LDAP server is authenticated. Possible\n            values are ANONYMOUS, SIMPLE, LDAPS, or START_TLS.\n        \n        'Manager DN' - The DN of the manager that is used to bind to the LDAP server to search for users.\n        'Manager Password' - The password of the manager that is used to bind to the LDAP server to\n            search for users.\n            \n        'TLS - Keystore' - Path to the Keystore that is used when connecting to LDAP using LDAPS or START_TLS.\n        'TLS - Keystore Password' - Password for the Keystore that is used when connecting to LDAP\n            using LDAPS or START_TLS.\n        'TLS - Keystore Type' - Type of the Keystore that is used when connecting to LDAP using\n            LDAPS or START_TLS (i.e. JKS or PKCS12).\n        'TLS - Truststore' - Path to the Truststore that is used when connecting to LDAP using LDAPS or START_TLS.\n        'TLS - Truststore Password' - Password for the Truststore that is used when connecting to\n            LDAP using LDAPS or START_TLS.\n        'TLS - Truststore Type' - Type of the Truststore that is used when connecting to LDAP using\n            LDAPS or START_TLS (i.e. JKS or PKCS12).\n        'TLS - Client Auth' - Client authentication policy when connecting to LDAP using LDAPS or START_TLS.\n            Possible values are REQUIRED, WANT, NONE.\n        'TLS - Protocol' - Protocol to use when connecting to LDAP using LDAPS or START_TLS. (i.e. TLS,\n            TLSv1.1, TLSv1.2, etc).\n        'TLS - Shutdown Gracefully' - Specifies whether the TLS should be shut down gracefully \n            before the target context is closed. Defaults to false.\n            \n        'Referral Strategy' - Strategy for handling referrals. Possible values are FOLLOW, IGNORE, THROW.\n        'Connect Timeout' - Duration of connect timeout. (i.e. 10 secs).\n        'Read Timeout' - Duration of read timeout. (i.e. 10 secs).\n       \n        'Url' - Space-separated list of URLs of the LDAP servers (i.e. ldap://<hostname>:<port>).\n        'User Search Base' - Base DN for searching for users (i.e. CN=Users,DC=example,DC=com).\n        'User Search Filter' - Filter for searching for users against the 'User Search Base'.\n            (i.e. sAMAccountName={0}). The user specified name is inserted into '{0}'.\n        'Identity Strategy' - Strategy to identify users. Possible values are USE_DN and USE_USERNAME.\n            The default functionality if this property is missing is USE_DN in order to retain\n            backward compatibility. USE_DN will use the full DN of the user entry if possible.\n            USE_USERNAME will use the username the user logged in with.\n        'Authentication Expiration' - The duration of how long the user authentication is valid\n            for. If the user never logs out, they will be required to log back in following\n            this duration.\n    -->\n    <provider>\n        <identifier>ldap-provider</identifier>\n        <class>org.apache.nifi.ldap.LdapProvider</class>\n        <property name=\"Authentication Strategy\">SIMPLE</property>\n        <property name=\"Manager DN\">cn=admin,dc=ldap,dc=example,dc=be</property>\n        <property name=\"Manager Password\">Z2JHHezi4aAA</property>\n        <property name=\"TLS - Keystore\">/opt/nifi/nifi-current/conf/release-name-nifi-0.release-name-nifi-headless.default.svc.cluster.local/keystore.jks</property>\n        <property name=\"TLS - Keystore Password\"></property>\n        <property name=\"TLS - Keystore Type\">JKS</property>\n        <property name=\"TLS - Truststore\">/opt/nifi/nifi-current/conf/release-name-nifi-0.release-name-nifi-headless.default.svc.cluster.local/truststore.jks</property>\n        <property name=\"TLS - Truststore Password\"></property>\n        <property name=\"TLS - Truststore Type\">JKS</property>\n        <property name=\"TLS - Client Auth\">NONE</property>\n        <property name=\"TLS - Protocol\">TLS</property>\n        <property name=\"TLS - Shutdown Gracefully\">false</property>\n\n        <property name=\"Referral Strategy\">FOLLOW</property>\n        <property name=\"Connect Timeout\">10 secs</property>\n        <property name=\"Read Timeout\">10 secs</property>\n        <property name=\"Url\">ldap://fadi-openldap:389</property>\n        <property name=\"User Search Base\">cn=admin,dc=ldap,dc=cetic,dc=be</property>\n        <property name=\"User Search Filter\">(cn={0})</property>\n        <property name=\"Identity Strategy\"></property>\n        <property name=\"Authentication Expiration\">12 hours</property>\n    </provider>\n</loginIdentityProviders>",
      "nifi.properties": "# Licensed to the Apache Software Foundation (ASF) under one or more\n# contributor license agreements.  See the NOTICE file distributed with\n# this work for additional information regarding copyright ownership.\n# The ASF licenses this file to You under the Apache License, Version 2.0\n# (the \"License\"); you may not use this file except in compliance with\n# the License.  You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Core Properties #\nnifi.flow.configuration.file=../data/flow.xml.gz\nnifi.flow.configuration.archive.enabled=true\nnifi.flow.configuration.archive.dir=../data/archive/\nnifi.flow.configuration.archive.max.time=30 days\nnifi.flow.configuration.archive.max.storage=500 MB\nnifi.flow.configuration.archive.max.count=\nnifi.flowcontroller.autoResumeState=true\nnifi.flowcontroller.graceful.shutdown.period=10 sec\nnifi.flowservice.writedelay.interval=500 ms\nnifi.administrative.yield.duration=30 sec\n# If a component has no work to do (is \"bored\"), how long should we wait before checking again for work?\nnifi.bored.yield.duration=10 millis\n\nnifi.authorizer.configuration.file=./conf/authorizers.xml\nnifi.login.identity.provider.configuration.file=./conf/login-identity-providers.xml\nnifi.templates.directory=../data/templates\nnifi.ui.banner.text=\nnifi.ui.autorefresh.interval=30 sec\nnifi.nar.library.directory=./lib\nnifi.nar.library.directory.custom=\nnifi.nar.library.autoload.directory=./extensions\nnifi.nar.working.directory=./work/nar/\nnifi.documentation.working.directory=./work/docs/components\n\n####################\n# State Management #\n####################\nnifi.state.management.configuration.file=./conf/state-management.xml\n# The ID of the local state provider\nnifi.state.management.provider.local=local-provider\n# The ID of the cluster-wide state provider. This will be ignored if NiFi is not clustered but must be populated if running in a cluster.\nnifi.state.management.provider.cluster=zk-provider\n# Specifies whether or not this instance of NiFi should run an embedded ZooKeeper server\nnifi.state.management.embedded.zookeeper.start=false\n# Properties file that provides the ZooKeeper properties to use if <nifi.state.management.embedded.zookeeper.start> is set to true\nnifi.state.management.embedded.zookeeper.properties=./conf/zookeeper.properties\n\n\n# H2 Settings\nnifi.database.directory=../data/database_repository\nnifi.h2.url.append=;LOCK_TIMEOUT=25000;WRITE_DELAY=0;AUTO_SERVER=FALSE\n\n# FlowFile Repository\nnifi.flowfile.repository.implementation=org.apache.nifi.controller.repository.WriteAheadFlowFileRepository\nnifi.flowfile.repository.directory=../flowfile_repository\nnifi.flowfile.repository.partitions=256\nnifi.flowfile.repository.checkpoint.interval=2 mins\nnifi.flowfile.repository.always.sync=false\n\nnifi.swap.manager.implementation=org.apache.nifi.controller.FileSystemSwapManager\nnifi.queue.swap.threshold=20000\nnifi.swap.in.period=5 sec\nnifi.swap.in.threads=1\nnifi.swap.out.period=5 sec\nnifi.swap.out.threads=4\n\n# Content Repository\nnifi.content.repository.implementation=org.apache.nifi.controller.repository.FileSystemRepository\nnifi.content.claim.max.appendable.size=1 MB\nnifi.content.claim.max.flow.files=100\nnifi.content.repository.directory.default=../content_repository\nnifi.content.repository.archive.max.retention.period=3 days\nnifi.content.repository.archive.max.usage.percentage=85%\nnifi.content.repository.archive.enabled=true\nnifi.content.repository.always.sync=false\nnifi.content.viewer.url=/nifi-content-viewer/\n\n# Provenance Repository Properties\nnifi.provenance.repository.implementation=org.apache.nifi.provenance.WriteAheadProvenanceRepository\nnifi.provenance.repository.debug.frequency=1_000_000\nnifi.provenance.repository.encryption.key.provider.implementation=\nnifi.provenance.repository.encryption.key.provider.location=\nnifi.provenance.repository.encryption.key.id=\nnifi.provenance.repository.encryption.key=\n\n# Persistent Provenance Repository Properties\nnifi.provenance.repository.directory.default=../provenance_repository\nnifi.provenance.repository.max.storage.time=10 days\nnifi.provenance.repository.max.storage.size=8 GB\nnifi.provenance.repository.rollover.time=30 secs\nnifi.provenance.repository.rollover.size=100 MB\nnifi.provenance.repository.query.threads=2\nnifi.provenance.repository.index.threads=2\nnifi.provenance.repository.compress.on.rollover=true\nnifi.provenance.repository.always.sync=false\nnifi.provenance.repository.journal.count=16\n# Comma-separated list of fields. Fields that are not indexed will not be searchable. Valid fields are:\n# EventType, FlowFileUUID, Filename, TransitURI, ProcessorID, AlternateIdentifierURI, Relationship, Details\nnifi.provenance.repository.indexed.fields=EventType, FlowFileUUID, Filename, ProcessorID, Relationship\n# FlowFile Attributes that should be indexed and made searchable.  Some examples to consider are filename, uuid, mime.type\nnifi.provenance.repository.indexed.attributes=\n# Large values for the shard size will result in more Java heap usage when searching the Provenance Repository\n# but should provide better performance\nnifi.provenance.repository.index.shard.size=500 MB\n# Indicates the maximum length that a FlowFile attribute can be when retrieving a Provenance Event from\n# the repository. If the length of any attribute exceeds this value, it will be truncated when the event is retrieved.\nnifi.provenance.repository.max.attribute.length=65536\n\n# Volatile Provenance Respository Properties\nnifi.provenance.repository.buffer.size=100000\n\n# Component Status Repository\nnifi.components.status.repository.implementation=org.apache.nifi.controller.status.history.VolatileComponentStatusRepository\nnifi.components.status.repository.buffer.size=1440\nnifi.components.status.snapshot.frequency=1 min\n\n# Site to Site properties\nnifi.remote.input.host=\nnifi.remote.input.secure=true\nnifi.remote.input.socket.port=10000\nnifi.remote.input.http.enabled=true\nnifi.remote.input.http.transaction.ttl=30 sec\nnifi.remote.contents.cache.expiration=30 secs\n\n# web properties #\nnifi.web.war.directory=./lib\nnifi.web.proxy.host=nifi.example.cetic.be\nnifi.web.https.port=8443\nnifi.web.http.host=\nnifi.web.http.network.interface.default=\nnifi.web.https.host=\nnifi.web.https.network.interface.default=\nnifi.web.jetty.working.directory=./work/jetty\nnifi.web.jetty.threads=200\n# nifi.web.proxy.context.path=\n\n# security properties #\nnifi.sensitive.props.key=changeMechangeMe\nnifi.sensitive.props.key.protected=\nnifi.sensitive.props.algorithm=NIFI_PBKDF2_AES_GCM_256\nnifi.sensitive.props.provider=BC\nnifi.sensitive.props.additional.keys=\n\n\nnifi.security.keystore=/opt/nifi/nifi-current/conf/release-name-nifi-0.release-name-nifi-headless.default.svc.cluster.local/keystore.jks\nnifi.security.keystoreType=jks\nnifi.security.keystorePasswd=changeMe\nnifi.security.keyPasswd=changeMe\nnifi.security.truststore=/opt/nifi/nifi-current/conf/release-name-nifi-0.release-name-nifi-headless.default.svc.cluster.local/truststore.jks\nnifi.security.truststoreType=jks\nnifi.security.truststorePasswd=changeMe\nproxiedEntity=cn=admin,dc=ldap,dc=example,dc=be\nnifi.security.user.authorizer=file-provider\nnifi.security.user.login.identity.provider=ldap-provider\n\nnifi.security.needClientAuth=\n\n\n\n\n# Apache Knox SSO Properties #\nnifi.security.user.knox.url=\nnifi.security.user.knox.publicKey=\nnifi.security.user.knox.cookieName=hadoop-jwt\nnifi.security.user.knox.audiences=\n\n# Identity Mapping Properties #\n# These properties allow normalizing user identities such that identities coming from different identity providers\n# (certificates, LDAP, Kerberos) can be treated the same internally in NiFi. The following example demonstrates normalizing\n# DNs from certificates and principals from Kerberos into a common identity string:\n#\n# nifi.security.identity.mapping.pattern.dn=^CN=(.*?), OU=(.*?), O=(.*?), L=(.*?), ST=(.*?), C=(.*?)$\n# nifi.security.identity.mapping.value.dn=$1@$2\n# nifi.security.identity.mapping.pattern.kerb=^(.*?)/instance@(.*?)$\n# nifi.security.identity.mapping.value.kerb=$1@$2\n\n# cluster common properties (all nodes must have same values) #\nnifi.cluster.protocol.heartbeat.interval=5 sec\nnifi.cluster.protocol.is.secure=true\n\n# cluster node properties (only configure for cluster nodes) #\nnifi.cluster.is.node=false\nnifi.cluster.node.address=\nnifi.cluster.node.protocol.port=6007\nnifi.cluster.node.protocol.threads=10\nnifi.cluster.node.protocol.max.threads=50\nnifi.cluster.node.event.history.size=25\nnifi.cluster.node.connection.timeout=5 sec\nnifi.cluster.node.read.timeout=5 sec\nnifi.cluster.node.max.concurrent.requests=100\nnifi.cluster.firewall.file=\nnifi.cluster.flow.election.max.wait.time=1 mins\nnifi.cluster.flow.election.max.candidates=\n\n# zookeeper properties, used for cluster management #\nnifi.zookeeper.connect.string=\nnifi.zookeeper.connect.timeout=3 secs\nnifi.zookeeper.session.timeout=3 secs\nnifi.zookeeper.root.node=/nifi\n\n# Zookeeper properties for the authentication scheme used when creating acls on znodes used for cluster management\n# Values supported for nifi.zookeeper.auth.type are \"default\", which will apply world/anyone rights on znodes\n# and \"sasl\" which will give rights to the sasl/kerberos identity used to authenticate the nifi node\n# The identity is determined using the value in nifi.kerberos.service.principal and the removeHostFromPrincipal\n# and removeRealmFromPrincipal values (which should align with the kerberos.removeHostFromPrincipal and kerberos.removeRealmFromPrincipal\n# values configured on the zookeeper server).\nnifi.zookeeper.auth.type=\nnifi.zookeeper.kerberos.removeHostFromPrincipal=\nnifi.zookeeper.kerberos.removeRealmFromPrincipal=\n\n# kerberos #\nnifi.kerberos.krb5.file=\n\n# kerberos service principal #\nnifi.kerberos.service.principal=\nnifi.kerberos.service.keytab.location=\n\n# kerberos spnego principal #\nnifi.kerberos.spnego.principal=\nnifi.kerberos.spnego.keytab.location=\nnifi.kerberos.spnego.authentication.expiration=12 hours\n\n# external properties files for variable registry\n# supports a comma delimited list of file locations\nnifi.variable.registry.properties=\n",
      "state-management.xml": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<stateManagement>\n    <local-provider>\n        <id>local-provider</id>\n        <class>org.apache.nifi.controller.state.providers.local.WriteAheadLocalStateProvider</class>\n        <property name=\"Directory\">./state/local</property>\n        <property name=\"Always Sync\">false</property>\n        <property name=\"Partitions\">16</property>\n        <property name=\"Checkpoint Interval\">2 mins</property>\n    </local-provider>\n    <cluster-provider>\n        <id>zk-provider</id>\n        <class>org.apache.nifi.controller.state.providers.zookeeper.ZooKeeperStateProvider</class>\n        <property name=\"Connect String\">release-name-zookeeper:2181</property>\n        <property name=\"Root Node\">/nifi</property>\n        <property name=\"Session Timeout\">10 seconds</property>\n        <property name=\"Access Control\">Open</property>\n    </cluster-provider>\n</stateManagement>\n",
      "zookeeper.properties": "#\n#\n# Licensed to the Apache Software Foundation (ASF) under one\n# or more contributor license agreements.  See the NOTICE file\n# distributed with this work for additional information\n# regarding copyright ownership.  The ASF licenses this file\n# to you under the Apache License, Version 2.0 (the\n# \"License\"); you may not use this file except in compliance\n# with the License.  You may obtain a copy of the License at\n#\n#   http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing,\n# software distributed under the License is distributed on an\n# \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n# KIND, either express or implied.  See the License for the\n# specific language governing permissions and limitations\n# under the License.\n#\n#\n#\n\ninitLimit=10\nautopurge.purgeInterval=24\nsyncLimit=5\ntickTime=2000\ndataDir=./state/zookeeper\nautopurge.snapRetainCount=30\n\n#\n# Specifies the servers that are part of this zookeeper ensemble. For\n# every NiFi instance running an embedded zookeeper, there needs to be\n# a server entry below. For instance:\n#\n# server.1=nifi-node1-hostname:2888:3888;2181\n# server.2=nifi-node2-hostname:2888:3888;2181\n# server.3=nifi-node3-hostname:2888:3888;2181\n#\n# The index of the server corresponds to the myid file that gets created\n# in the dataDir of each node running an embedded zookeeper. See the\n# administration guide for more details.\n#\n\nserver.1=\n"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-openldap-customldif",
      "labels": {
        "app": "openldap",
        "chart": "openldap-1.2.7",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "data": {
      "1-default-users.ldif": "# You can find an example ldif file."
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-openldap-env",
      "labels": {
        "app": "openldap",
        "chart": "openldap-1.2.7",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "data": {
      "LDAP_BACKEND": "hdb",
      "LDAP_DOMAIN": "ldap.cetic.be",
      "LDAP_ORGANISATION": "Cetic",
      "LDAP_REMOVE_CONFIG_AFTER_SETUP": "false",
      "LDAP_TLS": "true",
      "LDAP_TLS_ENFORCE": "false",
      "LDAP_TLS_VERIFY_CLIENT": "try"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-phpldapadmin",
      "labels": {
        "app": "phpldapadmin",
        "chart": "phpldapadmin-0.1.4",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "data": {
      "PHPLDAPADMIN_HTTPS": "false",
      "PHPLDAPADMIN_LDAP_HOSTS": "fadi-openldap",
      "PHPLDAPADMIN_TRUST_PROXY_SSL": "true"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-postgresql-configuration",
      "labels": {
        "app": "postgresql",
        "chart": "postgresql-0.2.3",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "data": {
      "pg_hba.conf": "local all all ldap ldapserver=fadi-openldap  ldapport=389 ldaptls=0 ldapbasedn=\"dc=ldap,dc=cetic,dc=be\" ldapbinddn=\"cn=admin,dc=ldap,dc=cetic,dc=be\" ldapbindpasswd=Z2JHHezi4aAA  ldapsearchfilter=cn=$username\nhost all all 0.0.0.0/0  ldap ldapserver=fadi-openldap  ldapport=389 ldaptls=0 ldapbasedn=\"dc=ldap,dc=cetic,dc=be\" ldapbinddn=\"cn=admin,dc=ldap,dc=cetic,dc=be\" ldapbindpasswd=Z2JHHezi4aAA  ldapsearchfilter=cn=$username\n",
      "initdbscripts.sh": "#!/bin/sh\npsql -c \"create role ldap_users;\" postgres admin\npsql -c \"create role ldap_groups;\" postgres admin\npsql -c \"create database zabbix;\" postgres admin\n"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "name": "release-name-postgresql-pgldap-config",
      "labels": {
        "app": "postgresql",
        "chart": "postgresql-0.2.3",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "data": {
      "pgldap-config.yaml": "# Reference: https://github.com/larskanis/pg-ldap-sync/blob/master/config/sample-config.yaml\n# Connection parameters to LDAP server\nldap_connection:\n  host: fadi-openldap\n  port: 389\n  auth:\n    method: :simple\n    username: CN=admin,DC=ldap,DC=cetic,DC=be\n    password: Z2JHHezi4aAA\n  # Search parameters for LDAP users which should be synchronized\nldap_users:\n  base: CN=admin,DC=ldap,DC=cetic,DC=be\n  # LDAP filter (according to RFC 2254)\n  # defines to users in LDAP to be synchronized\n  filter: (!(cn=admin))\n  # this attribute is used as PG role name\n  name_attribute: cn\n  # lowercase name for use as PG role name\n  lowercase_name: true\nldap_groups:\n    base: DC=ldap,DC=cetic,DC=be\n    filter: (|(cn=group1)(cn=group2)(cn=group3))\n    # this attribute is used as PG role name\n    name_attribute: cn\n    # this attribute must reference to all member DN's of the given group\n    member_attribute: member\n# Connection parameters to PostgreSQL server\n# see also: http://rubydoc.info/gems/pg/PG/Connection#initialize-instance_method\npg_connection:\n  host: fadi-postgresql\n  dbname: postgres # the db name is usually \"postgres\"\n  user: admin # the user name is usually \"postgres\"\n  password: Z2JHHezi4aAA # kubectl get secret --namespace fadi <pod_name> -o jsonpath=\"{.data.postgresql-password}\" | base64 --decode\npg_users:\n  # Filter for identifying LDAP generated users in the database.\n  # It's the WHERE-condition to \"SELECT rolname, oid FROM pg_roles\"\n  # filter: rolcanlogin AND NOT rolsuper\n  filter: oid IN (SELECT pam.member FROM pg_auth_members pam JOIN pg_roles pr ON pr.oid=pam.roleid WHERE pr.rolname='ldap_users')\n  # Options for CREATE RULE statements\n  create_options: LOGIN IN ROLE ldap_users\npg_groups:\n  # Filter for identifying LDAP generated groups in the database.\n  # It's the WHERE-condition to \"SELECT rolname, oid FROM pg_roles\"\n  # filter: NOT rolcanlogin AND NOT rolsuper\n  filter: oid IN (SELECT pam.member FROM pg_auth_members pam JOIN pg_roles pr ON pr.oid=pam.roleid WHERE pr.rolname='ldap_groups')\n  # Options for CREATE RULE statements\n  create_options: NOLOGIN IN ROLE ldap_groups\n  #grant_options:\n"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "PersistentVolumeClaim",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "default",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      },
      "finalizers": [
        "kubernetes.io/pvc-protection"
      ]
    },
    "spec": {
      "accessModes": [
        "ReadWriteOnce"
      ],
      "resources": {
        "requests": {
          "storage": "10Gi"
        }
      }
    }
  },
  {
    "kind": "PersistentVolumeClaim",
    "apiVersion": "v1",
    "metadata": {
      "name": "hub-db-dir",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "accessModes": [
        "ReadWriteOnce"
      ],
      "resources": {
        "requests": {
          "storage": "1Gi"
        }
      }
    }
  },
  {
    "kind": "PersistentVolumeClaim",
    "apiVersion": "v1",
    "metadata": {
      "name": "release-name-openldap",
      "labels": {
        "app": "openldap",
        "chart": "openldap-1.2.7",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "accessModes": [
        "ReadWriteOnce"
      ],
      "resources": {
        "requests": {
          "storage": "8Gi"
        }
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "PersistentVolumeClaim",
    "metadata": {
      "name": "release-name-superset",
      "labels": {
        "app": "superset",
        "chart": "superset-1.2.0",
        "release": "release-name"
      }
    },
    "spec": {
      "accessModes": [
        "ReadWriteOnce"
      ],
      "resources": {
        "requests": {
          "storage": "8Gi"
        }
      }
    }
  },
  {
    "kind": "ClusterRole",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      },
      "name": "release-name-grafana-clusterrole"
    },
    "rules": []
  },
  {
    "kind": "ClusterRole",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          "",
          "events.k8s.io"
        ],
        "resources": [
          "events"
        ],
        "verbs": [
          "create",
          "patch",
          "update"
        ]
      },
      {
        "apiGroups": [
          "coordination.k8s.io"
        ],
        "resources": [
          "leases"
        ],
        "verbs": [
          "create"
        ]
      },
      {
        "apiGroups": [
          "coordination.k8s.io"
        ],
        "resourceNames": [
          "user-scheduler-lock"
        ],
        "resources": [
          "leases"
        ],
        "verbs": [
          "get",
          "update"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "endpoints"
        ],
        "verbs": [
          "create"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resourceNames": [
          "user-scheduler-lock"
        ],
        "resources": [
          "endpoints"
        ],
        "verbs": [
          "get",
          "update"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "nodes"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "pods"
        ],
        "verbs": [
          "delete",
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "bindings",
          "pods/binding"
        ],
        "verbs": [
          "create"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "pods/status"
        ],
        "verbs": [
          "patch",
          "update"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "replicationcontrollers",
          "services"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          "apps",
          "extensions"
        ],
        "resources": [
          "replicasets"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          "apps"
        ],
        "resources": [
          "statefulsets"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          "policy"
        ],
        "resources": [
          "poddisruptionbudgets"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "persistentvolumeclaims",
          "persistentvolumes"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          "authentication.k8s.io"
        ],
        "resources": [
          "tokenreviews"
        ],
        "verbs": [
          "create"
        ]
      },
      {
        "apiGroups": [
          "authorization.k8s.io"
        ],
        "resources": [
          "subjectaccessreviews"
        ],
        "verbs": [
          "create"
        ]
      },
      {
        "apiGroups": [
          "storage.k8s.io"
        ],
        "resources": [
          "csinodes"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "persistentvolumes"
        ],
        "verbs": [
          "get",
          "list",
          "patch",
          "update",
          "watch"
        ]
      },
      {
        "apiGroups": [
          "storage.k8s.io"
        ],
        "resources": [
          "storageclasses"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "persistentvolumeclaims"
        ],
        "verbs": [
          "get",
          "list",
          "patch",
          "update",
          "watch"
        ]
      }
    ]
  },
  {
    "kind": "ClusterRole",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-traefik",
      "labels": {
        "app.kubernetes.io/name": "traefik",
        "helm.sh/chart": "traefik-10.6.2",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/instance": "release-name"
      }
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "services",
          "endpoints",
          "secrets"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          "extensions",
          "networking.k8s.io"
        ],
        "resources": [
          "ingresses",
          "ingressclasses"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      },
      {
        "apiGroups": [
          "extensions",
          "networking.k8s.io"
        ],
        "resources": [
          "ingresses/status"
        ],
        "verbs": [
          "update"
        ]
      },
      {
        "apiGroups": [
          "traefik.containo.us"
        ],
        "resources": [
          "ingressroutes",
          "ingressroutetcps",
          "ingressrouteudps",
          "middlewares",
          "middlewaretcps",
          "tlsoptions",
          "tlsstores",
          "traefikservices",
          "serverstransports"
        ],
        "verbs": [
          "get",
          "list",
          "watch"
        ]
      }
    ]
  },
  {
    "kind": "ClusterRoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-grafana-clusterrolebinding",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-grafana",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "ClusterRole",
      "name": "release-name-grafana-clusterrole",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "kind": "ClusterRoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "user-scheduler",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "ClusterRole",
      "name": "release-name-user-scheduler",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "kind": "ClusterRoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-traefik",
      "labels": {
        "app.kubernetes.io/name": "traefik",
        "helm.sh/chart": "traefik-10.6.2",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/instance": "release-name"
      }
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "ClusterRole",
      "name": "release-name-traefik"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-traefik",
        "namespace": "default"
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "Role",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          "extensions"
        ],
        "resources": [
          "podsecuritypolicies"
        ],
        "verbs": [
          "use"
        ],
        "resourceNames": [
          "release-name-grafana"
        ]
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "Role",
    "metadata": {
      "name": "release-name-grafana-test",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          "policy"
        ],
        "resources": [
          "podsecuritypolicies"
        ],
        "verbs": [
          "use"
        ],
        "resourceNames": [
          "release-name-grafana-test"
        ]
      }
    ]
  },
  {
    "kind": "Role",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "pods",
          "persistentvolumeclaims"
        ],
        "verbs": [
          "get",
          "watch",
          "list",
          "create",
          "delete"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "events"
        ],
        "verbs": [
          "get",
          "watch",
          "list"
        ]
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "Role",
      "name": "release-name-grafana"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-grafana",
        "namespace": "default"
      }
    ]
  },
  {
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "kind": "RoleBinding",
    "metadata": {
      "name": "release-name-grafana-test",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "roleRef": {
      "apiGroup": "rbac.authorization.k8s.io",
      "kind": "Role",
      "name": "release-name-grafana-test"
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-grafana-test",
        "namespace": "default"
      }
    ]
  },
  {
    "kind": "RoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "hub",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "Role",
      "name": "hub",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-adminer",
      "labels": {
        "app.kubernetes.io/name": "adminer",
        "helm.sh/chart": "adminer-0.1.7",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "port": 80,
          "targetPort": "http",
          "protocol": "TCP",
          "name": "http"
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "adminer",
        "app.kubernetes.io/instance": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "name": "service",
          "port": 80,
          "protocol": "TCP",
          "targetPort": 3000
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      },
      "annotations": {
        "prometheus.io/scrape": "true",
        "prometheus.io/path": "/hub/metrics"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "selector": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name"
      },
      "ports": [
        {
          "port": 8081,
          "targetPort": "http"
        }
      ]
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "proxy-api",
      "labels": {
        "component": "proxy-api",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "selector": {
        "component": "proxy",
        "app": "jupyterhub",
        "release": "release-name"
      },
      "ports": [
        {
          "port": 8001,
          "targetPort": "api"
        }
      ]
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "proxy-public",
      "labels": {
        "component": "proxy-public",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "selector": {
        "component": "proxy",
        "release": "release-name"
      },
      "ports": [
        {
          "name": "http",
          "port": 80,
          "targetPort": "http"
        }
      ],
      "type": "ClusterIP"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-keycloa-headless",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "keycloak",
        "helm.sh/chart": "keycloak-2.4.8",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "keycloak"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "clusterIP": "None",
      "ports": [
        {
          "name": "http",
          "port": 80,
          "protocol": "TCP",
          "targetPort": "http"
        }
      ],
      "publishNotReadyAddresses": true,
      "selector": {
        "app.kubernetes.io/name": "keycloak",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "keycloak"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-keycloa",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "keycloak",
        "helm.sh/chart": "keycloak-2.4.8",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "keycloak"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "name": "http",
          "port": 80,
          "protocol": "TCP",
          "targetPort": "http",
          "nodePort": null
        },
        {
          "name": "https",
          "port": 443,
          "protocol": "TCP",
          "targetPort": "https",
          "nodePort": null
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "keycloak",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "keycloak"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-zookeeper-headless",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "zookeeper",
        "helm.sh/chart": "zookeeper-5.23.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "zookeeper"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "clusterIP": "None",
      "publishNotReadyAddresses": true,
      "ports": [
        {
          "name": "tcp-client",
          "port": 2181,
          "targetPort": "client"
        },
        {
          "name": "follower",
          "port": 2888,
          "targetPort": "follower"
        },
        {
          "name": "tcp-election",
          "port": 3888,
          "targetPort": "election"
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "zookeeper",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "zookeeper"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-zookeeper",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "zookeeper",
        "helm.sh/chart": "zookeeper-5.23.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "zookeeper"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "name": "tcp-client",
          "port": 2181,
          "targetPort": "client"
        },
        {
          "name": "follower",
          "port": 2888,
          "targetPort": "follower"
        },
        {
          "name": "tcp-election",
          "port": 3888,
          "targetPort": "election"
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "zookeeper",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "zookeeper"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-nifi-headless",
      "labels": {
        "app": "nifi",
        "chart": "nifi-1.0.6",
        "release": "release-name",
        "heritage": "Helm"
      },
      "annotations": {
        "service.alpha.kubernetes.io/tolerate-unready-endpoints": "true"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "clusterIP": "None",
      "ports": [
        {
          "port": 8443,
          "name": "https"
        },
        {
          "port": 6007,
          "name": "cluster"
        }
      ],
      "selector": {
        "app": "nifi",
        "release": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-nifi",
      "labels": {
        "app": "nifi",
        "chart": "nifi-1.0.6",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "port": 8443,
          "name": "https",
          "targetPort": 8443,
          "nodePort": null
        }
      ],
      "selector": {
        "app": "nifi",
        "release": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-openldap",
      "labels": {
        "app": "openldap",
        "chart": "openldap-1.2.7",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "ports": [
        {
          "name": "ldap-port",
          "protocol": "TCP",
          "port": 389,
          "targetPort": "ldap-port"
        },
        {
          "name": "ssl-ldap-port",
          "protocol": "TCP",
          "port": 636,
          "targetPort": "ssl-ldap-port"
        }
      ],
      "selector": {
        "app": "openldap",
        "release": "release-name"
      },
      "type": "ClusterIP"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-phpldapadmin",
      "labels": {
        "app": "phpldapadmin",
        "chart": "phpldapadmin-0.1.4",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "port": 80,
          "targetPort": "http",
          "protocol": "TCP",
          "name": "http"
        }
      ],
      "selector": {
        "app": "phpldapadmin",
        "release": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-postgresql",
      "labels": {
        "app": "postgresql",
        "chart": "postgresql-0.2.3",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "name": "postgresql",
          "port": 5432,
          "targetPort": "postgresql"
        }
      ],
      "selector": {
        "app": "postgresql",
        "release": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-spark-headless",
      "labels": {
        "app.kubernetes.io/name": "spark",
        "helm.sh/chart": "spark-4.1.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "clusterIP": "None",
      "selector": {
        "app.kubernetes.io/name": "spark",
        "app.kubernetes.io/instance": "release-name"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-spark-master-svc",
      "labels": {
        "app.kubernetes.io/name": "spark",
        "helm.sh/chart": "spark-4.1.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "port": 7077,
          "targetPort": "cluster",
          "name": "cluster",
          "nodePort": null
        },
        {
          "port": 80,
          "targetPort": "http",
          "name": "http",
          "protocol": "TCP",
          "nodePort": null
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "spark",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "master"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-superset",
      "labels": {
        "app": "superset",
        "chart": "superset-1.2.0",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "ports": [
        {
          "name": "http",
          "port": 9000,
          "targetPort": 8088,
          "protocol": "TCP"
        }
      ],
      "selector": {
        "app": "superset",
        "release": "release-name",
        "component": "server"
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "DaemonSet",
    "metadata": {
      "name": "continuous-image-puller",
      "labels": {
        "component": "continuous-image-puller",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "selector": {
        "matchLabels": {
          "component": "continuous-image-puller",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "updateStrategy": {
        "type": "RollingUpdate",
        "rollingUpdate": {
          "maxUnavailable": "100%"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "continuous-image-puller",
            "app": "jupyterhub",
            "release": "release-name"
          }
        },
        "spec": {
          "tolerations": [
            {
              "key": "hub.jupyter.org_dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            },
            {
              "key": "hub.jupyter.org/dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            }
          ],
          "nodeSelector": {},
          "terminationGracePeriodSeconds": 0,
          "automountServiceAccountToken": false,
          "initContainers": [
            {
              "name": "image-pull-metadata-block",
              "image": "jupyterhub/k8s-network-tools:0.11.1",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ],
              "resources": {
                "requests": {
                  "cpu": 0,
                  "memory": 0
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 65534
              }
            },
            {
              "name": "image-pull-singleuser",
              "image": "jupyterhub/k8s-singleuser-sample:0.11.1",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ],
              "resources": {
                "requests": {
                  "cpu": 0,
                  "memory": 0
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 65534
              }
            },
            {
              "name": "image-pull-singleuser-profilelist-1",
              "image": "jupyter/datascience-notebook:7d427e7a4dde",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ],
              "resources": {
                "requests": {
                  "cpu": 0,
                  "memory": 0
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 65534
              }
            },
            {
              "name": "image-pull-singleuser-profilelist-2",
              "image": "jupyter/all-spark-notebook:latest",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ],
              "resources": {
                "requests": {
                  "cpu": 0,
                  "memory": 0
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 65534
              }
            },
            {
              "name": "image-pull-singleuser-profilelist-3",
              "image": "jupyter/tensorflow-notebook:latest",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ],
              "resources": {
                "requests": {
                  "cpu": 0,
                  "memory": 0
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 65534
              }
            }
          ],
          "containers": [
            {
              "name": "pause",
              "image": "k8s.gcr.io/pause:3.2",
              "resources": {
                "requests": {
                  "cpu": 0,
                  "memory": 0
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 11947,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-adminer",
      "labels": {
        "app.kubernetes.io/name": "adminer",
        "helm.sh/chart": "adminer-0.1.7",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "adminer",
          "app.kubernetes.io/instance": "release-name"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "adminer",
            "app.kubernetes.io/instance": "release-name"
          }
        },
        "spec": {
          "containers": [
            {
              "name": "adminer",
              "image": "adminer:4.8.1-standalone",
              "imagePullPolicy": "IfNotPresent",
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8080,
                  "protocol": "TCP"
                }
              ],
              "env": [
                {
                  "name": "ADMINER_PLUGINS",
                  "value": null
                },
                {
                  "name": "ADMINER_DESIGN",
                  "value": "pepa-linha"
                },
                {
                  "name": "ADMINER_DEFAULT_SERVER",
                  "value": null
                }
              ]
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-grafana",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "revisionHistoryLimit": 10,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "grafana",
          "app.kubernetes.io/instance": "release-name"
        }
      },
      "strategy": {
        "type": "RollingUpdate"
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "grafana",
            "app.kubernetes.io/instance": "release-name"
          },
          "annotations": {
            "checksum/config": "c61da6aeceeeb6d9d29dc78fac40e307dd6f92bedc4cbc553ee0473c68dc2962",
            "checksum/dashboards-json-config": "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b",
            "checksum/sc-dashboard-provider-config": "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b",
            "checksum/secret": "2338041c70879b4cc6854f24c0a55aaee9da09000be3020f5b04e5f09ce33b6a"
          }
        },
        "spec": {
          "serviceAccountName": "release-name-grafana",
          "securityContext": {
            "fsGroup": 472,
            "runAsGroup": 472,
            "runAsUser": 472
          },
          "initContainers": [
            {
              "name": "init-chown-data",
              "image": "busybox:1.31.1",
              "imagePullPolicy": "IfNotPresent",
              "securityContext": {
                "runAsNonRoot": false,
                "runAsUser": 0
              },
              "command": [
                "chown",
                "-R",
                "472:472",
                "/var/lib/grafana"
              ],
              "resources": {},
              "volumeMounts": [
                {
                  "name": "storage",
                  "mountPath": "/var/lib/grafana"
                }
              ]
            }
          ],
          "containers": [
            {
              "name": "grafana",
              "image": "grafana/grafana:7.3.5",
              "imagePullPolicy": "IfNotPresent",
              "volumeMounts": [
                {
                  "name": "config",
                  "mountPath": "/etc/grafana/grafana.ini",
                  "subPath": "grafana.ini"
                },
                {
                  "name": "ldap",
                  "mountPath": "/etc/grafana/ldap.toml",
                  "subPath": "ldap.toml"
                },
                {
                  "name": "storage",
                  "mountPath": "/var/lib/grafana"
                }
              ],
              "ports": [
                {
                  "name": "service",
                  "containerPort": 80,
                  "protocol": "TCP"
                },
                {
                  "name": "grafana",
                  "containerPort": 3000,
                  "protocol": "TCP"
                }
              ],
              "env": [
                {
                  "name": "GF_SECURITY_ADMIN_USER",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-grafana",
                      "key": "admin-user"
                    }
                  }
                },
                {
                  "name": "GF_SECURITY_ADMIN_PASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-grafana",
                      "key": "admin-password"
                    }
                  }
                }
              ],
              "livenessProbe": {
                "failureThreshold": 10,
                "httpGet": {
                  "path": "/api/health",
                  "port": 3000
                },
                "initialDelaySeconds": 60,
                "timeoutSeconds": 30
              },
              "readinessProbe": {
                "httpGet": {
                  "path": "/api/health",
                  "port": 3000
                }
              },
              "resources": {
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ],
          "volumes": [
            {
              "name": "config",
              "configMap": {
                "name": "release-name-grafana"
              }
            },
            {
              "name": "ldap",
              "secret": {
                "secretName": "release-name-grafana",
                "items": [
                  {
                    "key": "ldap-toml",
                    "path": "ldap.toml"
                  }
                ]
              }
            },
            {
              "name": "storage",
              "persistentVolumeClaim": {
                "claimName": "release-name-grafana"
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "hub",
      "labels": {
        "component": "hub",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "component": "hub",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "strategy": {
        "type": "Recreate"
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "hub",
            "app": "jupyterhub",
            "release": "release-name",
            "hub.jupyter.org/network-access-proxy-api": "true",
            "hub.jupyter.org/network-access-proxy-http": "true",
            "hub.jupyter.org/network-access-singleuser": "true"
          },
          "annotations": {
            "checksum/config-map": "32903125a6a25009eff55141a5338cdf309336b533eef75341d3f216a64649ac",
            "checksum/secret": "40822d3e739b1107d6a4ba68daa05492d485156f7e05cb077832ef3e0f381018"
          }
        },
        "spec": {
          "nodeSelector": {},
          "tolerations": [],
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "core"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "volumes": [
            {
              "name": "config",
              "configMap": {
                "name": "hub-config"
              }
            },
            {
              "name": "secret",
              "secret": {
                "secretName": "hub-secret"
              }
            },
            {
              "name": "hub-db-dir",
              "persistentVolumeClaim": {
                "claimName": "hub-db-dir"
              }
            }
          ],
          "serviceAccountName": "hub",
          "securityContext": {
            "fsGroup": 1000
          },
          "containers": [
            {
              "name": "hub",
              "image": "jupyterhub/k8s-hub:0.11.1",
              "args": [
                "jupyterhub",
                "--config",
                "/etc/jupyterhub/jupyterhub_config.py",
                "--upgrade-db"
              ],
              "volumeMounts": [
                {
                  "mountPath": "/etc/jupyterhub/jupyterhub_config.py",
                  "subPath": "jupyterhub_config.py",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/z2jh.py",
                  "subPath": "z2jh.py",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/config/",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/secret/",
                  "name": "secret"
                },
                {
                  "mountPath": "/srv/jupyterhub",
                  "name": "hub-db-dir"
                }
              ],
              "resources": {
                "requests": {
                  "cpu": "200m",
                  "memory": "512Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 1000,
                "runAsUser": 10173,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "env": [
                {
                  "name": "PYTHONUNBUFFERED",
                  "value": "1"
                },
                {
                  "name": "HELM_RELEASE_NAME",
                  "value": "release-name"
                },
                {
                  "name": "POD_NAMESPACE",
                  "valueFrom": {
                    "fieldRef": {
                      "fieldPath": "metadata.namespace"
                    }
                  }
                },
                {
                  "name": "CONFIGPROXY_AUTH_TOKEN",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "hub-secret",
                      "key": "proxy.token"
                    }
                  }
                }
              ],
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8081
                }
              ],
              "livenessProbe": {
                "initialDelaySeconds": 300,
                "periodSeconds": 10,
                "timeoutSeconds": 3,
                "failureThreshold": 30,
                "httpGet": {
                  "path": "/hub/health",
                  "port": "http"
                }
              },
              "readinessProbe": {
                "initialDelaySeconds": 0,
                "periodSeconds": 2,
                "timeoutSeconds": 1,
                "failureThreshold": 1000,
                "httpGet": {
                  "path": "/hub/health",
                  "port": "http"
                }
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "proxy",
      "labels": {
        "component": "proxy",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "component": "proxy",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "strategy": {
        "type": "Recreate"
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "proxy",
            "app": "jupyterhub",
            "release": "release-name",
            "hub.jupyter.org/network-access-hub": "true",
            "hub.jupyter.org/network-access-singleuser": "true"
          },
          "annotations": {
            "checksum/hub-secret": "66b14772f027b62d9b9a7f46c3de05aa5f35069017962240fd48d6ba783ac4cd",
            "checksum/proxy-secret": "01ba4719c80b6fe911b091a7c05124b64eeece964e09c058ef8f9805daca546b"
          }
        },
        "spec": {
          "terminationGracePeriodSeconds": 60,
          "nodeSelector": {},
          "tolerations": [],
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "core"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "containers": [
            {
              "name": "chp",
              "image": "jupyterhub/configurable-http-proxy:4.2.2",
              "command": [
                "configurable-http-proxy",
                "--ip=::",
                "--api-ip=::",
                "--api-port=8001",
                "--default-target=http://hub:$(HUB_SERVICE_PORT)",
                "--error-target=http://hub:$(HUB_SERVICE_PORT)/hub/error",
                "--port=8000"
              ],
              "resources": {
                "requests": {
                  "cpu": "200m",
                  "memory": "512Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "env": [
                {
                  "name": "CONFIGPROXY_AUTH_TOKEN",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "hub-secret",
                      "key": "proxy.token"
                    }
                  }
                }
              ],
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8000
                },
                {
                  "name": "api",
                  "containerPort": 8001
                }
              ],
              "livenessProbe": {
                "initialDelaySeconds": 60,
                "periodSeconds": 10,
                "httpGet": {
                  "path": "/_chp_healthz",
                  "port": "http",
                  "scheme": "HTTP"
                }
              },
              "readinessProbe": {
                "initialDelaySeconds": 0,
                "periodSeconds": 2,
                "httpGet": {
                  "path": "/_chp_healthz",
                  "port": "http",
                  "scheme": "HTTP"
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 10998,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "user-scheduler",
      "labels": {
        "component": "user-scheduler",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 2,
      "selector": {
        "matchLabels": {
          "component": "user-scheduler",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "component": "user-scheduler",
            "app": "jupyterhub",
            "release": "release-name"
          },
          "annotations": {
            "checksum/config-map": "6b7bc9096735cf55ae85b862354e8525fc89e93ea8dbaf477be342445ab6822c"
          }
        },
        "spec": {
          "serviceAccountName": "user-scheduler",
          "nodeSelector": {},
          "tolerations": [],
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "core"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "volumes": [
            {
              "name": "config",
              "configMap": {
                "name": "user-scheduler"
              }
            }
          ],
          "containers": [
            {
              "name": "user-scheduler",
              "image": "k8s.gcr.io/kube-scheduler:v1.16.15",
              "command": [
                "/usr/local/bin/kube-scheduler",
                "--scheduler-name=release-name-user-scheduler",
                "--policy-config-file=/etc/user-scheduler/policy.cfg",
                "--lock-object-name=user-scheduler-lock",
                "--lock-object-namespace=default",
                "--v=4"
              ],
              "volumeMounts": [
                {
                  "mountPath": "/etc/user-scheduler",
                  "name": "config"
                }
              ],
              "livenessProbe": {
                "httpGet": {
                  "path": "/healthz",
                  "port": 10251
                },
                "initialDelaySeconds": 15
              },
              "readinessProbe": {
                "httpGet": {
                  "path": "/healthz",
                  "port": 10251
                }
              },
              "resources": {
                "requests": {
                  "cpu": "50m",
                  "memory": "256Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 11121,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-openldap",
      "labels": {
        "app": "openldap",
        "chart": "openldap-1.2.7",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app": "openldap",
          "release": "release-name"
        }
      },
      "template": {
        "metadata": {
          "annotations": {
            "checksum/configmap-env": "6f803c2ceed1863b5b717474bb75f682dfb82af7c4e5585c1bb9d0ba8634c3b6",
            "checksum/configmap-customldif": "8bae41d62be4368d2ed9c0cb7b9d3284495a0f27f7be619988ed196a6136325a"
          },
          "labels": {
            "app": "openldap",
            "release": "release-name"
          }
        },
        "spec": {
          "initContainers": [
            {
              "name": "openldap-init-ldif",
              "image": "busybox",
              "command": [
                "sh",
                "-c",
                "cp /customldif/* /ldifworkingdir"
              ],
              "imagePullPolicy": "IfNotPresent",
              "volumeMounts": [
                {
                  "name": "customldif",
                  "mountPath": "/customldif"
                },
                {
                  "name": "ldifworkingdir",
                  "mountPath": "/ldifworkingdir"
                }
              ],
              "resources": {}
            }
          ],
          "containers": [
            {
              "name": "openldap",
              "image": "osixia/openldap:1.2.4",
              "imagePullPolicy": "IfNotPresent",
              "args": [
                "-l",
                "info",
                "--copy-service"
              ],
              "ports": [
                {
                  "name": "ldap-port",
                  "containerPort": 389
                },
                {
                  "name": "ssl-ldap-port",
                  "containerPort": 636
                }
              ],
              "envFrom": [
                {
                  "configMapRef": {
                    "name": "release-name-openldap-env"
                  }
                },
                {
                  "secretRef": {
                    "name": "release-name-openldap"
                  }
                }
              ],
              "volumeMounts": [
                {
                  "name": "data",
                  "mountPath": "/var/lib/ldap",
                  "subPath": "data"
                },
                {
                  "name": "data",
                  "mountPath": "/etc/ldap/slapd.d",
                  "subPath": "config-data"
                },
                {
                  "name": "ldifworkingdir",
                  "mountPath": "/container/service/slapd/assets/config/bootstrap/ldif/custom"
                }
              ],
              "env": null,
              "livenessProbe": {
                "tcpSocket": {
                  "port": "ldap-port"
                },
                "initialDelaySeconds": 20,
                "periodSeconds": 10,
                "failureThreshold": 10
              },
              "readinessProbe": {
                "tcpSocket": {
                  "port": "ldap-port"
                },
                "initialDelaySeconds": 20,
                "periodSeconds": 10,
                "failureThreshold": 10
              },
              "resources": {
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ],
          "volumes": [
            {
              "name": "customldif",
              "configMap": {
                "name": "release-name-openldap-customldif"
              }
            },
            {
              "name": "ldifworkingdir",
              "emptyDir": {}
            },
            {
              "name": "certs",
              "emptyDir": {
                "medium": "Memory"
              }
            },
            {
              "name": "data",
              "persistentVolumeClaim": {
                "claimName": "release-name-openldap"
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-phpldapadmin",
      "labels": {
        "app": "phpldapadmin",
        "chart": "phpldapadmin-0.1.4",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app": "phpldapadmin",
          "release": "release-name"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app": "phpldapadmin",
            "release": "release-name"
          }
        },
        "spec": {
          "containers": [
            {
              "name": "phpldapadmin",
              "image": "osixia/phpldapadmin:0.7.1",
              "imagePullPolicy": "IfNotPresent",
              "ports": [
                {
                  "name": "http",
                  "containerPort": 80,
                  "protocol": "TCP"
                }
              ],
              "envFrom": [
                {
                  "configMapRef": {
                    "name": "release-name-phpldapadmin"
                  }
                }
              ],
              "livenessProbe": {
                "httpGet": {
                  "path": "/",
                  "port": "http"
                }
              },
              "readinessProbe": {
                "httpGet": {
                  "path": "/",
                  "port": "http"
                }
              },
              "resources": {
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-superset",
      "labels": {
        "app": "superset",
        "chart": "superset-1.2.0",
        "component": "server",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app": "superset",
          "component": "server",
          "release": "release-name"
        }
      },
      "template": {
        "metadata": {
          "name": "release-name-superset",
          "labels": {
            "app": "superset",
            "component": "server",
            "chart": "superset-1.2.0",
            "release": "release-name",
            "heritage": "Helm"
          },
          "annotations": {
            "checksum/secrets": "6bd697a4417687fa83c535d05c202b53463cc5b93b3016a2e1e0d2f60672c66b"
          }
        },
        "spec": {
          "securityContext": {
            "runAsUser": 1000,
            "fsGroup": 1000
          },
          "volumes": [
            {
              "name": "superset-configs",
              "secret": {
                "secretName": "release-name-superset"
              }
            },
            {
              "name": "storage-volume",
              "persistentVolumeClaim": {
                "claimName": "release-name-superset"
              }
            }
          ],
          "containers": [
            {
              "name": "superset",
              "image": "amancevice/superset:0.35.2",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/usr/bin/env"
              ],
              "args": [
                "gunicorn",
                "-b",
                "0.0.0.0:8088",
                "--limit-request-line",
                "0",
                "--limit-request-field_size",
                "0",
                "superset:app"
              ],
              "volumeMounts": [
                {
                  "name": "superset-configs",
                  "mountPath": "/home/superset"
                },
                {
                  "name": "storage-volume",
                  "mountPath": "/var/lib/superset"
                }
              ],
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8088,
                  "protocol": "TCP"
                }
              ],
              "livenessProbe": {
                "failureThreshold": 2,
                "httpGet": {
                  "path": "/health",
                  "port": "http"
                },
                "initialDelaySeconds": 80,
                "periodSeconds": 10,
                "timeoutSeconds": 5
              },
              "readinessProbe": {
                "failureThreshold": 2,
                "httpGet": {
                  "path": "/health",
                  "port": "http"
                },
                "initialDelaySeconds": 60,
                "periodSeconds": 10,
                "timeoutSeconds": 5
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-traefik",
      "labels": {
        "app.kubernetes.io/name": "traefik",
        "helm.sh/chart": "traefik-10.6.2",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/instance": "release-name"
      },
      "annotations": null
    },
    "spec": {
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "traefik",
          "app.kubernetes.io/instance": "release-name"
        }
      },
      "strategy": {
        "type": "RollingUpdate",
        "rollingUpdate": {
          "maxSurge": 1,
          "maxUnavailable": 1
        }
      },
      "template": {
        "metadata": {
          "annotations": {
            "prometheus.io/scrape": "true",
            "prometheus.io/path": "/metrics",
            "prometheus.io/port": "9100"
          },
          "labels": {
            "app.kubernetes.io/name": "traefik",
            "helm.sh/chart": "traefik-10.6.2",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/instance": "release-name"
          }
        },
        "spec": {
          "serviceAccountName": "release-name-traefik",
          "terminationGracePeriodSeconds": 60,
          "hostNetwork": false,
          "containers": [
            {
              "image": "traefik:2.5.4",
              "imagePullPolicy": "IfNotPresent",
              "name": "release-name-traefik",
              "resources": null,
              "readinessProbe": {
                "httpGet": {
                  "path": "/ping",
                  "port": 9000
                },
                "failureThreshold": 1,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 2
              },
              "livenessProbe": {
                "httpGet": {
                  "path": "/ping",
                  "port": 9000
                },
                "failureThreshold": 3,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 2
              },
              "ports": [
                {
                  "name": "metrics",
                  "containerPort": 9100,
                  "protocol": "TCP"
                },
                {
                  "name": "traefik",
                  "containerPort": 9000,
                  "protocol": "TCP"
                },
                {
                  "name": "web",
                  "containerPort": 8000,
                  "protocol": "TCP"
                },
                {
                  "name": "websecure",
                  "containerPort": 8443,
                  "protocol": "TCP"
                }
              ],
              "securityContext": {
                "capabilities": {
                  "drop": [
                    "ALL"
                  ]
                },
                "readOnlyRootFilesystem": true,
                "runAsGroup": 65532,
                "runAsNonRoot": true,
                "runAsUser": 65532,
                "allowPrivilegeEscalation": false
              },
              "volumeMounts": [
                {
                  "name": "data",
                  "mountPath": "/data"
                },
                {
                  "name": "tmp",
                  "mountPath": "/tmp"
                }
              ],
              "args": [
                "--global.checknewversion",
                "--global.sendanonymoususage",
                "--entryPoints.metrics.address=:9100/tcp",
                "--entryPoints.traefik.address=:9000/tcp",
                "--entryPoints.web.address=:8000/tcp",
                "--entryPoints.websecure.address=:8443/tcp",
                "--api.dashboard=true",
                "--ping=true",
                "--metrics.prometheus=true",
                "--metrics.prometheus.entrypoint=metrics",
                "--providers.kubernetescrd",
                "--providers.kubernetesingress",
                "--providers.kubernetesIngress.ingressClass=traefik-cert-manager"
              ]
            }
          ],
          "volumes": [
            {
              "name": "data",
              "emptyDir": {}
            },
            {
              "name": "tmp",
              "emptyDir": {}
            }
          ],
          "securityContext": {
            "fsGroup": 65532
          }
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "user-placeholder",
      "labels": {
        "component": "user-placeholder",
        "app": "jupyterhub",
        "release": "release-name",
        "chart": "jupyterhub-0.11.1",
        "heritage": "Helm"
      }
    },
    "spec": {
      "podManagementPolicy": "Parallel",
      "replicas": 0,
      "selector": {
        "matchLabels": {
          "component": "user-placeholder",
          "app": "jupyterhub",
          "release": "release-name"
        }
      },
      "serviceName": "user-placeholder",
      "template": {
        "metadata": {
          "labels": {
            "component": "user-placeholder",
            "app": "jupyterhub",
            "release": "release-name"
          }
        },
        "spec": {
          "schedulerName": "release-name-user-scheduler",
          "tolerations": [
            {
              "key": "hub.jupyter.org_dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            },
            {
              "key": "hub.jupyter.org/dedicated",
              "operator": "Equal",
              "value": "user",
              "effect": "NoSchedule"
            }
          ],
          "nodeSelector": {},
          "affinity": {
            "nodeAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 100,
                  "preference": {
                    "matchExpressions": [
                      {
                        "key": "hub.jupyter.org/node-purpose",
                        "operator": "In",
                        "values": [
                          "user"
                        ]
                      }
                    ]
                  }
                }
              ]
            }
          },
          "terminationGracePeriodSeconds": 0,
          "automountServiceAccountToken": false,
          "containers": [
            {
              "name": "pause",
              "image": "k8s.gcr.io/pause:3.2",
              "resources": {
                "requests": {
                  "memory": "1G"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "securityContext": {
                "allowPrivilegeEscalation": false,
                "runAsGroup": 65534,
                "runAsUser": 10540,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "release-name-keycloa",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "keycloak",
        "helm.sh/chart": "keycloak-2.4.8",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "keycloak"
      }
    },
    "spec": {
      "replicas": 1,
      "podManagementPolicy": "Parallel",
      "serviceName": "release-name-keycloa-headless",
      "updateStrategy": {
        "type": "RollingUpdate"
      },
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "keycloak",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "keycloak"
        }
      },
      "template": {
        "metadata": {
          "annotations": {
            "checksum/configmap-env-vars": "d1a702305eff3750d1bc1f386b741ec99c79d9a6c920c7731cc1b4b62d2dc03b",
            "checksum/secrets": "02938f364062431dcd4c536267f503c83e22c94ea0ad65a79130b1bdf89c8be1"
          },
          "labels": {
            "app.kubernetes.io/name": "keycloak",
            "helm.sh/chart": "keycloak-2.4.8",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "keycloak"
          }
        },
        "spec": {
          "serviceAccountName": "release-name-keycloa",
          "affinity": {
            "podAffinity": null,
            "podAntiAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "podAffinityTerm": {
                    "labelSelector": {
                      "matchLabels": {
                        "app.kubernetes.io/name": "keycloak",
                        "app.kubernetes.io/instance": "release-name"
                      }
                    },
                    "namespaces": [
                      "default"
                    ],
                    "topologyKey": "kubernetes.io/hostname"
                  },
                  "weight": 1
                }
              ]
            },
            "nodeAffinity": null
          },
          "securityContext": {
            "fsGroup": 1001
          },
          "containers": [
            {
              "name": "keycloak",
              "image": "docker.io/bitnami/keycloak:12.0.4-debian-10-r52",
              "imagePullPolicy": "IfNotPresent",
              "securityContext": {
                "runAsNonRoot": true,
                "runAsUser": 11583,
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "env": [
                {
                  "name": "KUBERNETES_NAMESPACE",
                  "valueFrom": {
                    "fieldRef": {
                      "apiVersion": "v1",
                      "fieldPath": "metadata.namespace"
                    }
                  }
                },
                {
                  "name": "BITNAMI_DEBUG",
                  "value": "false"
                },
                {
                  "name": "KEYCLOAK_ADMIN_PASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-keycloak",
                      "key": "admin-password"
                    }
                  }
                },
                {
                  "name": "KEYCLOAK_MANAGEMENT_PASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-keycloak",
                      "key": "management-password"
                    }
                  }
                },
                {
                  "name": "KEYCLOAK_DATABASE_PASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-keycloak",
                      "key": "database-password"
                    }
                  }
                }
              ],
              "envFrom": [
                {
                  "configMapRef": {
                    "name": "release-name-keycloa-env-vars"
                  }
                }
              ],
              "resources": {
                "limits": {},
                "requests": {},
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8080,
                  "protocol": "TCP"
                },
                {
                  "name": "https",
                  "containerPort": 8443,
                  "protocol": "TCP"
                },
                {
                  "name": "http-management",
                  "containerPort": 9990,
                  "protocol": "TCP"
                }
              ],
              "livenessProbe": {
                "failureThreshold": 3,
                "httpGet": {
                  "path": "/auth/",
                  "port": "http"
                },
                "initialDelaySeconds": 300,
                "periodSeconds": 1,
                "successThreshold": 1,
                "timeoutSeconds": 5
              },
              "readinessProbe": {
                "failureThreshold": 3,
                "httpGet": {
                  "path": "/auth/realms/master",
                  "port": "http"
                },
                "initialDelaySeconds": 30,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 1
              },
              "volumeMounts": null
            }
          ],
          "volumes": null
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "release-name-zookeeper",
      "namespace": "qE6qSW8pmXLGc",
      "labels": {
        "app.kubernetes.io/name": "zookeeper",
        "helm.sh/chart": "zookeeper-5.23.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "zookeeper",
        "role": "zookeeper"
      }
    },
    "spec": {
      "serviceName": "release-name-zookeeper-headless",
      "replicas": 3,
      "podManagementPolicy": "Parallel",
      "updateStrategy": {
        "type": "RollingUpdate"
      },
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "zookeeper",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "zookeeper"
        }
      },
      "template": {
        "metadata": {
          "name": "release-name-zookeeper",
          "labels": {
            "app.kubernetes.io/name": "zookeeper",
            "helm.sh/chart": "zookeeper-5.23.0",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "zookeeper"
          }
        },
        "spec": {
          "serviceAccountName": "default",
          "securityContext": {
            "fsGroup": 1001
          },
          "containers": [
            {
              "name": "zookeeper",
              "image": "docker.io/bitnami/zookeeper:3.6.2-debian-10-r37",
              "imagePullPolicy": "IfNotPresent",
              "securityContext": {
                "runAsUser": 10770,
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "command": [
                "bash",
                "-ec",
                "# Execute entrypoint as usual after obtaining ZOO_SERVER_ID based on POD hostname\nHOSTNAME=`hostname -s`\nif [[ $HOSTNAME =~ (.*)-([0-9]+)$ ]]; then\n  ORD=${BASH_REMATCH[2]}\n  export ZOO_SERVER_ID=$((ORD+1))\nelse\n  echo \"Failed to get index from hostname $HOST\"\n  exit 1\nfi\nexec /entrypoint.sh /run.sh\n"
              ],
              "resources": {
                "requests": {
                  "cpu": "250m",
                  "memory": "256Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "env": [
                {
                  "name": "ZOO_DATA_LOG_DIR",
                  "value": ""
                },
                {
                  "name": "ZOO_PORT_NUMBER",
                  "value": "2181"
                },
                {
                  "name": "ZOO_TICK_TIME",
                  "value": "2000"
                },
                {
                  "name": "ZOO_INIT_LIMIT",
                  "value": "10"
                },
                {
                  "name": "ZOO_SYNC_LIMIT",
                  "value": "5"
                },
                {
                  "name": "ZOO_MAX_CLIENT_CNXNS",
                  "value": "60"
                },
                {
                  "name": "ZOO_4LW_COMMANDS_WHITELIST",
                  "value": "srvr, mntr, ruok"
                },
                {
                  "name": "ZOO_LISTEN_ALLIPS_ENABLED",
                  "value": "no"
                },
                {
                  "name": "ZOO_AUTOPURGE_INTERVAL",
                  "value": "0"
                },
                {
                  "name": "ZOO_AUTOPURGE_RETAIN_COUNT",
                  "value": "3"
                },
                {
                  "name": "ZOO_MAX_SESSION_TIMEOUT",
                  "value": "40000"
                },
                {
                  "name": "ZOO_SERVERS",
                  "value": "release-name-zookeeper-0.release-name-zookeeper-headless.default.svc.cluster.local:2888:3888 release-name-zookeeper-1.release-name-zookeeper-headless.default.svc.cluster.local:2888:3888 release-name-zookeeper-2.release-name-zookeeper-headless.default.svc.cluster.local:2888:3888"
                },
                {
                  "name": "ZOO_ENABLE_AUTH",
                  "value": "no"
                },
                {
                  "name": "ZOO_HEAP_SIZE",
                  "value": "1024"
                },
                {
                  "name": "ZOO_LOG_LEVEL",
                  "value": "ERROR"
                },
                {
                  "name": "ALLOW_ANONYMOUS_LOGIN",
                  "value": "yes"
                },
                {
                  "name": "POD_NAME",
                  "valueFrom": {
                    "fieldRef": {
                      "apiVersion": "v1",
                      "fieldPath": "metadata.name"
                    }
                  }
                }
              ],
              "ports": [
                {
                  "name": "client",
                  "containerPort": 2181
                },
                {
                  "name": "follower",
                  "containerPort": 2888
                },
                {
                  "name": "election",
                  "containerPort": 3888
                }
              ],
              "livenessProbe": {
                "exec": {
                  "command": [
                    "/bin/bash",
                    "-c",
                    "echo \"ruok\" | timeout 2 nc -w 2 localhost 2181 | grep imok"
                  ]
                },
                "initialDelaySeconds": 30,
                "periodSeconds": 10,
                "timeoutSeconds": 5,
                "successThreshold": 1,
                "failureThreshold": 6
              },
              "readinessProbe": {
                "exec": {
                  "command": [
                    "/bin/bash",
                    "-c",
                    "echo \"ruok\" | timeout 2 nc -w 2 localhost 2181 | grep imok"
                  ]
                },
                "initialDelaySeconds": 5,
                "periodSeconds": 10,
                "timeoutSeconds": 5,
                "successThreshold": 1,
                "failureThreshold": 6
              },
              "volumeMounts": [
                {
                  "name": "data",
                  "mountPath": "/bitnami/zookeeper"
                }
              ]
            }
          ],
          "volumes": null
        }
      },
      "volumeClaimTemplates": [
        {
          "metadata": {
            "name": "data",
            "annotations": null
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "resources": {
              "requests": {
                "storage": "8Gi"
              }
            }
          }
        }
      ]
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "release-name-nifi",
      "labels": {
        "app": "nifi",
        "chart": "nifi-1.0.6",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "podManagementPolicy": "Parallel",
      "serviceName": "release-name-nifi-headless",
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app": "nifi",
          "release": "release-name"
        }
      },
      "template": {
        "metadata": {
          "annotations": {
            "security.alpha.kubernetes.io/sysctls": "net.ipv4.ip_local_port_range=10000 65000"
          },
          "labels": {
            "app": "nifi",
            "chart": "nifi-1.0.6",
            "release": "release-name",
            "heritage": "Helm"
          }
        },
        "spec": {
          "serviceAccountName": "default",
          "affinity": {
            "podAntiAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "weight": 1,
                  "podAffinityTerm": {
                    "labelSelector": {
                      "matchExpressions": [
                        {
                          "key": "app",
                          "operator": "In",
                          "values": [
                            "nifi"
                          ]
                        }
                      ]
                    },
                    "topologyKey": "kubernetes.io/hostname"
                  }
                }
              ]
            }
          },
          "terminationGracePeriodSeconds": 30,
          "securityContext": {
            "fsGroup": 1000,
            "runAsUser": 1000
          },
          "initContainers": null,
          "containers": [
            {
              "name": "server",
              "imagePullPolicy": "IfNotPresent",
              "image": "apache/nifi:1.14.0",
              "command": [
                "bash",
                "-ce",
                "prop_replace () {\n  target_file=${NIFI_HOME}/conf/${3:-nifi.properties}\n  echo \"updating ${1} in ${target_file}\"\n  if egrep \"^${1}=\" ${target_file} &> /dev/null; then\n    sed -i -e \"s|^$1=.*$|$1=$2|\"  ${target_file}\n  else\n    echo ${1}=${2} >> ${target_file}\n  fi\n}\nmkdir -p ${NIFI_HOME}/config-data/conf\nFQDN=$(hostname -f)\n\ncat \"${NIFI_HOME}/conf/nifi.temp\" > \"${NIFI_HOME}/conf/nifi.properties\"\ncat \"${NIFI_HOME}/conf/authorizers.temp\" > \"${NIFI_HOME}/conf/authorizers.xml\"\ncat \"${NIFI_HOME}/conf/login-identity-providers-ldap.xml\" > \"${NIFI_HOME}/conf/login-identity-providers.xml\"\n\nif ! test -f /opt/nifi/data/flow.xml.gz && test -f /opt/nifi/data/flow.xml; then\n  gzip /opt/nifi/data/flow.xml\nfi\n\nprop_replace nifi.remote.input.host ${FQDN}\nprop_replace nifi.cluster.node.address ${FQDN}\nprop_replace nifi.zookeeper.connect.string ${NIFI_ZOOKEEPER_CONNECT_STRING}\nprop_replace nifi.web.http.host ${FQDN}\n# Update nifi.properties for web ui proxy hostname\nprop_replace nifi.web.proxy.host nifi.example.cetic.be\n\nif [ ! -r \"${NIFI_HOME}/conf/nifi-cert.pem\" ]\nthen\n  /opt/nifi/nifi-toolkit-current/bin/tls-toolkit.sh standalone \\\n    -n 'release-name-nifi-0.release-name-nifi-headless.default.svc.cluster.local' \\\n    -C 'CN=admin, OU=NIFI' \\\n    -o \"${NIFI_HOME}/conf/\" \\\n    -P changeMe \\\n    -S changeMe \\\n    --nifiPropertiesFile /opt/nifi/nifi-current/conf/nifi.properties\nfi\nprop_replace nifi.web.http.network.interface.default \"eth0\" nifi.properties\nprop_replace nifi.web.http.network.interface.lo \"lo\" nifi.properties\n\nfor f in \"${NIFI_HOME}/conf/authorizers.xml\" \"${NIFI_HOME}/conf/login-identity-providers.xml\" ${NIFI_HOME}/conf/nifi.properties\ndo\n  echo === $f ===\n  cat $f\ndone\necho === end of files ===\n\nfunction prop () {\n  target_file=${NIFI_HOME}/conf/nifi.properties\n  egrep \"^${1}=\" ${target_file} | cut -d'=' -f2\n}\n\nfunction offloadNode() {\n    FQDN=$(hostname -f)\n    echo \"disconnecting node '$FQDN'\"\n    baseUrl=https://${FQDN}:8443\n\n    echo \"keystoreType=$(prop nifi.security.keystoreType)\" > secure.properties\n    echo \"keystore=$(prop nifi.security.keystore)\" >> secure.properties\n    echo \"keystorePasswd=$(prop nifi.security.keystorePasswd)\" >> secure.properties\n    echo \"truststoreType=$(prop nifi.security.truststoreType)\" >> secure.properties\n    echo \"truststore=$(prop nifi.security.truststore)\" >> secure.properties\n    echo \"truststorePasswd=$(prop nifi.security.truststorePasswd)\" >> secure.properties\n    echo \"proxiedEntity=CN=admin, OU=NIFI\" >> secure.properties\n   \n    secureArgs=\"-p secure.properties\"\n\n    echo baseUrl ${baseUrl}\n    echo \"gracefully disconnecting node '$FQDN' from cluster\"\n    ${NIFI_TOOLKIT_HOME}/bin/cli.sh nifi get-nodes -ot json -u ${baseUrl} ${secureArgs} > nodes.json\n    nnid=$(jq --arg FQDN \"$FQDN\" '.cluster.nodes[] | select(.address==$FQDN) | .nodeId' nodes.json)\n    echo \"disconnecting node ${nnid}\"\n    ${NIFI_TOOLKIT_HOME}/bin/cli.sh nifi disconnect-node -nnid $nnid -u ${baseUrl} ${secureArgs}\n    echo \"\"\n    echo \"get a connected node\"\n    connectedNode=$(jq -r 'first(.cluster.nodes|=sort_by(.address)| .cluster.nodes[] | select(.status==\"CONNECTED\")) | .address' nodes.json)\n    baseUrl=https://${connectedNode}:8443\n    echo baseUrl ${baseUrl}\n    echo \"\"\n    echo \"wait until node has state 'DISCONNECTED'\"\n    while [[ \"${node_state}\" != \"DISCONNECTED\" ]]; do\n        sleep 1\n        ${NIFI_TOOLKIT_HOME}/bin/cli.sh nifi get-nodes -ot json -u ${baseUrl} ${secureArgs} > nodes.json\n        node_state=$(jq -r --arg FQDN \"$FQDN\" '.cluster.nodes[] | select(.address==$FQDN) | .status' nodes.json)\n        echo \"state is '${node_state}'\"\n    done\n    echo \"\"\n    echo \"node '${nnid}' was disconnected\"\n    echo \"offloading node\"\n    ${NIFI_TOOLKIT_HOME}/bin/cli.sh nifi offload-node -nnid $nnid -u ${baseUrl} ${secureArgs}\n    echo \"\"\n    echo \"wait until node has state 'OFFLOADED'\"\n    while [[ \"${node_state}\" != \"OFFLOADED\" ]]; do\n        sleep 1\n        ${NIFI_TOOLKIT_HOME}/bin/cli.sh nifi get-nodes -ot json -u ${baseUrl} ${secureArgs} > nodes.json\n        node_state=$(jq -r --arg FQDN \"$FQDN\" '.cluster.nodes[] | select(.address==$FQDN) | .status' nodes.json)\n        echo \"state is '${node_state}'\"\n    done\n}\n\ndeleteNode() {\n    echo \"deleting node\"\n    ${NIFI_TOOLKIT_HOME}/bin/cli.sh nifi delete-node -nnid ${nnid} -u ${baseUrl} ${secureArgs}\n    echo \"node deleted\"\n}\n\ntrap 'echo Received trapped signal, beginning shutdown...;offloadNode;./bin/nifi.sh stop;deleteNode;exit 0;' TERM HUP INT;\ntrap \":\" EXIT\n\nexec bin/nifi.sh run & nifi_pid=\"$!\"\necho NiFi running with PID ${nifi_pid}.\nwait ${nifi_pid}\n"
              ],
              "resources": {
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "ports": [
                {
                  "containerPort": 8443,
                  "name": "https",
                  "protocol": "TCP"
                },
                {
                  "containerPort": 6007,
                  "name": "cluster",
                  "protocol": "TCP"
                }
              ],
              "env": [
                {
                  "name": "NIFI_ZOOKEEPER_CONNECT_STRING",
                  "value": "release-name-zookeeper:2181"
                }
              ],
              "lifecycle": {
                "postStart": {
                  "exec": {
                    "command": [
                      "/bin/sh",
                      "-c",
                      "/opt/nifi/psql; wget -P /opt/nifi/psql https://jdbc.postgresql.org/download/postgresql-42.2.6.jar"
                    ]
                  }
                }
              },
              "livenessProbe": {
                "initialDelaySeconds": 90,
                "periodSeconds": 60,
                "tcpSocket": {
                  "port": 8443
                }
              },
              "volumeMounts": [
                {
                  "name": "logs",
                  "mountPath": "/opt/nifi/nifi-current/logs"
                },
                {
                  "name": "data",
                  "mountPath": "/opt/nifi/data"
                },
                {
                  "name": "auth-conf",
                  "mountPath": "/opt/nifi/nifi-current/auth-conf/"
                },
                {
                  "name": "config-data",
                  "mountPath": "/opt/nifi/nifi-current/config-data"
                },
                {
                  "name": "flowfile-repository",
                  "mountPath": "/opt/nifi/flowfile_repository"
                },
                {
                  "name": "content-repository",
                  "mountPath": "/opt/nifi/content_repository"
                },
                {
                  "name": "provenance-repository",
                  "mountPath": "/opt/nifi/provenance_repository"
                },
                {
                  "name": "bootstrap-conf",
                  "mountPath": "/opt/nifi/nifi-current/conf/bootstrap.conf",
                  "subPath": "bootstrap.conf"
                },
                {
                  "name": "nifi-properties",
                  "mountPath": "/opt/nifi/nifi-current/conf/nifi.temp",
                  "subPath": "nifi.temp"
                },
                {
                  "name": "authorizers-temp",
                  "mountPath": "/opt/nifi/nifi-current/conf/authorizers.temp",
                  "subPath": "authorizers.temp"
                },
                {
                  "name": "bootstrap-notification-services-xml",
                  "mountPath": "/opt/nifi/nifi-current/conf/bootstrap-notification-services.xml",
                  "subPath": "bootstrap-notification-services.xml"
                },
                {
                  "name": "login-identity-providers-ldap-xml",
                  "mountPath": "/opt/nifi/nifi-current/conf/login-identity-providers-ldap.xml",
                  "subPath": "login-identity-providers-ldap.xml"
                },
                {
                  "name": "state-management-xml",
                  "mountPath": "/opt/nifi/nifi-current/conf/state-management.xml",
                  "subPath": "state-management.xml"
                },
                {
                  "name": "zookeeper-properties",
                  "mountPath": "/opt/nifi/nifi-current/conf/zookeeper.properties",
                  "subPath": "zookeeper.properties"
                },
                {
                  "name": "flow-content",
                  "mountPath": "/opt/nifi/data/flow.xml",
                  "subPath": "flow.xml"
                }
              ]
            },
            {
              "name": "app-log",
              "imagePullPolicy": "IfNotPresent",
              "image": "busybox:1.32.0",
              "args": [
                "tail",
                "-n+1",
                "-F",
                "/var/log/nifi-app.log"
              ],
              "resources": {
                "limits": {
                  "cpu": "50m",
                  "memory": "50Mi"
                },
                "requests": {
                  "cpu": "10m",
                  "memory": "10Mi"
                }
              },
              "volumeMounts": [
                {
                  "name": "logs",
                  "mountPath": "/var/log"
                }
              ]
            },
            {
              "name": "bootstrap-log",
              "imagePullPolicy": "IfNotPresent",
              "image": "busybox:1.32.0",
              "args": [
                "tail",
                "-n+1",
                "-F",
                "/var/log/nifi-bootstrap.log"
              ],
              "resources": {
                "limits": {
                  "cpu": "50m",
                  "memory": "50Mi"
                },
                "requests": {
                  "cpu": "10m",
                  "memory": "10Mi"
                }
              },
              "volumeMounts": [
                {
                  "name": "logs",
                  "mountPath": "/var/log"
                }
              ]
            },
            {
              "name": "user-log",
              "imagePullPolicy": "IfNotPresent",
              "image": "busybox:1.32.0",
              "args": [
                "tail",
                "-n+1",
                "-F",
                "/var/log/nifi-user.log"
              ],
              "resources": {
                "limits": {
                  "cpu": "50m",
                  "memory": "50Mi"
                },
                "requests": {
                  "cpu": "10m",
                  "memory": "10Mi"
                }
              },
              "volumeMounts": [
                {
                  "name": "logs",
                  "mountPath": "/var/log"
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "bootstrap-conf",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "bootstrap.conf",
                    "path": "bootstrap.conf"
                  }
                ]
              }
            },
            {
              "name": "nifi-properties",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "nifi.properties",
                    "path": "nifi.temp"
                  }
                ]
              }
            },
            {
              "name": "authorizers-temp",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "authorizers.xml",
                    "path": "authorizers.temp"
                  }
                ]
              }
            },
            {
              "name": "bootstrap-notification-services-xml",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "bootstrap-notification-services.xml",
                    "path": "bootstrap-notification-services.xml"
                  }
                ]
              }
            },
            {
              "name": "login-identity-providers-ldap-xml",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "login-identity-providers-ldap.xml",
                    "path": "login-identity-providers-ldap.xml"
                  }
                ]
              }
            },
            {
              "name": "state-management-xml",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "state-management.xml",
                    "path": "state-management.xml"
                  }
                ]
              }
            },
            {
              "name": "zookeeper-properties",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "zookeeper.properties",
                    "path": "zookeeper.properties"
                  }
                ]
              }
            },
            {
              "name": "flow-content",
              "configMap": {
                "name": "release-name-nifi-config",
                "items": [
                  {
                    "key": "flow.xml",
                    "path": "flow.xml"
                  }
                ]
              }
            }
          ]
        }
      },
      "volumeClaimTemplates": [
        {
          "metadata": {
            "name": "logs"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "storageClassName": null,
            "resources": {
              "requests": {
                "storage": "5Gi"
              }
            }
          }
        },
        {
          "metadata": {
            "name": "config-data"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "storageClassName": null,
            "resources": {
              "requests": {
                "storage": "100Mi"
              }
            }
          }
        },
        {
          "metadata": {
            "name": "data"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "storageClassName": null,
            "resources": {
              "requests": {
                "storage": "1Gi"
              }
            }
          }
        },
        {
          "metadata": {
            "name": "flowfile-repository"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "storageClassName": null,
            "resources": {
              "requests": {
                "storage": "10Gi"
              }
            }
          }
        },
        {
          "metadata": {
            "name": "content-repository"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "storageClassName": null,
            "resources": {
              "requests": {
                "storage": "10Gi"
              }
            }
          }
        },
        {
          "metadata": {
            "name": "provenance-repository"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "storageClassName": null,
            "resources": {
              "requests": {
                "storage": "10Gi"
              }
            }
          }
        },
        {
          "metadata": {
            "name": "auth-conf"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "storageClassName": null,
            "resources": {
              "requests": {
                "storage": "100Mi"
              }
            }
          }
        }
      ]
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "release-name-postgresql",
      "labels": {
        "app": "postgresql",
        "chart": "postgresql-0.2.3",
        "release": "release-name",
        "heritage": "Helm"
      }
    },
    "spec": {
      "serviceName": "release-name-postgresql-headless",
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app": "postgresql",
          "release": "release-name"
        }
      },
      "template": {
        "metadata": {
          "name": "release-name-postgresql",
          "labels": {
            "app": "postgresql",
            "chart": "postgresql-0.2.3",
            "release": "release-name",
            "heritage": "Helm"
          }
        },
        "spec": {
          "initContainers": [
            {
              "name": "init-chmod-data",
              "image": "debian:buster-slim",
              "imagePullPolicy": "Always",
              "resources": {},
              "command": [
                "sh",
                "-c",
                "mkdir -p /var/lib/postgresql/data\nchmod 700 /var/lib/postgresql/data\nfind /var/lib/postgresql -mindepth 1 -maxdepth 1 -not -name \".snapshot\" -not -name \"lost+found\" | \\\n  xargs chown -R 1001:1001\n"
              ],
              "securityContext": {
                "runAsUser": 0
              },
              "volumeMounts": [
                {
                  "name": "data",
                  "mountPath": "/var/lib/postgresql",
                  "subPath": null
                }
              ]
            }
          ],
          "containers": [
            {
              "name": "release-name-postgresql",
              "image": "postgres:11.5",
              "args": [
                "-c",
                "hba_file=/var/lib/postgresql/conf/pg_hba.conf"
              ],
              "imagePullPolicy": "IfNotPresent",
              "resources": {
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "env": [
                {
                  "name": "POSTGRES_PASSWORD",
                  "value": "Z2JHHezi4aAA"
                },
                {
                  "name": "POSTGRES_USER",
                  "value": "admin"
                },
                {
                  "name": "POSTGRES_DB",
                  "value": "postgres"
                },
                {
                  "name": "PGDATA",
                  "value": "/var/lib/postgresql/data/pgdata"
                }
              ],
              "ports": [
                {
                  "name": "postgresql",
                  "containerPort": 5432
                }
              ],
              "livenessProbe": null,
              "readinessProbe": null,
              "volumeMounts": [
                {
                  "name": "data",
                  "mountPath": "/var/lib/postgresql/data",
                  "subPath": null,
                  "readOnly": false
                },
                {
                  "name": "postgresql-config-pghba",
                  "mountPath": "/var/lib/postgresql/conf/pg_hba.conf",
                  "subPath": "pg_hba.conf",
                  "readOnly": false
                },
                {
                  "name": "postgresql-config-initdbscripts",
                  "mountPath": "/docker-entrypoint-initdb.d/initdbscripts.sh",
                  "subPath": "initdbscripts.sh",
                  "readOnly": false
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "postgresql-config-pghba",
              "configMap": {
                "name": "release-name-postgresql-configuration",
                "items": [
                  {
                    "key": "pg_hba.conf",
                    "path": "pg_hba.conf"
                  }
                ]
              }
            },
            {
              "name": "postgresql-config-initdbscripts",
              "configMap": {
                "name": "release-name-postgresql-configuration",
                "items": [
                  {
                    "key": "initdbscripts.sh",
                    "path": "initdbscripts.sh"
                  }
                ]
              }
            }
          ]
        }
      },
      "volumeClaimTemplates": [
        {
          "metadata": {
            "name": "data"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "resources": {
              "requests": {
                "storage": "10Gi"
              }
            }
          }
        }
      ]
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "release-name-spark-master",
      "labels": {
        "app.kubernetes.io/name": "spark",
        "helm.sh/chart": "spark-4.1.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "master"
      }
    },
    "spec": {
      "serviceName": "release-name-spark-headless",
      "replicas": 1,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "spark",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "master"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "spark",
            "helm.sh/chart": "spark-4.1.0",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "master"
          }
        },
        "spec": {
          "securityContext": {
            "fsGroup": 1001,
            "runAsUser": 1001
          },
          "containers": [
            {
              "name": "spark-master",
              "image": "docker.io/bitnami/spark:3.0.1-debian-10-r65",
              "imagePullPolicy": "IfNotPresent",
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8080,
                  "protocol": "TCP"
                },
                {
                  "name": "cluster",
                  "containerPort": 7077
                }
              ],
              "volumeMounts": null,
              "env": [
                {
                  "name": "SPARK_MODE",
                  "value": "master"
                },
                {
                  "name": "SPARK_DAEMON_MEMORY",
                  "value": null
                },
                {
                  "name": "SPARK_MASTER_PORT",
                  "value": "7077"
                },
                {
                  "name": "SPARK_MASTER_WEBUI_PORT",
                  "value": "8080"
                }
              ],
              "livenessProbe": {
                "httpGet": {
                  "path": "/",
                  "port": 8080
                },
                "initialDelaySeconds": 180,
                "periodSeconds": 20,
                "timeoutSeconds": 5,
                "successThreshold": 1,
                "failureThreshold": 6
              },
              "readinessProbe": {
                "httpGet": {
                  "path": "/",
                  "port": 8080
                },
                "initialDelaySeconds": 30,
                "periodSeconds": 10,
                "timeoutSeconds": 5,
                "successThreshold": 1,
                "failureThreshold": 6
              },
              "resources": {
                "limits": {},
                "requests": {},
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ],
          "volumes": null
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "release-name-spark-worker",
      "labels": {
        "app.kubernetes.io/name": "spark",
        "helm.sh/chart": "spark-4.1.0",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "worker"
      }
    },
    "spec": {
      "serviceName": "release-name-spark-headless",
      "replicas": 2,
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "spark",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "worker"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "spark",
            "helm.sh/chart": "spark-4.1.0",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "worker"
          }
        },
        "spec": {
          "securityContext": {
            "fsGroup": 1001,
            "runAsUser": 1001
          },
          "containers": [
            {
              "name": "spark-worker",
              "image": "docker.io/bitnami/spark:3.0.1-debian-10-r65",
              "imagePullPolicy": "IfNotPresent",
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8081,
                  "protocol": "TCP"
                }
              ],
              "volumeMounts": null,
              "env": [
                {
                  "name": "SPARK_MODE",
                  "value": "worker"
                },
                {
                  "name": "BASH_DEBUG",
                  "value": "0"
                },
                {
                  "name": "SPARK_DAEMON_MEMORY",
                  "value": null
                },
                {
                  "name": "SPARK_WORKER_WEBUI_PORT",
                  "value": "8081"
                },
                {
                  "name": "SPARK_DAEMON_JAVA_OPTS",
                  "value": null
                },
                {
                  "name": "SPARK_MASTER_URL",
                  "value": "spark://release-name-spark-master-svc:7077"
                },
                {
                  "name": "SPARK_WORKER_OPTS",
                  "value": null
                }
              ],
              "livenessProbe": {
                "httpGet": {
                  "path": "/",
                  "port": 8081
                },
                "initialDelaySeconds": 180,
                "periodSeconds": 20,
                "timeoutSeconds": 5,
                "successThreshold": 1,
                "failureThreshold": 6
              },
              "readinessProbe": {
                "httpGet": {
                  "path": "/",
                  "port": 8081
                },
                "initialDelaySeconds": 30,
                "periodSeconds": 10,
                "timeoutSeconds": 5,
                "successThreshold": 1,
                "failureThreshold": 6
              },
              "resources": {
                "limits": {},
                "requests": {},
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ],
          "volumes": null
        }
      }
    }
  },
  {
    "apiVersion": "batch/v1beta1",
    "kind": "CronJob",
    "metadata": {
      "name": "pg-ldap-sync"
    },
    "spec": {
      "schedule": "*/30 * * * *",
      "jobTemplate": {
        "metadata": {
          "labels": {
            "app": "release-name"
          }
        },
        "spec": {
          "template": {
            "spec": {
              "containers": [
                {
                  "name": "pg-ldap-sync",
                  "image": "ceticasbl/pg-ldap-sync:latest",
                  "args": [
                    "/workspace/pgldap-config.yaml",
                    "-vv"
                  ],
                  "imagePullPolicy": "IfNotPresent",
                  "volumeMounts": [
                    {
                      "name": "pgldap-config",
                      "mountPath": "/workspace",
                      "subPath": ""
                    }
                  ]
                }
              ],
              "restartPolicy": "Never",
              "volumes": [
                {
                  "name": "pgldap-config",
                  "configMap": {
                    "name": "release-name-postgresql-pgldap-config",
                    "items": [
                      {
                        "key": "pgldap-config.yaml",
                        "path": "pgldap-config.yaml"
                      }
                    ]
                  }
                }
              ]
            }
          }
        }
      }
    }
  },
  {
    "apiVersion": "traefik.containo.us/v1alpha1",
    "kind": "IngressRoute",
    "metadata": {
      "name": "grafana-http"
    },
    "spec": {
      "entryPoints": [
        "web"
      ],
      "routes": [
        {
          "kind": "Rule",
          "match": "Host(`grafana.example.cetic.be`) && PathPrefix(`/`)",
          "services": [
            {
              "name": "release-name-grafana",
              "port": 80
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "traefik.containo.us/v1alpha1",
    "kind": "IngressRoute",
    "metadata": {
      "name": "nifi-http"
    },
    "spec": {
      "entryPoints": [
        "web"
      ],
      "routes": [
        {
          "kind": "Rule",
          "match": "Host(`nifi.example.cetic.be`) && PathPrefix(`/`)",
          "services": [
            {
              "name": "release-name-nifi",
              "port": 8443
            }
          ],
          "middlewares": [
            {
              "name": "https-redirect"
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "traefik.containo.us/v1alpha1",
    "kind": "IngressRoute",
    "metadata": {
      "name": "hub-http"
    },
    "spec": {
      "entryPoints": [
        "web"
      ],
      "routes": [
        {
          "kind": "Rule",
          "match": "Host(`jupyterhub.example.cetic.be`) && PathPrefix(`/`)",
          "services": [
            {
              "name": "proxy-public",
              "port": 80
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "traefik.containo.us/v1alpha1",
    "kind": "IngressRoute",
    "metadata": {
      "name": "superset-http"
    },
    "spec": {
      "entryPoints": [
        "web"
      ],
      "routes": [
        {
          "kind": "Rule",
          "match": "Host(`superset.example.cetic.be`) && PathPrefix(`/`)",
          "services": [
            {
              "name": "release-name-superset",
              "port": 9000
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "traefik.containo.us/v1alpha1",
    "kind": "IngressRoute",
    "metadata": {
      "name": "keycloak-http"
    },
    "spec": {
      "entryPoints": [
        "web"
      ],
      "routes": [
        {
          "kind": "Rule",
          "match": "Host(`keycloak.example.cetic.be`) && PathPrefix(`/`)",
          "services": [
            {
              "name": "release-name-keycloak",
              "port": 80
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "traefik.containo.us/v1alpha1",
    "kind": "IngressRouteTCP",
    "metadata": {
      "name": "nifi"
    },
    "spec": {
      "entryPoints": [
        "websecure"
      ],
      "routes": [
        {
          "match": "HostSNI(`nifi.example.cetic.be`)",
          "services": [
            {
              "name": "release-name-nifi",
              "port": 8443
            }
          ]
        }
      ],
      "tls": {
        "passthrough": true
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "List",
    "metadata": {
      "name": "release-name-traefik"
    },
    "items": [
      {
        "apiVersion": "v1",
        "kind": "Service",
        "metadata": {
          "name": "release-name-traefik",
          "labels": {
            "app.kubernetes.io/name": "traefik",
            "helm.sh/chart": "traefik-10.6.2",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/instance": "release-name"
          },
          "annotations": null
        },
        "spec": {
          "type": "LoadBalancer",
          "loadBalancerIP": null,
          "selector": {
            "app.kubernetes.io/name": "traefik",
            "app.kubernetes.io/instance": "release-name"
          },
          "ports": [
            {
              "port": 80,
              "name": "web",
              "targetPort": "web",
              "protocol": "TCP"
            },
            {
              "port": 443,
              "name": "websecure",
              "targetPort": "websecure",
              "protocol": "TCP"
            }
          ]
        }
      }
    ]
  },
  {
    "apiVersion": "v1",
    "kind": "Pod",
    "metadata": {
      "name": "release-name-grafana-test",
      "labels": {
        "helm.sh/chart": "grafana-6.1.17",
        "app.kubernetes.io/name": "grafana",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/version": "7.3.5",
        "app.kubernetes.io/managed-by": "Helm"
      },
      "annotations": {
        "helm.sh/hook": "test-success"
      },
      "namespace": "qE6qSW8pmXLGc"
    },
    "spec": {
      "serviceAccountName": "release-name-grafana-test",
      "containers": [
        {
          "name": "release-name-test",
          "image": "bats/bats:v1.1.0",
          "imagePullPolicy": "IfNotPresent",
          "command": [
            "/opt/bats/bin/bats",
            "-t",
            "/tests/run.sh"
          ],
          "volumeMounts": [
            {
              "mountPath": "/tests",
              "name": "tests",
              "readOnly": true
            }
          ]
        }
      ],
      "volumes": [
        {
          "name": "tests",
          "configMap": {
            "name": "release-name-grafana-test"
          }
        }
      ],
      "restartPolicy": "Never"
    }
  },
  {
    "apiVersion": "traefik.containo.us/v1alpha1",
    "kind": "IngressRoute",
    "metadata": {
      "name": "release-name-traefik-dashboard",
      "annotations": {
        "helm.sh/hook": "post-install,post-upgrade"
      },
      "labels": {
        "app.kubernetes.io/name": "traefik",
        "helm.sh/chart": "traefik-10.6.2",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/instance": "release-name"
      }
    },
    "spec": {
      "entryPoints": [
        "traefik"
      ],
      "routes": [
        {
          "match": "PathPrefix(`/dashboard`) || PathPrefix(`/api`)",
          "kind": "Rule",
          "services": [
            {
              "name": "api@internal",
              "kind": "TraefikService"
            }
          ]
        }
      ]
    }
  }
]