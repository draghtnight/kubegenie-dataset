[
  {
    "apiVersion": "networking.k8s.io/v1",
    "kind": "NetworkPolicy",
    "metadata": {
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      },
      "name": "release-name-jupyterhub-hub",
      "namespace": "default"
    },
    "spec": {
      "podSelector": {
        "matchLabels": {
          "app.kubernetes.io/name": "jupyterhub",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "hub"
        }
      },
      "policyTypes": [
        "Ingress",
        "Egress"
      ],
      "ingress": [
        {
          "ports": [
            {
              "port": 8081
            }
          ],
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-hub": "true"
                }
              },
              "namespaceSelector": {
                "matchLabels": {}
              }
            },
            {
              "namespaceSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-hub": "true"
                }
              }
            }
          ]
        }
      ],
      "egress": [
        {
          "ports": [
            {
              "port": 8001
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "app.kubernetes.io/name": "jupyterhub",
                  "app.kubernetes.io/instance": "release-name",
                  "app.kubernetes.io/component": "proxy"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "port": 8888
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "app.kubernetes.io/name": "jupyterhub",
                  "app.kubernetes.io/instance": "release-name",
                  "app.kubernetes.io/component": "singleuser"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 53
            },
            {
              "protocol": "TCP",
              "port": 53
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 5432
            },
            {
              "protocol": "TCP",
              "port": 5432
            }
          ]
        },
        {
          "to": null
        }
      ]
    }
  },
  {
    "apiVersion": "networking.k8s.io/v1",
    "kind": "NetworkPolicy",
    "metadata": {
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "proxy"
      },
      "name": "release-name-jupyterhub-proxy",
      "namespace": "default"
    },
    "spec": {
      "podSelector": {
        "matchLabels": {
          "app.kubernetes.io/name": "jupyterhub",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "proxy"
        }
      },
      "policyTypes": [
        "Ingress",
        "Egress"
      ],
      "ingress": [
        {
          "ports": [
            {
              "port": 8000
            }
          ]
        },
        {
          "ports": [
            {
              "port": 8001
            }
          ],
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-proxy-api": "true"
                }
              },
              "namespaceSelector": {
                "matchLabels": {}
              }
            },
            {
              "namespaceSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-proxy-api": "true"
                }
              }
            }
          ]
        }
      ],
      "egress": [
        {
          "ports": [
            {
              "port": 8081
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "app.kubernetes.io/name": "jupyterhub",
                  "app.kubernetes.io/instance": "release-name",
                  "app.kubernetes.io/component": "hub"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "port": 8888
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "app.kubernetes.io/name": "jupyterhub",
                  "app.kubernetes.io/instance": "release-name",
                  "app.kubernetes.io/component": "singleuser"
                }
              }
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 53
            },
            {
              "protocol": "TCP",
              "port": 53
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "networking.k8s.io/v1",
    "kind": "NetworkPolicy",
    "metadata": {
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "singleuser"
      },
      "name": "release-name-jupyterhub-singleuser",
      "namespace": "default"
    },
    "spec": {
      "podSelector": {
        "matchLabels": {
          "app.kubernetes.io/name": "jupyterhub",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "singleuser"
        }
      },
      "policyTypes": [
        "Ingress",
        "Egress"
      ],
      "ingress": [
        {
          "ports": [
            {
              "port": 8888
            }
          ],
          "from": [
            {
              "podSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-singleuser": "true"
                }
              },
              "namespaceSelector": {
                "matchLabels": {}
              }
            },
            {
              "namespaceSelector": {
                "matchLabels": {
                  "hub.jupyter.org/network-access-singleuser": "true"
                }
              }
            }
          ]
        }
      ],
      "egress": [
        {
          "ports": [
            {
              "port": 8081
            }
          ],
          "to": [
            {
              "podSelector": {
                "matchLabels": {
                  "app.kubernetes.io/name": "jupyterhub",
                  "app.kubernetes.io/instance": "release-name",
                  "app.kubernetes.io/component": "hub"
                }
              }
            }
          ]
        },
        {
          "to": [
            {
              "ipBlock": {
                "cidr": "0.0.0.0/0",
                "except": [
                  "169.254.169.254/32"
                ]
              }
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 53
            },
            {
              "protocol": "TCP",
              "port": 53
            }
          ]
        },
        {
          "ports": [
            {
              "protocol": "UDP",
              "port": 5432
            },
            {
              "protocol": "TCP",
              "port": 5432
            }
          ]
        }
      ]
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "release-name-jupyterhub-hub",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      },
      "annotations": null
    },
    "automountServiceAccountToken": true
  },
  {
    "apiVersion": "v1",
    "kind": "ServiceAccount",
    "metadata": {
      "name": "release-name-jupyterhub-singleuser",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "singleuser"
      },
      "annotations": null
    },
    "automountServiceAccountToken": true
  },
  {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
      "name": "release-name-postgresql",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "postgresql",
        "helm.sh/chart": "postgresql-11.6.5",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm"
      }
    },
    "type": "Opaque",
    "data": {
      "postgres-password": "dmJyeEdNU0E0Ng==",
      "password": "eTNYcmtESTN1Zg=="
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Secret",
    "metadata": {
      "name": "release-name-jupyterhub-hub",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      }
    },
    "type": "Opaque",
    "data": {
      "values.yaml": "Q2hhcnQ6CiAgTmFtZToganVweXRlcmh1YgogIFZlcnNpb246IDEuMy42ClJlbGVhc2U6CiAgTmFtZTogcmVsZWFzZS1uYW1lCiAgTmFtZXNwYWNlOiBkZWZhdWx0CiAgU2VydmljZTogSGVsbQpodWI6CiAgY29uZmlnOgogICAgSnVweXRlckh1YjoKICAgICAgYWRtaW5fYWNjZXNzOiB0cnVlCiAgICAgIGF1dGhlbnRpY2F0b3JfY2xhc3M6IGR1bW15CiAgICAgIGNvb2tpZV9zZWNyZXRfZmlsZTogL3RtcC9qdXB5dGVyaHViX2Nvb2tpZV9zZWNyZXQKICAgICAgRHVtbXlBdXRoZW50aWNhdG9yOgogICAgICAgIHBhc3N3b3JkOiAieTIzcE9JV0R2eSIKICAgICAgQXV0aGVudGljYXRvcjoKICAgICAgICBhZG1pbl91c2VyczoKICAgICAgICAgIC0gdXNlcgogIGNvb2tpZVNlY3JldDoKICBjb25jdXJyZW50U3Bhd25MaW1pdDogNjQKICBjb25zZWN1dGl2ZUZhaWx1cmVMaW1pdDogNQogIGFjdGl2ZVNlcnZlckxpbWl0OgogIGRiOgogICAgdHlwZTogcG9zdGdyZXMKICAgIHVybDogcG9zdGdyZXNxbDovL2JuX2p1cHl0ZXJodWJAcmVsZWFzZS1uYW1lLXBvc3RncmVzcWw6NTQzMi9iaXRuYW1pX2p1cHl0ZXJodWIKICBzZXJ2aWNlczoge30KICBhbGxvd05hbWVkU2VydmVyczogZmFsc2UKICBuYW1lZFNlcnZlckxpbWl0UGVyVXNlcjoKICByZWRpcmVjdFRvU2VydmVyOgogIHNodXRkb3duT25Mb2dvdXQ6CnNpbmdsZXVzZXI6CiAgcG9kTmFtZVRlbXBsYXRlOiByZWxlYXNlLW5hbWUtanVweXRlcmh1Yi1qdXB5dGVyLXt1c2VybmFtZX0KICBuZXR3b3JrVG9vbHM6CiAgICBpbWFnZToKICAgICAgbmFtZTogZG9ja2VyLmlvL2JpdG5hbWkvYml0bmFtaS1zaGVsbAogICAgICB0YWc6IDExLWRlYmlhbi0xMS1yMwogICAgICBwdWxsUG9saWN5OiBJZk5vdFByZXNlbnQKICAgICAgcHVsbFNlY3JldHM6CiAgICAgICAgCiAgY2xvdWRNZXRhZGF0YToKICAgIGJsb2NrV2l0aElwdGFibGVzOiBmYWxzZQogIGV2ZW50czogdHJ1ZQogIGV4dHJhQW5ub3RhdGlvbnM6CiAgZXh0cmFMYWJlbHM6CiAgICBodWIuanVweXRlci5vcmcvbmV0d29yay1hY2Nlc3MtaHViOiAidHJ1ZSIKICAgIGFwcC5rdWJlcm5ldGVzLmlvL2NvbXBvbmVudDogc2luZ2xldXNlcgogICAgYXBwLmt1YmVybmV0ZXMuaW8vbmFtZToganVweXRlcmh1YgogICAgaGVsbS5zaC9jaGFydDoganVweXRlcmh1Yi0xLjMuNgogICAgYXBwLmt1YmVybmV0ZXMuaW8vaW5zdGFuY2U6IHJlbGVhc2UtbmFtZQogICAgYXBwLmt1YmVybmV0ZXMuaW8vbWFuYWdlZC1ieTogSGVsbQogIHVpZDogMTAwMQogIGZzR2lkOiAxMDAxCiAgc2VydmljZUFjY291bnROYW1lOiByZWxlYXNlLW5hbWUtanVweXRlcmh1Yi1zaW5nbGV1c2VyCiAgc3RvcmFnZToKICAgIHR5cGU6IGR5bmFtaWMKICAgIGV4dHJhTGFiZWxzOgogICAgICBhcHAua3ViZXJuZXRlcy5pby9jb21wb25lbnQ6IHNpbmdsZXVzZXIKICAgICAgYXBwLmt1YmVybmV0ZXMuaW8vbmFtZToganVweXRlcmh1YgogICAgICBoZWxtLnNoL2NoYXJ0OiBqdXB5dGVyaHViLTEuMy42CiAgICAgIGFwcC5rdWJlcm5ldGVzLmlvL2luc3RhbmNlOiByZWxlYXNlLW5hbWUKICAgICAgYXBwLmt1YmVybmV0ZXMuaW8vbWFuYWdlZC1ieTogSGVsbQogICAgY2FwYWNpdHk6IDEwR2kKICAgIGhvbWVNb3VudFBhdGg6IC9vcHQvYml0bmFtaS9qdXB5dGVyaHViLXNpbmdsZXVzZXIKICAgIGR5bmFtaWM6CiAgICAgIAogICAgICBwdmNOYW1lVGVtcGxhdGU6IHJlbGVhc2UtbmFtZS1qdXB5dGVyaHViLWNsYWltLXt1c2VybmFtZX17c2VydmVybmFtZX0KICAgICAgdm9sdW1lTmFtZVRlbXBsYXRlOiByZWxlYXNlLW5hbWUtanVweXRlcmh1Yi12b2x1bWUte3VzZXJuYW1lfXtzZXJ2ZXJuYW1lfQogICAgICBzdG9yYWdlQWNjZXNzTW9kZXM6CiAgICAgICAgLSBSZWFkV3JpdGVPbmNlCiAgaW1hZ2U6CiAgICBuYW1lOiBkb2NrZXIuaW8vYml0bmFtaS9qdXB5dGVyLWJhc2Utbm90ZWJvb2sKICAgIHRhZzogMS41LjAtZGViaWFuLTExLXIzCiAgICBwdWxsUG9saWN5OiBJZk5vdFByZXNlbnQKICAgIHB1bGxTZWNyZXRzOgogICAgICAgIAogIHN0YXJ0VGltZW91dDogMzAwCiAgY3B1OgogICAgbGltaXQ6IAogICAgZ3VhcmFudGVlOiAKICBtZW1vcnk6CiAgICBsaW1pdDogCiAgICBndWFyYW50ZWU6IAogIGNtZDoganVweXRlcmh1Yi1zaW5nbGV1c2VyCiAgZGVmYXVsdFVybDoKY3VsbDoKICBlbmFibGVkOiB0cnVlCiAgdXNlcnM6IGZhbHNlCiAgcmVtb3ZlTmFtZWRTZXJ2ZXJzOiBmYWxzZQogIHRpbWVvdXQ6IDM2MDAKICBldmVyeTogNjAwCiAgY29uY3VycmVuY3k6IDEwCiAgbWF4QWdlOiAwCg==",
      "proxy-token": "M3NhRlNiM3VpZnpvc1FMUjl6bUN3TTRaNnpzcXRFSUM="
    }
  },
  {
    "apiVersion": "v1",
    "kind": "ConfigMap",
    "metadata": {
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      },
      "name": "release-name-jupyterhub-hub",
      "namespace": "PKxINInLHAp"
    },
    "data": {
      "jupyterhub_config.py": "import os\nimport re\nimport sys\n\nfrom binascii import a2b_hex\n\nfrom tornado.httpclient import AsyncHTTPClient\nfrom kubernetes import client\nfrom jupyterhub.utils import url_path_join\n\n# Make sure that modules placed in the same directory as the jupyterhub config are added to the pythonpath\nconfiguration_directory = os.path.dirname(os.path.realpath(__file__))\nsys.path.insert(0, configuration_directory)\n\nfrom z2jh import get_config, set_config_if_not_none\n\ndef camelCaseify(s):\n    \"\"\"convert snake_case to camelCase\n\n    For the common case where some_value is set from someValue\n    so we don't have to specify the name twice.\n    \"\"\"\n    return re.sub(r\"_([a-z])\", lambda m: m.group(1).upper(), s)\n\n# Configure JupyterHub to use the curl backend for making HTTP requests,\n# rather than the pure-python implementations. The default one starts\n# being too slow to make a large number of requests to the proxy API\n# at the rate required.\nAsyncHTTPClient.configure(\"tornado.curl_httpclient.CurlAsyncHTTPClient\")\n\nc.JupyterHub.spawner_class = \"kubespawner.KubeSpawner\"\n\n# Connect to a proxy running in a different pod. Note that *_SERVICE_*\n# environment variables are set by Kubernetes for Services\n# Adapted by Bitnami to allow other service names\nc.ConfigurableHTTPProxy.api_url = (\n    f\"http://release-name-jupyterhub-proxy-api:{os.environ['PROXY_API_SERVICE_PORT']}\"\n)\nc.ConfigurableHTTPProxy.should_start = False\n\n# Do not shut down user pods when hub is restarted\nc.JupyterHub.cleanup_servers = False\n\n# Check that the proxy has routes appropriately setup\nc.JupyterHub.last_activity_interval = 60\n\n# Don't wait at all before redirecting a spawning user to the progress page\nc.JupyterHub.tornado_settings = {\n    \"slow_spawn_timeout\": 0,\n}\n\n# configure the hub db connection\ndb_type = get_config(\"hub.db.type\")\nif db_type == \"sqlite-pvc\":\n    c.JupyterHub.db_url = \"sqlite:///jupyterhub.sqlite\"\nelif db_type == \"sqlite-memory\":\n    c.JupyterHub.db_url = \"sqlite://\"\nelse:\n    set_config_if_not_none(c.JupyterHub, \"db_url\", \"hub.db.url\")\n\n# c.JupyterHub configuration from Helm chart's configmap\nfor trait, cfg_key in (\n    (\"concurrent_spawn_limit\", None),\n    (\"active_server_limit\", None),\n    (\"base_url\", None),\n    # ('cookie_secret', None),  # requires a Hex -> Byte transformation\n    (\"allow_named_servers\", None),\n    (\"named_server_limit_per_user\", None),\n    (\"authenticate_prometheus\", None),\n    (\"redirect_to_server\", None),\n    (\"shutdown_on_logout\", None),\n    (\"template_paths\", None),\n    (\"template_vars\", None),\n):\n    if cfg_key is None:\n        cfg_key = camelCaseify(trait)\n    set_config_if_not_none(c.JupyterHub, trait, \"hub.\" + cfg_key)\n\n# a required Hex -> Byte transformation\ncookie_secret_hex = get_config(\"hub.cookieSecret\")\nif cookie_secret_hex:\n    c.JupyterHub.cookie_secret = a2b_hex(cookie_secret_hex)\n\n# hub_bind_url configures what the JupyterHub process within the hub pod's\n# container should listen to.\nhub_container_port = 8081\nc.JupyterHub.hub_bind_url = f\"http://:{hub_container_port}\"\n\n# hub_connect_url is the URL for connecting to the hub for use by external\n# JupyterHub services such as the proxy. Note that *_SERVICE_* environment\n# variables are set by Kubernetes for Services.\nc.JupyterHub.hub_connect_url = f\"http://release-name-jupyterhub-hub:{os.environ['HUB_SERVICE_PORT']}\"\n\nc.KubeSpawner.port = 8888\nc.KubeSpawner.notebook_dir = \"/opt/bitnami/jupyterhub-singleuser\"\n\n# implement common labels\n# this duplicates the jupyterhub.commonLabels helper\ncommon_labels = c.KubeSpawner.common_labels = {}\ncommon_labels[\"app\"] = get_config(\n    \"nameOverride\",\n    default=get_config(\"Chart.Name\", \"jupyterhub\"),\n)\ncommon_labels[\"heritage\"] = \"jupyterhub\"\nchart_name = get_config(\"Chart.Name\")\nchart_version = get_config(\"Chart.Version\")\nif chart_name and chart_version:\n    common_labels[\"chart\"] = \"{}-{}\".format(\n        chart_name,\n        chart_version.replace(\"+\", \"_\"),\n    )\nrelease = get_config(\"Release.Name\")\nif release:\n    common_labels[\"release\"] = release\n\nc.KubeSpawner.namespace = os.environ.get(\"POD_NAMESPACE\", \"default\")\n\n# Max number of consecutive failures before the Hub restarts itself\n# requires jupyterhub 0.9.2\nset_config_if_not_none(\n    c.Spawner,\n    \"consecutive_failure_limit\",\n    \"hub.consecutiveFailureLimit\",\n)\n\nfor trait, cfg_key in (\n    (\"pod_name_template\", None),\n    (\"start_timeout\", None),\n    (\"image_pull_policy\", \"image.pullPolicy\"),\n    # ('image_pull_secrets', 'image.pullSecrets'), # Managed manually below\n    (\"events_enabled\", \"events\"),\n    (\"extra_labels\", None),\n    (\"extra_annotations\", None),\n    (\"uid\", None),\n    (\"fs_gid\", None),\n    (\"run_privileged\", None),\n    (\"allow_privilege_escalation\", None),\n    (\"service_account\", \"serviceAccountName\"),\n    (\"storage_extra_labels\", \"storage.extraLabels\"),\n    (\"tolerations\", \"extraTolerations\"),\n    (\"node_selector\", None),\n    (\"node_affinity_required\", \"extraNodeAffinity.required\"),\n    (\"node_affinity_preferred\", \"extraNodeAffinity.preferred\"),\n    (\"pod_affinity_required\", \"extraPodAffinity.required\"),\n    (\"pod_affinity_preferred\", \"extraPodAffinity.preferred\"),\n    (\"pod_anti_affinity_required\", \"extraPodAntiAffinity.required\"),\n    (\"pod_anti_affinity_preferred\", \"extraPodAntiAffinity.preferred\"),\n    (\"lifecycle_hooks\", None),\n    (\"init_containers\", None),\n    (\"extra_containers\", None),\n    (\"mem_limit\", \"memory.limit\"),\n    (\"mem_guarantee\", \"memory.guarantee\"),\n    (\"cpu_limit\", \"cpu.limit\"),\n    (\"cpu_guarantee\", \"cpu.guarantee\"),\n    (\"extra_resource_limits\", \"extraResource.limits\"),\n    (\"extra_resource_guarantees\", \"extraResource.guarantees\"),\n    (\"environment\", \"extraEnv\"),\n    (\"profile_list\", None),\n    (\"extra_pod_config\", None),\n):\n    if cfg_key is None:\n        cfg_key = camelCaseify(trait)\n    set_config_if_not_none(c.KubeSpawner, trait, \"singleuser.\" + cfg_key)\n\nimage = get_config(\"singleuser.image.name\")\nif image:\n    tag = get_config(\"singleuser.image.tag\")\n    if tag:\n        image = \"{}:{}\".format(image, tag)\n\n    c.KubeSpawner.image = image\n\n# Combine imagePullSecret.create (single), imagePullSecrets (list), and\n# singleuser.image.pullSecrets (list).\nimage_pull_secrets = []\nif get_config(\"imagePullSecret.automaticReferenceInjection\") and (\n    get_config(\"imagePullSecret.create\") or get_config(\"imagePullSecret.enabled\")\n):\n    image_pull_secrets.append(\"image-pull-secret\")\nif get_config(\"imagePullSecrets\"):\n    image_pull_secrets.extend(get_config(\"imagePullSecrets\"))\nif get_config(\"singleuser.image.pullSecrets\"):\n    image_pull_secrets.extend(get_config(\"singleuser.image.pullSecrets\"))\nif image_pull_secrets:\n    c.KubeSpawner.image_pull_secrets = image_pull_secrets\n\n# scheduling:\nif get_config(\"scheduling.userScheduler.enabled\"):\n    c.KubeSpawner.scheduler_name = os.environ[\"HELM_RELEASE_NAME\"] + \"-user-scheduler\"\nif get_config(\"scheduling.podPriority.enabled\"):\n    c.KubeSpawner.priority_class_name = (\n        os.environ[\"HELM_RELEASE_NAME\"] + \"-default-priority\"\n    )\n\n# add node-purpose affinity\nmatch_node_purpose = get_config(\"scheduling.userPods.nodeAffinity.matchNodePurpose\")\nif match_node_purpose:\n    node_selector = dict(\n        matchExpressions=[\n            dict(\n                key=\"hub.jupyter.org/node-purpose\",\n                operator=\"In\",\n                values=[\"user\"],\n            )\n        ],\n    )\n    if match_node_purpose == \"prefer\":\n        c.KubeSpawner.node_affinity_preferred.append(\n            dict(\n                weight=100,\n                preference=node_selector,\n            ),\n        )\n    elif match_node_purpose == \"require\":\n        c.KubeSpawner.node_affinity_required.append(node_selector)\n    elif match_node_purpose == \"ignore\":\n        pass\n    else:\n        raise ValueError(\n            \"Unrecognized value for matchNodePurpose: %r\" % match_node_purpose\n        )\n\n# add dedicated-node toleration\nfor key in (\n    \"hub.jupyter.org/dedicated\",\n    # workaround GKE not supporting / in initial node taints\n    \"hub.jupyter.org_dedicated\",\n):\n    c.KubeSpawner.tolerations.append(\n        dict(\n            key=key,\n            operator=\"Equal\",\n            value=\"user\",\n            effect=\"NoSchedule\",\n        )\n    )\n\n# Configure dynamically provisioning pvc\nstorage_type = get_config(\"singleuser.storage.type\")\n\nif storage_type == \"dynamic\":\n    pvc_name_template = get_config(\"singleuser.storage.dynamic.pvcNameTemplate\")\n    c.KubeSpawner.pvc_name_template = pvc_name_template\n    volume_name_template = get_config(\"singleuser.storage.dynamic.volumeNameTemplate\")\n    c.KubeSpawner.storage_pvc_ensure = True\n    set_config_if_not_none(\n        c.KubeSpawner, \"storage_class\", \"singleuser.storage.dynamic.storageClass\"\n    )\n    set_config_if_not_none(\n        c.KubeSpawner,\n        \"storage_access_modes\",\n        \"singleuser.storage.dynamic.storageAccessModes\",\n    )\n    set_config_if_not_none(\n        c.KubeSpawner, \"storage_capacity\", \"singleuser.storage.capacity\"\n    )\n\n    # Add volumes to singleuser pods\n    c.KubeSpawner.volumes = [\n        {\n            \"name\": volume_name_template,\n            \"persistentVolumeClaim\": {\"claimName\": pvc_name_template},\n        }\n    ]\n    c.KubeSpawner.volume_mounts = [\n        {\n            \"mountPath\": get_config(\"singleuser.storage.homeMountPath\"),\n            \"name\": volume_name_template,\n        }\n    ]\nelif storage_type == \"static\":\n    pvc_claim_name = get_config(\"singleuser.storage.static.pvcName\")\n    c.KubeSpawner.volumes = [\n        {\"name\": \"home\", \"persistentVolumeClaim\": {\"claimName\": pvc_claim_name}}\n    ]\n\n    c.KubeSpawner.volume_mounts = [\n        {\n            \"mountPath\": get_config(\"singleuser.storage.homeMountPath\"),\n            \"name\": \"home\",\n            \"subPath\": get_config(\"singleuser.storage.static.subPath\"),\n        }\n    ]\n\nc.KubeSpawner.volumes.extend(get_config(\"singleuser.storage.extraVolumes\", []))\nc.KubeSpawner.volume_mounts.extend(\n    get_config(\"singleuser.storage.extraVolumeMounts\", [])\n)\n\nc.JupyterHub.services = []\n\nif get_config(\"cull.enabled\", False):\n    cull_cmd = [\"python3\", \"-m\", \"jupyterhub_idle_culler\"]\n    base_url = c.JupyterHub.get(\"base_url\", \"/\")\n    cull_cmd.append(\"--url=http://localhost:8081\" + url_path_join(base_url, \"hub/api\"))\n\n    cull_timeout = get_config(\"cull.timeout\")\n    if cull_timeout:\n        cull_cmd.append(\"--timeout=%s\" % cull_timeout)\n\n    cull_every = get_config(\"cull.every\")\n    if cull_every:\n        cull_cmd.append(\"--cull-every=%s\" % cull_every)\n\n    cull_concurrency = get_config(\"cull.concurrency\")\n    if cull_concurrency:\n        cull_cmd.append(\"--concurrency=%s\" % cull_concurrency)\n\n    if get_config(\"cull.users\"):\n        cull_cmd.append(\"--cull-users\")\n\n    if get_config(\"cull.removeNamedServers\"):\n        cull_cmd.append(\"--remove-named-servers\")\n\n    cull_max_age = get_config(\"cull.maxAge\")\n    if cull_max_age:\n        cull_cmd.append(\"--max-age=%s\" % cull_max_age)\n\n    c.JupyterHub.services.append(\n        {\n            \"name\": \"cull-idle\",\n            \"admin\": True,\n            \"command\": cull_cmd,\n        }\n    )\n\nfor name, service in get_config(\"hub.services\", {}).items():\n    # jupyterhub.services is a list of dicts, but\n    # in the helm chart it is a dict of dicts for easier merged-config\n    service.setdefault(\"name\", name)\n    # handle camelCase->snake_case of api_token\n    api_token = service.pop(\"apiToken\", None)\n    if api_token:\n        service[\"api_token\"] = api_token\n    c.JupyterHub.services.append(service)\n\nset_config_if_not_none(c.Spawner, \"cmd\", \"singleuser.cmd\")\nset_config_if_not_none(c.Spawner, \"default_url\", \"singleuser.defaultUrl\")\n\ncloud_metadata = get_config(\"singleuser.cloudMetadata\", {})\n\nif (\n    cloud_metadata.get(\"blockWithIptables\") == True\n    or cloud_metadata.get(\"enabled\") == False\n):\n    # Use iptables to block access to cloud metadata by default\n    network_tools_image_name = get_config(\"singleuser.networkTools.image.name\")\n    network_tools_image_tag = get_config(\"singleuser.networkTools.image.tag\")\n    ip_block_container = client.V1Container(\n        name=\"block-cloud-metadata\",\n        image=f\"{network_tools_image_name}:{network_tools_image_tag}\",\n        command=[\n            \"/bin/bash\"\n        ],\n        args=[\n            \"-ec\",\n            \"install_packages iptables && iptables -A OUTPUT -d \" + cloud_metadata.get(\"ip\", \"169.254.169.254\") + \" -j DROP\"\n        ],\n        security_context=client.V1SecurityContext(\n            privileged=True,\n            run_as_user=0,\n            capabilities=client.V1Capabilities(add=[\"NET_ADMIN\"]),\n        ),\n    )\n\n    c.KubeSpawner.init_containers.append(ip_block_container)\n\nif get_config(\"debug.enabled\", False):\n    c.JupyterHub.log_level = \"DEBUG\"\n    c.Spawner.debug = True\n\n# load hub.config values\nfor section, sub_cfg in get_config(\"hub.config\", {}).items():\n    c[section].update(sub_cfg)\n\n# execute hub.extraConfig string\nextra_config = get_config(\"hub.extraConfig\", {})\nif isinstance(extra_config, str):\n    from textwrap import indent, dedent\n\n    msg = dedent(\n        \"\"\"\n    hub.extraConfig should be a dict of strings,\n    but found a single string instead.\n\n    extraConfig as a single string is deprecated\n    as of the jupyterhub chart version 0.6.\n\n    The keys can be anything identifying the\n    block of extra configuration.\n\n    Try this instead:\n\n        hub:\n          extraConfig:\n            myConfig: |\n              {}\n\n    This configuration will still be loaded,\n    but you are encouraged to adopt the nested form\n    which enables easier merging of multiple extra configurations.\n    \"\"\"\n    )\n    print(msg.format(indent(extra_config, \" \" * 10).lstrip()), file=sys.stderr)\n    extra_config = {\"deprecated string\": extra_config}\n\nfor key, config_py in sorted(extra_config.items()):\n    print(\"Loading extra config: %s\" % key)\n    exec(config_py)\n",
      "z2jh.py": "\"\"\"\nUtility methods for use in jupyterhub_config.py and dynamic subconfigs.\n\nMethods here can be imported by extraConfig in values.yaml\n\"\"\"\nfrom collections import Mapping\nfrom functools import lru_cache\nimport os\n\nimport yaml\n\n# memoize so we only load config once\n@lru_cache()\ndef _load_config():\n    \"\"\"Load configuration from disk\n\n    Memoized to only load once\n    \"\"\"\n    cfg = {}\n    for source in (\"config\", \"secret\"):\n        path = f\"/etc/jupyterhub/{source}/values.yaml\"\n        if os.path.exists(path):\n            print(f\"Loading {path}\")\n            with open(path) as f:\n                values = yaml.safe_load(f)\n            cfg = _merge_dictionaries(cfg, values)\n        else:\n            print(f\"No config at {path}\")\n    return cfg\n\ndef _merge_dictionaries(a, b):\n    \"\"\"Merge two dictionaries recursively.\n\n    Simplified From https://stackoverflow.com/a/7205107\n    \"\"\"\n    merged = a.copy()\n    for key in b:\n        if key in a:\n            if isinstance(a[key], Mapping) and isinstance(b[key], Mapping):\n                merged[key] = _merge_dictionaries(a[key], b[key])\n            else:\n                merged[key] = b[key]\n        else:\n            merged[key] = b[key]\n    return merged\n\ndef get_config(key, default=None):\n    \"\"\"\n    Find a config item of a given name & return it\n\n    Parses everything as YAML, so lists and dicts are available too\n\n    get_config(\"a.b.c\") returns config['a']['b']['c']\n    \"\"\"\n    value = _load_config()\n    # resolve path in yaml\n    for level in key.split(\".\"):\n        if not isinstance(value, dict):\n            # a parent is a scalar or null,\n            # can't resolve full path\n            return default\n        if level not in value:\n            return default\n        else:\n            value = value[level]\n    return value\n\ndef set_config_if_not_none(cparent, name, key):\n    \"\"\"\n    Find a config item of a given name, set the corresponding Jupyter\n    configuration item if not None\n    \"\"\"\n    data = get_config(key)\n    if data is not None:\n        setattr(cparent, name, data)\n"
    }
  },
  {
    "kind": "Role",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-jupyterhub-hub",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      }
    },
    "rules": [
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "pods",
          "persistentvolumeclaims"
        ],
        "verbs": [
          "get",
          "watch",
          "list",
          "create",
          "delete"
        ]
      },
      {
        "apiGroups": [
          ""
        ],
        "resources": [
          "events"
        ],
        "verbs": [
          "get",
          "watch",
          "list"
        ]
      }
    ]
  },
  {
    "kind": "RoleBinding",
    "apiVersion": "rbac.authorization.k8s.io/v1",
    "metadata": {
      "name": "release-name-jupyterhub-hub",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      }
    },
    "subjects": [
      {
        "kind": "ServiceAccount",
        "name": "release-name-jupyterhub-hub",
        "namespace": "default"
      }
    ],
    "roleRef": {
      "kind": "Role",
      "name": "release-name-jupyterhub-hub",
      "apiGroup": "rbac.authorization.k8s.io"
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-postgresql-hl",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "postgresql",
        "helm.sh/chart": "postgresql-11.6.5",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "primary",
        "service.alpha.kubernetes.io/tolerate-unready-endpoints": "true"
      }
    },
    "spec": {
      "type": "ClusterIP",
      "clusterIP": "None",
      "publishNotReadyAddresses": true,
      "ports": [
        {
          "name": "tcp-postgresql",
          "port": 5432,
          "targetPort": "tcp-postgresql"
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "postgresql",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "primary"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-postgresql",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "postgresql",
        "helm.sh/chart": "postgresql-11.6.5",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "primary"
      },
      "annotations": null
    },
    "spec": {
      "type": "ClusterIP",
      "sessionAffinity": "None",
      "ports": [
        {
          "name": "tcp-postgresql",
          "port": 5432,
          "targetPort": "tcp-postgresql",
          "nodePort": null
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "postgresql",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "primary"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-jupyterhub-hub",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      },
      "annotations": null
    },
    "spec": {
      "type": "ClusterIP",
      "sessionAffinity": "None",
      "ports": [
        {
          "name": "http",
          "port": 8081,
          "targetPort": "http",
          "protocol": "TCP",
          "nodePort": null
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "jupyterhub",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "hub"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-jupyterhub-proxy-api",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "proxy"
      },
      "annotations": null
    },
    "spec": {
      "type": "ClusterIP",
      "sessionAffinity": "None",
      "ports": [
        {
          "name": "http",
          "port": 8001,
          "targetPort": "api",
          "protocol": "TCP",
          "nodePort": null
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "jupyterhub",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "proxy"
      }
    }
  },
  {
    "apiVersion": "v1",
    "kind": "Service",
    "metadata": {
      "name": "release-name-jupyterhub-proxy-public",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "proxy"
      },
      "annotations": null
    },
    "spec": {
      "type": "LoadBalancer",
      "externalTrafficPolicy": "Cluster",
      "sessionAffinity": "None",
      "ports": [
        {
          "name": "http",
          "port": 80,
          "targetPort": "http",
          "protocol": "TCP"
        }
      ],
      "selector": {
        "app.kubernetes.io/name": "jupyterhub",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/component": "proxy"
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "DaemonSet",
    "metadata": {
      "name": "release-name-jupyterhub-image-puller",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "image-puller"
      }
    },
    "spec": {
      "updateStrategy": {
        "rollingUpdate": {},
        "type": "RollingUpdate"
      },
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "jupyterhub",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "image-puller"
        }
      },
      "template": {
        "metadata": {
          "labels": {
            "app.kubernetes.io/name": "jupyterhub",
            "helm.sh/chart": "jupyterhub-1.3.6",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "image-puller"
          }
        },
        "spec": {
          "affinity": {
            "podAffinity": null,
            "podAntiAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "podAffinityTerm": {
                    "labelSelector": {
                      "matchLabels": {
                        "app.kubernetes.io/name": "jupyterhub",
                        "app.kubernetes.io/instance": "release-name",
                        "app.kubernetes.io/component": "image-puller"
                      }
                    },
                    "namespaces": [
                      "default"
                    ],
                    "topologyKey": "kubernetes.io/hostname"
                  },
                  "weight": 1
                }
              ]
            },
            "nodeAffinity": null
          },
          "securityContext": {
            "fsGroup": 1001
          },
          "initContainers": [
            {
              "name": "pull-0",
              "image": "docker.io/bitnami/jupyter-base-notebook:1.5.0-debian-11-r3",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ],
              "securityContext": {
                "runAsNonRoot": true,
                "runAsUser": 1001
              }
            },
            {
              "name": "pull-1",
              "image": "docker.io/bitnami/bitnami-shell:11-debian-11-r3",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/bin/sh",
                "-c",
                "echo \"Pulling complete\""
              ],
              "securityContext": {
                "runAsNonRoot": true,
                "runAsUser": 1001
              }
            }
          ],
          "containers": [
            {
              "name": "pause",
              "image": "docker.io/bitnami/bitnami-shell:11-debian-11-r3",
              "imagePullPolicy": "IfNotPresent",
              "securityContext": {
                "runAsNonRoot": true,
                "runAsUser": 11678,
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "command": [
                "/bin/sh",
                "-c",
                "sleep infinity"
              ],
              "envFrom": null,
              "resources": {
                "limits": {},
                "requests": {},
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-jupyterhub-hub",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "hub"
      }
    },
    "spec": {
      "strategy": {
        "rollingUpdate": {},
        "type": "RollingUpdate"
      },
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "jupyterhub",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "hub"
        }
      },
      "template": {
        "metadata": {
          "annotations": {
            "checksum/hub-config": "e21f0c06ddc8892853bab08d90eeb36ddb7b469ea021440a3772bf39133187df",
            "checksum/hub-secret": "6a38d1559296f7c9db93a1d3ceed75133cfe0b1b4874e634f0022d20afed8273"
          },
          "labels": {
            "app.kubernetes.io/name": "jupyterhub",
            "helm.sh/chart": "jupyterhub-1.3.6",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "hub",
            "hub.jupyter.org/network-access-proxy-api": "true",
            "hub.jupyter.org/network-access-proxy-http": "true",
            "hub.jupyter.org/network-access-singleuser": "true"
          }
        },
        "spec": {
          "serviceAccountName": "release-name-jupyterhub-hub",
          "affinity": {
            "podAffinity": null,
            "podAntiAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "podAffinityTerm": {
                    "labelSelector": {
                      "matchLabels": {
                        "app.kubernetes.io/name": "jupyterhub",
                        "app.kubernetes.io/instance": "release-name",
                        "app.kubernetes.io/component": "hub"
                      }
                    },
                    "namespaces": [
                      "default"
                    ],
                    "topologyKey": "kubernetes.io/hostname"
                  },
                  "weight": 1
                }
              ]
            },
            "nodeAffinity": null
          },
          "securityContext": {
            "fsGroup": 1001
          },
          "initContainers": [
            {
              "name": "wait-for-db",
              "image": "docker.io/bitnami/postgresql:14.3.0-debian-11-r0",
              "imagePullPolicy": "IfNotPresent",
              "command": [
                "/bin/bash"
              ],
              "args": [
                "-ec",
                "#!/bin/bash\n\nset -o errexit\nset -o nounset\nset -o pipefail\n\n. /opt/bitnami/scripts/libos.sh\n. /opt/bitnami/scripts/liblog.sh\n. /opt/bitnami/scripts/libpostgresql.sh\n\ncheck_postgresql_connection() {\n    echo \"SELECT 1\" | postgresql_remote_execute \"$POSTGRESQL_CLIENT_DATABASE_HOST\" \"$POSTGRESQL_CLIENT_DATABASE_PORT_NUMBER\" \"$POSTGRESQL_CLIENT_DATABASE_NAME\" \"$POSTGRESQL_CLIENT_POSTGRES_USER\" \"$POSTGRESQL_CLIENT_CREATE_DATABASE_PASSWORD\"\n}\n\ninfo \"Connecting to the PostgreSQL instance $POSTGRESQL_CLIENT_DATABASE_HOST:$POSTGRESQL_CLIENT_DATABASE_PORT_NUMBER\"\nif ! retry_while \"check_postgresql_connection\"; then\n    error \"Could not connect to the database server\"\n    return 1\nelse\n    info \"Connected to the PostgreSQL instance\"\nfi\n"
              ],
              "securityContext": {
                "runAsNonRoot": true,
                "runAsUser": 1000
              },
              "env": [
                {
                  "name": "POSTGRESQL_CLIENT_DATABASE_HOST",
                  "value": "release-name-postgresql"
                },
                {
                  "name": "POSTGRESQL_CLIENT_DATABASE_NAME",
                  "value": "bitnami_jupyterhub"
                },
                {
                  "name": "POSTGRESQL_CLIENT_DATABASE_PORT_NUMBER",
                  "value": "5432"
                },
                {
                  "name": "POSTGRESQL_CLIENT_CREATE_DATABASE_PASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-postgresql",
                      "key": "password"
                    }
                  }
                },
                {
                  "name": "POSTGRESQL_CLIENT_POSTGRES_USER",
                  "value": "bn_jupyterhub"
                }
              ]
            }
          ],
          "containers": [
            {
              "name": "hub",
              "image": "docker.io/bitnami/jupyterhub:1.5.0-debian-11-r3",
              "imagePullPolicy": "IfNotPresent",
              "securityContext": {
                "runAsNonRoot": true,
                "runAsUser": 11140,
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "command": [
                "jupyterhub"
              ],
              "args": [
                "--config",
                "/etc/jupyterhub/jupyterhub_config.py",
                "--upgrade-db"
              ],
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8081
                }
              ],
              "env": [
                {
                  "name": "PYTHONUNBUFFERED",
                  "value": "1"
                },
                {
                  "name": "HELM_RELEASE_NAME",
                  "value": "release-name"
                },
                {
                  "name": "PROXY_API_SERVICE_PORT",
                  "value": "8001"
                },
                {
                  "name": "HUB_SERVICE_PORT",
                  "value": "8081"
                },
                {
                  "name": "POD_NAMESPACE",
                  "valueFrom": {
                    "fieldRef": {
                      "fieldPath": "metadata.namespace"
                    }
                  }
                },
                {
                  "name": "CONFIGPROXY_AUTH_TOKEN",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-jupyterhub-hub",
                      "key": "proxy-token"
                    }
                  }
                },
                {
                  "name": "PGPASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-postgresql",
                      "key": "password"
                    }
                  }
                }
              ],
              "envFrom": null,
              "resources": {
                "limits": {},
                "requests": {},
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "startupProbe": {
                "failureThreshold": 30,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 3,
                "httpGet": {
                  "path": "/hub/health",
                  "port": "http"
                }
              },
              "livenessProbe": {
                "failureThreshold": 30,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 3,
                "httpGet": {
                  "path": "/hub/health",
                  "port": "http"
                }
              },
              "readinessProbe": {
                "failureThreshold": 30,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 3,
                "httpGet": {
                  "path": "/hub/health",
                  "port": "http"
                }
              },
              "volumeMounts": [
                {
                  "mountPath": "/etc/jupyterhub/jupyterhub_config.py",
                  "subPath": "jupyterhub_config.py",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/z2jh.py",
                  "subPath": "z2jh.py",
                  "name": "config"
                },
                {
                  "mountPath": "/etc/jupyterhub/secret/",
                  "name": "secret"
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "config",
              "configMap": {
                "name": "release-name-jupyterhub-hub"
              }
            },
            {
              "name": "secret",
              "secret": {
                "secretName": "release-name-jupyterhub-hub"
              }
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "Deployment",
    "metadata": {
      "name": "release-name-jupyterhub-proxy",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "jupyterhub",
        "helm.sh/chart": "jupyterhub-1.3.6",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "proxy"
      }
    },
    "spec": {
      "strategy": {
        "rollingUpdate": {},
        "type": "RollingUpdate"
      },
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "jupyterhub",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "proxy"
        }
      },
      "template": {
        "metadata": {
          "annotations": {
            "checksum/hub-secret": "c95587fcc48c49e2ed0c681f9c5248d179ea9d5f6022ba77abef3aafefc9aafb"
          },
          "labels": {
            "app.kubernetes.io/name": "jupyterhub",
            "helm.sh/chart": "jupyterhub-1.3.6",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "proxy",
            "hub.jupyter.org/network-access-hub": "true",
            "hub.jupyter.org/network-access-singleuser": "true"
          }
        },
        "spec": {
          "affinity": {
            "podAffinity": null,
            "podAntiAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "podAffinityTerm": {
                    "labelSelector": {
                      "matchLabels": {
                        "app.kubernetes.io/name": "jupyterhub",
                        "app.kubernetes.io/instance": "release-name",
                        "app.kubernetes.io/component": "proxy"
                      }
                    },
                    "namespaces": [
                      "default"
                    ],
                    "topologyKey": "kubernetes.io/hostname"
                  },
                  "weight": 1
                }
              ]
            },
            "nodeAffinity": null
          },
          "securityContext": {
            "fsGroup": 1001
          },
          "containers": [
            {
              "name": "proxy",
              "image": "docker.io/bitnami/configurable-http-proxy:4.5.1-debian-11-r3",
              "imagePullPolicy": "IfNotPresent",
              "securityContext": {
                "runAsNonRoot": true,
                "runAsUser": 11393,
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "args": [
                "configurable-http-proxy",
                "--ip=::",
                "--api-ip=::",
                "--api-port=8001",
                "--default-target=http://release-name-jupyterhub-hub:8081",
                "--error-target=http://release-name-jupyterhub-hub:8081/hub/error",
                "--port=8000"
              ],
              "ports": [
                {
                  "name": "http",
                  "containerPort": 8000,
                  "protocol": "TCP"
                },
                {
                  "name": "api",
                  "containerPort": 8001,
                  "protocol": "TCP"
                }
              ],
              "env": [
                {
                  "name": "CONFIGPROXY_AUTH_TOKEN",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-jupyterhub-hub",
                      "key": "proxy-token"
                    }
                  }
                }
              ],
              "envFrom": null,
              "resources": {
                "limits": {},
                "requests": {},
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "startupProbe": {
                "failureThreshold": 30,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 3,
                "httpGet": {
                  "path": "/_chp_healthz",
                  "port": "http"
                }
              },
              "livenessProbe": {
                "failureThreshold": 30,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 3,
                "httpGet": {
                  "path": "/_chp_healthz",
                  "port": "http"
                }
              },
              "readinessProbe": {
                "failureThreshold": 30,
                "initialDelaySeconds": 10,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 3,
                "httpGet": {
                  "path": "/_chp_healthz",
                  "port": "http"
                }
              },
              "volumeMounts": null
            }
          ]
        }
      }
    }
  },
  {
    "apiVersion": "apps/v1",
    "kind": "StatefulSet",
    "metadata": {
      "name": "release-name-postgresql",
      "namespace": "PKxINInLHAp",
      "labels": {
        "app.kubernetes.io/name": "postgresql",
        "helm.sh/chart": "postgresql-11.6.5",
        "app.kubernetes.io/instance": "release-name",
        "app.kubernetes.io/managed-by": "Helm",
        "app.kubernetes.io/component": "primary"
      },
      "annotations": null
    },
    "spec": {
      "replicas": 1,
      "serviceName": "release-name-postgresql-hl",
      "updateStrategy": {
        "rollingUpdate": {},
        "type": "RollingUpdate"
      },
      "selector": {
        "matchLabels": {
          "app.kubernetes.io/name": "postgresql",
          "app.kubernetes.io/instance": "release-name",
          "app.kubernetes.io/component": "primary"
        }
      },
      "template": {
        "metadata": {
          "name": "release-name-postgresql",
          "labels": {
            "app.kubernetes.io/name": "postgresql",
            "helm.sh/chart": "postgresql-11.6.5",
            "app.kubernetes.io/instance": "release-name",
            "app.kubernetes.io/managed-by": "Helm",
            "app.kubernetes.io/component": "primary"
          },
          "annotations": null
        },
        "spec": {
          "serviceAccountName": "default",
          "affinity": {
            "podAffinity": null,
            "podAntiAffinity": {
              "preferredDuringSchedulingIgnoredDuringExecution": [
                {
                  "podAffinityTerm": {
                    "labelSelector": {
                      "matchLabels": {
                        "app.kubernetes.io/name": "postgresql",
                        "app.kubernetes.io/instance": "release-name",
                        "app.kubernetes.io/component": "primary"
                      }
                    },
                    "namespaces": [
                      "default"
                    ],
                    "topologyKey": "kubernetes.io/hostname"
                  },
                  "weight": 1
                }
              ]
            },
            "nodeAffinity": null
          },
          "securityContext": {
            "fsGroup": 1001
          },
          "hostNetwork": false,
          "hostIPC": false,
          "initContainers": null,
          "containers": [
            {
              "name": "postgresql",
              "image": "docker.io/bitnami/postgresql:14.3.0-debian-11-r0",
              "imagePullPolicy": "IfNotPresent",
              "securityContext": {
                "runAsUser": 10515,
                "allowPrivilegeEscalation": false,
                "capabilities": {
                  "drop": {
                    "": "NET_RAW"
                  }
                },
                "readOnlyRootFilesystem": true
              },
              "env": [
                {
                  "name": "BITNAMI_DEBUG",
                  "value": "false"
                },
                {
                  "name": "POSTGRESQL_PORT_NUMBER",
                  "value": "5432"
                },
                {
                  "name": "POSTGRESQL_VOLUME_DIR",
                  "value": "/bitnami/postgresql"
                },
                {
                  "name": "PGDATA",
                  "value": "/bitnami/postgresql/data"
                },
                {
                  "name": "POSTGRES_USER",
                  "value": "bn_jupyterhub"
                },
                {
                  "name": "POSTGRES_POSTGRES_PASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-postgresql",
                      "key": "postgres-password"
                    }
                  }
                },
                {
                  "name": "POSTGRES_PASSWORD",
                  "valueFrom": {
                    "secretKeyRef": {
                      "name": "release-name-postgresql",
                      "key": "password"
                    }
                  }
                },
                {
                  "name": "POSTGRES_DB",
                  "value": "bitnami_jupyterhub"
                },
                {
                  "name": "POSTGRESQL_ENABLE_LDAP",
                  "value": "no"
                },
                {
                  "name": "POSTGRESQL_ENABLE_TLS",
                  "value": "no"
                },
                {
                  "name": "POSTGRESQL_LOG_HOSTNAME",
                  "value": "false"
                },
                {
                  "name": "POSTGRESQL_LOG_CONNECTIONS",
                  "value": "false"
                },
                {
                  "name": "POSTGRESQL_LOG_DISCONNECTIONS",
                  "value": "false"
                },
                {
                  "name": "POSTGRESQL_PGAUDIT_LOG_CATALOG",
                  "value": "off"
                },
                {
                  "name": "POSTGRESQL_CLIENT_MIN_MESSAGES",
                  "value": "error"
                },
                {
                  "name": "POSTGRESQL_SHARED_PRELOAD_LIBRARIES",
                  "value": "pgaudit"
                }
              ],
              "ports": [
                {
                  "name": "tcp-postgresql",
                  "containerPort": 5432
                }
              ],
              "livenessProbe": {
                "failureThreshold": 6,
                "initialDelaySeconds": 30,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 5,
                "exec": {
                  "command": [
                    "/bin/sh",
                    "-c",
                    "exec pg_isready -U \"bn_jupyterhub\" -d \"dbname=bitnami_jupyterhub\" -h 127.0.0.1 -p 5432"
                  ]
                }
              },
              "readinessProbe": {
                "failureThreshold": 6,
                "initialDelaySeconds": 5,
                "periodSeconds": 10,
                "successThreshold": 1,
                "timeoutSeconds": 5,
                "exec": {
                  "command": [
                    "/bin/sh",
                    "-c",
                    "-e",
                    "exec pg_isready -U \"bn_jupyterhub\" -d \"dbname=bitnami_jupyterhub\" -h 127.0.0.1 -p 5432\n[ -f /opt/bitnami/postgresql/tmp/.initialized ] || [ -f /bitnami/postgresql/.initialized ]\n"
                  ]
                }
              },
              "resources": {
                "limits": {},
                "requests": {
                  "cpu": "250m",
                  "memory": "256Mi"
                },
                "seccompProfile": {
                  "type": "RuntimeDefault"
                }
              },
              "volumeMounts": [
                {
                  "name": "dshm",
                  "mountPath": "/dev/shm"
                },
                {
                  "name": "data",
                  "mountPath": "/bitnami/postgresql"
                }
              ]
            }
          ],
          "volumes": [
            {
              "name": "dshm",
              "emptyDir": {
                "medium": "Memory"
              }
            }
          ]
        }
      },
      "volumeClaimTemplates": [
        {
          "metadata": {
            "name": "data"
          },
          "spec": {
            "accessModes": [
              "ReadWriteOnce"
            ],
            "resources": {
              "requests": {
                "storage": "8Gi"
              }
            }
          }
        }
      ]
    }
  }
]