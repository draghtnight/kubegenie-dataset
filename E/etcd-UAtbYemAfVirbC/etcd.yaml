apiVersion: v1
kind: PersistentVolume
metadata:
  name: release-etcd-data-0
  namespace: default
  labels:
    app: release-etcd
    chart: etcd-6.0.0
    release: release
    heritage: Helm
    name: release-etcd
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: null
  storageClassName: release-etcd-data
  hostPath:
    path: /dockerdata-nfs/release/k8s-etcd-0
---
apiVersion: v1
kind: Service
metadata:
  name: k8s-etcd
  labels:
    heritage: Helm
    release: release
    chart: etcd-6.0.0
    app: etcd
spec:
  ports:
    - name: etcd-server
      port: 2380
    - name: etcd-client
      port: 2379
  clusterIP: None
  selector:
    app: etcd
    release: release
---
apiVersion: apps/v1beta1
kind: StatefulSet
metadata:
  name: release-etcd
  labels:
    heritage: Helm
    release: release
    chart: etcd-6.0.0
    app: etcd
spec:
  serviceName: k8s-etcd
  replicas: 1
  template:
    metadata:
      labels:
        heritage: Helm
        release: release
        chart: etcd-6.0.0
        app: etcd
    spec:
      containers:
        - name: release-etcd
          image: k8s.gcr.io/etcd-amd64:3.2.24
          imagePullPolicy: Always
          ports:
            - containerPort: 2380
              name: etcd-server
            - containerPort: 2379
              name: etcd-client
          livenessProbe:
            tcpSocket:
              port: 2379
            initialDelaySeconds: 90
            periodSeconds: 30
            timeoutSeconds: 5
          resources: null
          env:
            - name: INITIAL_CLUSTER_SIZE
              value: "1"
            - name: SET_NAME
              value: release-etcd
            - name: SERVICE_NAME
              value: k8s-etcd
          lifecycle:
            preStop:
              exec:
                command:
                  - /bin/sh
                  - -ec
                  - |
                    EPS=""
                    for i in $(seq 0 $((${INITIAL_CLUSTER_SIZE} - 1))); do
                        EPS="${EPS}${EPS:+,}http://${SET_NAME}-${i}.${SERVICE_NAME}:2379"
                    done

                    HOSTNAME=$(hostname)

                    member_hash() {
                        etcdctl member list | grep http://${HOSTNAME}.${SERVICE_NAME}:2380 | cut -d':' -f1 | cut -d'[' -f1
                    }

                    SET_ID=${HOSTNAME##*[^0-9]}

                    if [ "${SET_ID}" -ge ${INITIAL_CLUSTER_SIZE} ]; then
                        echo "Removing ${HOSTNAME} from etcd cluster"
                        ETCDCTL_ENDPOINT=${EPS} etcdctl member remove $(member_hash)
                        if [ $? -eq 0 ]; then
                            # Remove everything otherwise the cluster will no longer scale-up
                            rm -rf /var/run/etcd/*
                        fi
                    fi
          command:
            - /bin/sh
            - -ec
            - |
              HOSTNAME=$(hostname)

              # store member id into PVC for later member replacement
              collect_member() {
                  while ! etcdctl member list &>/dev/null; do sleep 1; done
                  etcdctl member list | grep http://${HOSTNAME}.${SERVICE_NAME}:2380 | cut -d':' -f1 | cut -d'[' -f1 > /var/run/etcd/member_id
                  exit 0
              }

              eps() {
                  EPS=""
                  for i in $(seq 0 $((${INITIAL_CLUSTER_SIZE} - 1))); do
                      EPS="${EPS}${EPS:+,}http://${SET_NAME}-${i}.${SERVICE_NAME}:2379"
                  done
                  echo ${EPS}
              }

              member_hash() {
                  etcdctl member list | grep http://${HOSTNAME}.${SERVICE_NAME}:2380 | cut -d':' -f1 | cut -d'[' -f1
              }

              # we should wait for other pods to be up before trying to join
              # otherwise we got "no such host" errors when trying to resolve other members
              for i in $(seq 0 $((${INITIAL_CLUSTER_SIZE} - 1))); do
                  while true; do
                      echo "Waiting for ${SET_NAME}-${i}.${SERVICE_NAME} to come up"
                      ping -W 1 -c 1 ${SET_NAME}-${i}.${SERVICE_NAME} > /dev/null && break
                      sleep 1s
                  done
              done

              # re-joining after failure?
              if [[ -e /var/run/etcd/default.etcd && -f /var/run/etcd/member_id ]]; then
                  echo "Re-joining etcd member"
                  member_id=$(cat /var/run/etcd/member_id)

                  # re-join member
                  ETCDCTL_ENDPOINT=$(eps) etcdctl member update ${member_id} http://${HOSTNAME}.${SERVICE_NAME}:2380 | true
                  exec etcd --name ${HOSTNAME} \
                      --listen-peer-urls http://0.0.0.0:2380 \
                      --listen-client-urls http://0.0.0.0:2379\
                      --advertise-client-urls http://${HOSTNAME}.${SERVICE_NAME}:2379 \
                      --data-dir /var/run/etcd/default.etcd
              fi

              # etcd-SET_ID
              SET_ID=${HOSTNAME##*[^0-9]}

              # adding a new member to existing cluster (assuming all initial pods are available)
              if [ "${SET_ID}" -ge ${INITIAL_CLUSTER_SIZE} ]; then
                  export ETCDCTL_ENDPOINT=$(eps)

                  # member already added?
                  MEMBER_HASH=$(member_hash)
                  if [ -n "${MEMBER_HASH}" ]; then
                      # the member hash exists but for some reason etcd failed
                      # as the datadir has not be created, we can remove the member
                      # and retrieve new hash
                      etcdctl member remove ${MEMBER_HASH}
                  fi

                  echo "Adding new member"
                  etcdctl member add ${HOSTNAME} http://${HOSTNAME}.${SERVICE_NAME}:2380 | grep "^ETCD_" > /var/run/etcd/new_member_envs

                  if [ $? -ne 0 ]; then
                      echo "Exiting"
                      rm -f /var/run/etcd/new_member_envs
                      exit 1
                  fi

                  cat /var/run/etcd/new_member_envs
                  source /var/run/etcd/new_member_envs

                  collect_member &

                  exec etcd --name ${HOSTNAME} \
                      --listen-peer-urls http://0.0.0.0:2380 \
                      --listen-client-urls http://0.0.0.0:2379 \
                      --advertise-client-urls http://${HOSTNAME}.${SERVICE_NAME}:2379 \
                      --data-dir /var/run/etcd/default.etcd \
                      --initial-advertise-peer-urls http://${HOSTNAME}.${SERVICE_NAME}:2380 \
                      --initial-cluster ${ETCD_INITIAL_CLUSTER} \
                      --initial-cluster-state ${ETCD_INITIAL_CLUSTER_STATE}
              fi

              PEERS=""
              for i in $(seq 0 $((${INITIAL_CLUSTER_SIZE} - 1))); do
                  PEERS="${PEERS}${PEERS:+,}${SET_NAME}-${i}=http://${SET_NAME}-${i}.${SERVICE_NAME}:2380"
              done

              collect_member &

              # join member
              exec etcd --name ${HOSTNAME} \
                  --initial-advertise-peer-urls http://${HOSTNAME}.${SERVICE_NAME}:2380 \
                  --listen-peer-urls http://0.0.0.0:2380 \
                  --listen-client-urls http://0.0.0.0:2379 \
                  --advertise-client-urls http://${HOSTNAME}.${SERVICE_NAME}:2379 \
                  --initial-cluster-token etcd-cluster-1 \
                  --initial-cluster ${PEERS} \
                  --initial-cluster-state new \
                  --data-dir /var/run/etcd/default.etcd
          volumeMounts:
            - name: release-etcd-data
              mountPath: /var/run/etcd
  volumeClaimTemplates:
    - metadata:
        name: release-etcd-data
        labels:
          name: release-etcd
          chart: etcd-6.0.0
          release: release
          heritage: Helm
      spec:
        accessModes:
          - ReadWriteOnce
        storageClassName: release-etcd-data
        resources:
          requests:
            storage: 1Gi
---
null
